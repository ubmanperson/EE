// src/generated/calibration/CalibratedClassifierCV.ts
import crypto from "node:crypto";
var CalibratedClassifierCV = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `CalibratedClassifierCV${crypto.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This CalibratedClassifierCV instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "CalibratedClassifierCV.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.calibration import CalibratedClassifierCV
try: bridgeCalibratedClassifierCV
except NameError: bridgeCalibratedClassifierCV = {}
`;
    await this._py.ex`ctor_CalibratedClassifierCV = {'estimator': ${this.opts["estimator"] ?? void 0}, 'method': ${this.opts["method"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'ensemble': ${this.opts["ensemble"] ?? void 0}}

ctor_CalibratedClassifierCV = {k: v for k, v in ctor_CalibratedClassifierCV.items() if v is not None}`;
    await this._py.ex`bridgeCalibratedClassifierCV[${this.id}] = CalibratedClassifierCV(**ctor_CalibratedClassifierCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeCalibratedClassifierCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the calibrated model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This CalibratedClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("CalibratedClassifierCV must call init() before fit()");
    }
    await this._py.ex`pms_CalibratedClassifierCV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_CalibratedClassifierCV_fit = {k: v for k, v in pms_CalibratedClassifierCV_fit.items() if v is not None}`;
    await this._py.ex`res_CalibratedClassifierCV_fit = bridgeCalibratedClassifierCV[${this.id}].fit(**pms_CalibratedClassifierCV_fit)`;
    return this._py`res_CalibratedClassifierCV_fit.tolist() if hasattr(res_CalibratedClassifierCV_fit, 'tolist') else res_CalibratedClassifierCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This CalibratedClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibratedClassifierCV must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_CalibratedClassifierCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_CalibratedClassifierCV_get_metadata_routing = {k: v for k, v in pms_CalibratedClassifierCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_CalibratedClassifierCV_get_metadata_routing = bridgeCalibratedClassifierCV[${this.id}].get_metadata_routing(**pms_CalibratedClassifierCV_get_metadata_routing)`;
    return this._py`res_CalibratedClassifierCV_get_metadata_routing.tolist() if hasattr(res_CalibratedClassifierCV_get_metadata_routing, 'tolist') else res_CalibratedClassifierCV_get_metadata_routing`;
  }
  /**
      Predict the target of new samples.
  
      The predicted class is the class that has the highest probability, and can thus be different from the prediction of the uncalibrated classifier.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This CalibratedClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibratedClassifierCV must call init() before predict()"
      );
    }
    await this._py.ex`pms_CalibratedClassifierCV_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_CalibratedClassifierCV_predict = {k: v for k, v in pms_CalibratedClassifierCV_predict.items() if v is not None}`;
    await this._py.ex`res_CalibratedClassifierCV_predict = bridgeCalibratedClassifierCV[${this.id}].predict(**pms_CalibratedClassifierCV_predict)`;
    return this._py`res_CalibratedClassifierCV_predict.tolist() if hasattr(res_CalibratedClassifierCV_predict, 'tolist') else res_CalibratedClassifierCV_predict`;
  }
  /**
      Calibrated probabilities of classification.
  
      This function returns calibrated probabilities of classification according to each class on an array of test vectors X.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This CalibratedClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibratedClassifierCV must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_CalibratedClassifierCV_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_CalibratedClassifierCV_predict_proba = {k: v for k, v in pms_CalibratedClassifierCV_predict_proba.items() if v is not None}`;
    await this._py.ex`res_CalibratedClassifierCV_predict_proba = bridgeCalibratedClassifierCV[${this.id}].predict_proba(**pms_CalibratedClassifierCV_predict_proba)`;
    return this._py`res_CalibratedClassifierCV_predict_proba.tolist() if hasattr(res_CalibratedClassifierCV_predict_proba, 'tolist') else res_CalibratedClassifierCV_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This CalibratedClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("CalibratedClassifierCV must call init() before score()");
    }
    await this._py.ex`pms_CalibratedClassifierCV_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_CalibratedClassifierCV_score = {k: v for k, v in pms_CalibratedClassifierCV_score.items() if v is not None}`;
    await this._py.ex`res_CalibratedClassifierCV_score = bridgeCalibratedClassifierCV[${this.id}].score(**pms_CalibratedClassifierCV_score)`;
    return this._py`res_CalibratedClassifierCV_score.tolist() if hasattr(res_CalibratedClassifierCV_score, 'tolist') else res_CalibratedClassifierCV_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This CalibratedClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibratedClassifierCV must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_CalibratedClassifierCV_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_CalibratedClassifierCV_set_fit_request = {k: v for k, v in pms_CalibratedClassifierCV_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_CalibratedClassifierCV_set_fit_request = bridgeCalibratedClassifierCV[${this.id}].set_fit_request(**pms_CalibratedClassifierCV_set_fit_request)`;
    return this._py`res_CalibratedClassifierCV_set_fit_request.tolist() if hasattr(res_CalibratedClassifierCV_set_fit_request, 'tolist') else res_CalibratedClassifierCV_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This CalibratedClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibratedClassifierCV must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_CalibratedClassifierCV_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_CalibratedClassifierCV_set_score_request = {k: v for k, v in pms_CalibratedClassifierCV_set_score_request.items() if v is not None}`;
    await this._py.ex`res_CalibratedClassifierCV_set_score_request = bridgeCalibratedClassifierCV[${this.id}].set_score_request(**pms_CalibratedClassifierCV_set_score_request)`;
    return this._py`res_CalibratedClassifierCV_set_score_request.tolist() if hasattr(res_CalibratedClassifierCV_set_score_request, 'tolist') else res_CalibratedClassifierCV_set_score_request`;
  }
  /**
    The class labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This CalibratedClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibratedClassifierCV must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_CalibratedClassifierCV_classes_ = bridgeCalibratedClassifierCV[${this.id}].classes_`;
      return this._py`attr_CalibratedClassifierCV_classes_.tolist() if hasattr(attr_CalibratedClassifierCV_classes_, 'tolist') else attr_CalibratedClassifierCV_classes_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Only defined if the underlying estimator exposes such an attribute when fit.
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This CalibratedClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibratedClassifierCV must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_CalibratedClassifierCV_n_features_in_ = bridgeCalibratedClassifierCV[${this.id}].n_features_in_`;
      return this._py`attr_CalibratedClassifierCV_n_features_in_.tolist() if hasattr(attr_CalibratedClassifierCV_n_features_in_, 'tolist') else attr_CalibratedClassifierCV_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Only defined if the underlying estimator exposes such an attribute when fit.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This CalibratedClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibratedClassifierCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_CalibratedClassifierCV_feature_names_in_ = bridgeCalibratedClassifierCV[${this.id}].feature_names_in_`;
      return this._py`attr_CalibratedClassifierCV_feature_names_in_.tolist() if hasattr(attr_CalibratedClassifierCV_feature_names_in_, 'tolist') else attr_CalibratedClassifierCV_feature_names_in_`;
    })();
  }
  /**
    The list of classifier and calibrator pairs.
   */
  get calibrated_classifiers_() {
    if (this._isDisposed) {
      throw new Error(
        "This CalibratedClassifierCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibratedClassifierCV must call init() before accessing calibrated_classifiers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_CalibratedClassifierCV_calibrated_classifiers_ = bridgeCalibratedClassifierCV[${this.id}].calibrated_classifiers_`;
      return this._py`attr_CalibratedClassifierCV_calibrated_classifiers_.tolist() if hasattr(attr_CalibratedClassifierCV_calibrated_classifiers_, 'tolist') else attr_CalibratedClassifierCV_calibrated_classifiers_`;
    })();
  }
};

// src/generated/calibration/CalibrationDisplay.ts
import crypto2 from "node:crypto";
var CalibrationDisplay = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `CalibrationDisplay${crypto2.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This CalibrationDisplay instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "CalibrationDisplay.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.calibration import CalibrationDisplay
try: bridgeCalibrationDisplay
except NameError: bridgeCalibrationDisplay = {}
`;
    await this._py.ex`ctor_CalibrationDisplay = {'prob_true': np.array(${this.opts["prob_true"] ?? void 0}) if ${this.opts["prob_true"] !== void 0} else None, 'prob_pred': np.array(${this.opts["prob_pred"] ?? void 0}) if ${this.opts["prob_pred"] !== void 0} else None, 'y_prob': np.array(${this.opts["y_prob"] ?? void 0}) if ${this.opts["y_prob"] !== void 0} else None, 'estimator_name': ${this.opts["estimator_name"] ?? void 0}, 'pos_label': ${this.opts["pos_label"] ?? void 0}}

ctor_CalibrationDisplay = {k: v for k, v in ctor_CalibrationDisplay.items() if v is not None}`;
    await this._py.ex`bridgeCalibrationDisplay[${this.id}] = CalibrationDisplay(**ctor_CalibrationDisplay)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeCalibrationDisplay[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Plot calibration curve using a binary classifier and data.
  
      A calibration curve, also known as a reliability diagram, uses inputs from a binary classifier and plots the average predicted probability for each bin against the fraction of positive classes, on the y-axis.
  
      Extra keyword arguments will be passed to [`matplotlib.pyplot.plot`](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot "(in Matplotlib v3.9.2)").
  
      Read more about calibration in the [User Guide](https://scikit-learn.org/stable/modules/generated/../calibration.html#calibration) and more about the scikit-learn visualization API in [Visualizations](https://scikit-learn.org/stable/modules/generated/../../visualizations.html#visualizations).
     */
  async from_estimator(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This CalibrationDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibrationDisplay must call init() before from_estimator()"
      );
    }
    await this._py.ex`pms_CalibrationDisplay_from_estimator = {'estimator': ${opts["estimator"] ?? void 0}, 'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'n_bins': ${opts["n_bins"] ?? void 0}, 'strategy': ${opts["strategy"] ?? void 0}, 'pos_label': ${opts["pos_label"] ?? void 0}, 'name': ${opts["name"] ?? void 0}, 'ref_line': ${opts["ref_line"] ?? void 0}, 'ax': ${opts["ax"] ?? void 0}, 'kwargs': ${opts["kwargs"] ?? void 0}}

pms_CalibrationDisplay_from_estimator = {k: v for k, v in pms_CalibrationDisplay_from_estimator.items() if v is not None}`;
    await this._py.ex`res_CalibrationDisplay_from_estimator = bridgeCalibrationDisplay[${this.id}].from_estimator(**pms_CalibrationDisplay_from_estimator)`;
    return this._py`res_CalibrationDisplay_from_estimator.tolist() if hasattr(res_CalibrationDisplay_from_estimator, 'tolist') else res_CalibrationDisplay_from_estimator`;
  }
  /**
      Plot calibration curve using true labels and predicted probabilities.
  
      Calibration curve, also known as reliability diagram, uses inputs from a binary classifier and plots the average predicted probability for each bin against the fraction of positive classes, on the y-axis.
  
      Extra keyword arguments will be passed to [`matplotlib.pyplot.plot`](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot "(in Matplotlib v3.9.2)").
  
      Read more about calibration in the [User Guide](https://scikit-learn.org/stable/modules/generated/../calibration.html#calibration) and more about the scikit-learn visualization API in [Visualizations](https://scikit-learn.org/stable/modules/generated/../../visualizations.html#visualizations).
     */
  async from_predictions(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This CalibrationDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibrationDisplay must call init() before from_predictions()"
      );
    }
    await this._py.ex`pms_CalibrationDisplay_from_predictions = {'y_true': np.array(${opts["y_true"] ?? void 0}) if ${opts["y_true"] !== void 0} else None, 'y_prob': np.array(${opts["y_prob"] ?? void 0}) if ${opts["y_prob"] !== void 0} else None, 'n_bins': ${opts["n_bins"] ?? void 0}, 'strategy': ${opts["strategy"] ?? void 0}, 'pos_label': ${opts["pos_label"] ?? void 0}, 'name': ${opts["name"] ?? void 0}, 'ref_line': ${opts["ref_line"] ?? void 0}, 'ax': ${opts["ax"] ?? void 0}, 'kwargs': ${opts["kwargs"] ?? void 0}}

pms_CalibrationDisplay_from_predictions = {k: v for k, v in pms_CalibrationDisplay_from_predictions.items() if v is not None}`;
    await this._py.ex`res_CalibrationDisplay_from_predictions = bridgeCalibrationDisplay[${this.id}].from_predictions(**pms_CalibrationDisplay_from_predictions)`;
    return this._py`res_CalibrationDisplay_from_predictions.tolist() if hasattr(res_CalibrationDisplay_from_predictions, 'tolist') else res_CalibrationDisplay_from_predictions`;
  }
  /**
      Plot visualization.
  
      Extra keyword arguments will be passed to [`matplotlib.pyplot.plot`](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot "(in Matplotlib v3.9.2)").
     */
  async plot(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This CalibrationDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("CalibrationDisplay must call init() before plot()");
    }
    await this._py.ex`pms_CalibrationDisplay_plot = {'ax': ${opts["ax"] ?? void 0}, 'name': ${opts["name"] ?? void 0}, 'ref_line': ${opts["ref_line"] ?? void 0}, 'kwargs': ${opts["kwargs"] ?? void 0}}

pms_CalibrationDisplay_plot = {k: v for k, v in pms_CalibrationDisplay_plot.items() if v is not None}`;
    await this._py.ex`res_CalibrationDisplay_plot = bridgeCalibrationDisplay[${this.id}].plot(**pms_CalibrationDisplay_plot)`;
    return this._py`res_CalibrationDisplay_plot.tolist() if hasattr(res_CalibrationDisplay_plot, 'tolist') else res_CalibrationDisplay_plot`;
  }
  /**
    Calibration curve.
   */
  get line_() {
    if (this._isDisposed) {
      throw new Error(
        "This CalibrationDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibrationDisplay must call init() before accessing line_"
      );
    }
    return (async () => {
      await this._py.ex`attr_CalibrationDisplay_line_ = bridgeCalibrationDisplay[${this.id}].line_`;
      return this._py`attr_CalibrationDisplay_line_.tolist() if hasattr(attr_CalibrationDisplay_line_, 'tolist') else attr_CalibrationDisplay_line_`;
    })();
  }
  /**
    Axes with calibration curve.
   */
  get ax_() {
    if (this._isDisposed) {
      throw new Error(
        "This CalibrationDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibrationDisplay must call init() before accessing ax_"
      );
    }
    return (async () => {
      await this._py.ex`attr_CalibrationDisplay_ax_ = bridgeCalibrationDisplay[${this.id}].ax_`;
      return this._py`attr_CalibrationDisplay_ax_.tolist() if hasattr(attr_CalibrationDisplay_ax_, 'tolist') else attr_CalibrationDisplay_ax_`;
    })();
  }
  /**
    Figure containing the curve.
   */
  get figure_() {
    if (this._isDisposed) {
      throw new Error(
        "This CalibrationDisplay instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "CalibrationDisplay must call init() before accessing figure_"
      );
    }
    return (async () => {
      await this._py.ex`attr_CalibrationDisplay_figure_ = bridgeCalibrationDisplay[${this.id}].figure_`;
      return this._py`attr_CalibrationDisplay_figure_.tolist() if hasattr(attr_CalibrationDisplay_figure_, 'tolist') else attr_CalibrationDisplay_figure_`;
    })();
  }
};

// src/generated/cluster/AffinityPropagation.ts
import crypto3 from "node:crypto";
var AffinityPropagation = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `AffinityPropagation${crypto3.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "AffinityPropagation.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import AffinityPropagation
try: bridgeAffinityPropagation
except NameError: bridgeAffinityPropagation = {}
`;
    await this._py.ex`ctor_AffinityPropagation = {'damping': ${this.opts["damping"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'convergence_iter': ${this.opts["convergence_iter"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}, 'preference': np.array(${this.opts["preference"] ?? void 0}) if ${this.opts["preference"] !== void 0} else None, 'affinity': ${this.opts["affinity"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_AffinityPropagation = {k: v for k, v in ctor_AffinityPropagation.items() if v is not None}`;
    await this._py.ex`bridgeAffinityPropagation[${this.id}] = AffinityPropagation(**ctor_AffinityPropagation)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeAffinityPropagation[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the clustering from features, or affinity matrix.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("AffinityPropagation must call init() before fit()");
    }
    await this._py.ex`pms_AffinityPropagation_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_AffinityPropagation_fit = {k: v for k, v in pms_AffinityPropagation_fit.items() if v is not None}`;
    await this._py.ex`res_AffinityPropagation_fit = bridgeAffinityPropagation[${this.id}].fit(**pms_AffinityPropagation_fit)`;
    return this._py`res_AffinityPropagation_fit.tolist() if hasattr(res_AffinityPropagation_fit, 'tolist') else res_AffinityPropagation_fit`;
  }
  /**
    Fit clustering from features/affinity matrix; return cluster labels.
   */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AffinityPropagation must call init() before fit_predict()"
      );
    }
    await this._py.ex`pms_AffinityPropagation_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_AffinityPropagation_fit_predict = {k: v for k, v in pms_AffinityPropagation_fit_predict.items() if v is not None}`;
    await this._py.ex`res_AffinityPropagation_fit_predict = bridgeAffinityPropagation[${this.id}].fit_predict(**pms_AffinityPropagation_fit_predict)`;
    return this._py`res_AffinityPropagation_fit_predict.tolist() if hasattr(res_AffinityPropagation_fit_predict, 'tolist') else res_AffinityPropagation_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AffinityPropagation must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_AffinityPropagation_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_AffinityPropagation_get_metadata_routing = {k: v for k, v in pms_AffinityPropagation_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_AffinityPropagation_get_metadata_routing = bridgeAffinityPropagation[${this.id}].get_metadata_routing(**pms_AffinityPropagation_get_metadata_routing)`;
    return this._py`res_AffinityPropagation_get_metadata_routing.tolist() if hasattr(res_AffinityPropagation_get_metadata_routing, 'tolist') else res_AffinityPropagation_get_metadata_routing`;
  }
  /**
    Predict the closest cluster each sample in X belongs to.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("AffinityPropagation must call init() before predict()");
    }
    await this._py.ex`pms_AffinityPropagation_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AffinityPropagation_predict = {k: v for k, v in pms_AffinityPropagation_predict.items() if v is not None}`;
    await this._py.ex`res_AffinityPropagation_predict = bridgeAffinityPropagation[${this.id}].predict(**pms_AffinityPropagation_predict)`;
    return this._py`res_AffinityPropagation_predict.tolist() if hasattr(res_AffinityPropagation_predict, 'tolist') else res_AffinityPropagation_predict`;
  }
  /**
    Indices of cluster centers.
   */
  get cluster_centers_indices_() {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AffinityPropagation must call init() before accessing cluster_centers_indices_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AffinityPropagation_cluster_centers_indices_ = bridgeAffinityPropagation[${this.id}].cluster_centers_indices_`;
      return this._py`attr_AffinityPropagation_cluster_centers_indices_.tolist() if hasattr(attr_AffinityPropagation_cluster_centers_indices_, 'tolist') else attr_AffinityPropagation_cluster_centers_indices_`;
    })();
  }
  /**
    Cluster centers (if affinity != `precomputed`).
   */
  get cluster_centers_() {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AffinityPropagation must call init() before accessing cluster_centers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AffinityPropagation_cluster_centers_ = bridgeAffinityPropagation[${this.id}].cluster_centers_`;
      return this._py`attr_AffinityPropagation_cluster_centers_.tolist() if hasattr(attr_AffinityPropagation_cluster_centers_, 'tolist') else attr_AffinityPropagation_cluster_centers_`;
    })();
  }
  /**
    Labels of each point.
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AffinityPropagation must call init() before accessing labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AffinityPropagation_labels_ = bridgeAffinityPropagation[${this.id}].labels_`;
      return this._py`attr_AffinityPropagation_labels_.tolist() if hasattr(attr_AffinityPropagation_labels_, 'tolist') else attr_AffinityPropagation_labels_`;
    })();
  }
  /**
    Stores the affinity matrix used in `fit`.
   */
  get affinity_matrix_() {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AffinityPropagation must call init() before accessing affinity_matrix_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AffinityPropagation_affinity_matrix_ = bridgeAffinityPropagation[${this.id}].affinity_matrix_`;
      return this._py`attr_AffinityPropagation_affinity_matrix_.tolist() if hasattr(attr_AffinityPropagation_affinity_matrix_, 'tolist') else attr_AffinityPropagation_affinity_matrix_`;
    })();
  }
  /**
    Number of iterations taken to converge.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AffinityPropagation must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AffinityPropagation_n_iter_ = bridgeAffinityPropagation[${this.id}].n_iter_`;
      return this._py`attr_AffinityPropagation_n_iter_.tolist() if hasattr(attr_AffinityPropagation_n_iter_, 'tolist') else attr_AffinityPropagation_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AffinityPropagation must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AffinityPropagation_n_features_in_ = bridgeAffinityPropagation[${this.id}].n_features_in_`;
      return this._py`attr_AffinityPropagation_n_features_in_.tolist() if hasattr(attr_AffinityPropagation_n_features_in_, 'tolist') else attr_AffinityPropagation_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This AffinityPropagation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AffinityPropagation must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AffinityPropagation_feature_names_in_ = bridgeAffinityPropagation[${this.id}].feature_names_in_`;
      return this._py`attr_AffinityPropagation_feature_names_in_.tolist() if hasattr(attr_AffinityPropagation_feature_names_in_, 'tolist') else attr_AffinityPropagation_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/AgglomerativeClustering.ts
import crypto4 from "node:crypto";
var AgglomerativeClustering = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `AgglomerativeClustering${crypto4.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "AgglomerativeClustering.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import AgglomerativeClustering
try: bridgeAgglomerativeClustering
except NameError: bridgeAgglomerativeClustering = {}
`;
    await this._py.ex`ctor_AgglomerativeClustering = {'n_clusters': ${this.opts["n_clusters"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'memory': ${this.opts["memory"] ?? void 0}, 'connectivity': ${this.opts["connectivity"] ?? void 0}, 'compute_full_tree': ${this.opts["compute_full_tree"] ?? void 0}, 'linkage': ${this.opts["linkage"] ?? void 0}, 'distance_threshold': ${this.opts["distance_threshold"] ?? void 0}, 'compute_distances': ${this.opts["compute_distances"] ?? void 0}}

ctor_AgglomerativeClustering = {k: v for k, v in ctor_AgglomerativeClustering.items() if v is not None}`;
    await this._py.ex`bridgeAgglomerativeClustering[${this.id}] = AgglomerativeClustering(**ctor_AgglomerativeClustering)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeAgglomerativeClustering[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the hierarchical clustering from features, or distance matrix.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("AgglomerativeClustering must call init() before fit()");
    }
    await this._py.ex`pms_AgglomerativeClustering_fit = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}}

pms_AgglomerativeClustering_fit = {k: v for k, v in pms_AgglomerativeClustering_fit.items() if v is not None}`;
    await this._py.ex`res_AgglomerativeClustering_fit = bridgeAgglomerativeClustering[${this.id}].fit(**pms_AgglomerativeClustering_fit)`;
    return this._py`res_AgglomerativeClustering_fit.tolist() if hasattr(res_AgglomerativeClustering_fit, 'tolist') else res_AgglomerativeClustering_fit`;
  }
  /**
      Fit and return the result of each sample’s clustering assignment.
  
      In addition to fitting, this method also return the result of the clustering assignment for each sample in the training set.
     */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before fit_predict()"
      );
    }
    await this._py.ex`pms_AgglomerativeClustering_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_AgglomerativeClustering_fit_predict = {k: v for k, v in pms_AgglomerativeClustering_fit_predict.items() if v is not None}`;
    await this._py.ex`res_AgglomerativeClustering_fit_predict = bridgeAgglomerativeClustering[${this.id}].fit_predict(**pms_AgglomerativeClustering_fit_predict)`;
    return this._py`res_AgglomerativeClustering_fit_predict.tolist() if hasattr(res_AgglomerativeClustering_fit_predict, 'tolist') else res_AgglomerativeClustering_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_AgglomerativeClustering_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_AgglomerativeClustering_get_metadata_routing = {k: v for k, v in pms_AgglomerativeClustering_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_AgglomerativeClustering_get_metadata_routing = bridgeAgglomerativeClustering[${this.id}].get_metadata_routing(**pms_AgglomerativeClustering_get_metadata_routing)`;
    return this._py`res_AgglomerativeClustering_get_metadata_routing.tolist() if hasattr(res_AgglomerativeClustering_get_metadata_routing, 'tolist') else res_AgglomerativeClustering_get_metadata_routing`;
  }
  /**
    The number of clusters found by the algorithm. If `distance_threshold=None`, it will be equal to the given `n_clusters`.
   */
  get n_clusters_() {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before accessing n_clusters_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AgglomerativeClustering_n_clusters_ = bridgeAgglomerativeClustering[${this.id}].n_clusters_`;
      return this._py`attr_AgglomerativeClustering_n_clusters_.tolist() if hasattr(attr_AgglomerativeClustering_n_clusters_, 'tolist') else attr_AgglomerativeClustering_n_clusters_`;
    })();
  }
  /**
    Cluster labels for each point.
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before accessing labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AgglomerativeClustering_labels_ = bridgeAgglomerativeClustering[${this.id}].labels_`;
      return this._py`attr_AgglomerativeClustering_labels_.tolist() if hasattr(attr_AgglomerativeClustering_labels_, 'tolist') else attr_AgglomerativeClustering_labels_`;
    })();
  }
  /**
    Number of leaves in the hierarchical tree.
   */
  get n_leaves_() {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before accessing n_leaves_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AgglomerativeClustering_n_leaves_ = bridgeAgglomerativeClustering[${this.id}].n_leaves_`;
      return this._py`attr_AgglomerativeClustering_n_leaves_.tolist() if hasattr(attr_AgglomerativeClustering_n_leaves_, 'tolist') else attr_AgglomerativeClustering_n_leaves_`;
    })();
  }
  /**
    The estimated number of connected components in the graph.
   */
  get n_connected_components_() {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before accessing n_connected_components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AgglomerativeClustering_n_connected_components_ = bridgeAgglomerativeClustering[${this.id}].n_connected_components_`;
      return this._py`attr_AgglomerativeClustering_n_connected_components_.tolist() if hasattr(attr_AgglomerativeClustering_n_connected_components_, 'tolist') else attr_AgglomerativeClustering_n_connected_components_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AgglomerativeClustering_n_features_in_ = bridgeAgglomerativeClustering[${this.id}].n_features_in_`;
      return this._py`attr_AgglomerativeClustering_n_features_in_.tolist() if hasattr(attr_AgglomerativeClustering_n_features_in_, 'tolist') else attr_AgglomerativeClustering_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AgglomerativeClustering_feature_names_in_ = bridgeAgglomerativeClustering[${this.id}].feature_names_in_`;
      return this._py`attr_AgglomerativeClustering_feature_names_in_.tolist() if hasattr(attr_AgglomerativeClustering_feature_names_in_, 'tolist') else attr_AgglomerativeClustering_feature_names_in_`;
    })();
  }
  /**
    The children of each non-leaf node. Values less than `n_samples` correspond to leaves of the tree which are the original samples. A node `i` greater than or equal to `n_samples` is a non-leaf node and has children `children_\[i \- n_samples\]`. Alternatively at the i-th iteration, children\[i\]\[0\] and children\[i\]\[1\] are merged to form node `n_samples + i`.
   */
  get children_() {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before accessing children_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AgglomerativeClustering_children_ = bridgeAgglomerativeClustering[${this.id}].children_`;
      return this._py`attr_AgglomerativeClustering_children_.tolist() if hasattr(attr_AgglomerativeClustering_children_, 'tolist') else attr_AgglomerativeClustering_children_`;
    })();
  }
  /**
    Distances between nodes in the corresponding place in `children_`. Only computed if `distance_threshold` is used or `compute_distances` is set to `true`.
   */
  get distances_() {
    if (this._isDisposed) {
      throw new Error(
        "This AgglomerativeClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AgglomerativeClustering must call init() before accessing distances_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AgglomerativeClustering_distances_ = bridgeAgglomerativeClustering[${this.id}].distances_`;
      return this._py`attr_AgglomerativeClustering_distances_.tolist() if hasattr(attr_AgglomerativeClustering_distances_, 'tolist') else attr_AgglomerativeClustering_distances_`;
    })();
  }
};

// src/generated/cluster/Birch.ts
import crypto5 from "node:crypto";
var Birch = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `Birch${crypto5.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("Birch.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import Birch
try: bridgeBirch
except NameError: bridgeBirch = {}
`;
    await this._py.ex`ctor_Birch = {'threshold': ${this.opts["threshold"] ?? void 0}, 'branching_factor': ${this.opts["branching_factor"] ?? void 0}, 'n_clusters': ${this.opts["n_clusters"] ?? void 0}, 'compute_labels': ${this.opts["compute_labels"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}}

ctor_Birch = {k: v for k, v in ctor_Birch.items() if v is not None}`;
    await this._py.ex`bridgeBirch[${this.id}] = Birch(**ctor_Birch)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeBirch[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Build a CF Tree for the input data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before fit()");
    }
    await this._py.ex`pms_Birch_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_Birch_fit = {k: v for k, v in pms_Birch_fit.items() if v is not None}`;
    await this._py.ex`res_Birch_fit = bridgeBirch[${this.id}].fit(**pms_Birch_fit)`;
    return this._py`res_Birch_fit.tolist() if hasattr(res_Birch_fit, 'tolist') else res_Birch_fit`;
  }
  /**
    Perform clustering on `X` and returns cluster labels.
   */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before fit_predict()");
    }
    await this._py.ex`pms_Birch_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'kwargs': ${opts["kwargs"] ?? void 0}}

pms_Birch_fit_predict = {k: v for k, v in pms_Birch_fit_predict.items() if v is not None}`;
    await this._py.ex`res_Birch_fit_predict = bridgeBirch[${this.id}].fit_predict(**pms_Birch_fit_predict)`;
    return this._py`res_Birch_fit_predict.tolist() if hasattr(res_Birch_fit_predict, 'tolist') else res_Birch_fit_predict`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before fit_transform()");
    }
    await this._py.ex`pms_Birch_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_Birch_fit_transform = {k: v for k, v in pms_Birch_fit_transform.items() if v is not None}`;
    await this._py.ex`res_Birch_fit_transform = bridgeBirch[${this.id}].fit_transform(**pms_Birch_fit_transform)`;
    return this._py`res_Birch_fit_transform.tolist() if hasattr(res_Birch_fit_transform, 'tolist') else res_Birch_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class_name0", "class_name1", "class_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before get_feature_names_out()");
    }
    await this._py.ex`pms_Birch_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_Birch_get_feature_names_out = {k: v for k, v in pms_Birch_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_Birch_get_feature_names_out = bridgeBirch[${this.id}].get_feature_names_out(**pms_Birch_get_feature_names_out)`;
    return this._py`res_Birch_get_feature_names_out.tolist() if hasattr(res_Birch_get_feature_names_out, 'tolist') else res_Birch_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_Birch_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_Birch_get_metadata_routing = {k: v for k, v in pms_Birch_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_Birch_get_metadata_routing = bridgeBirch[${this.id}].get_metadata_routing(**pms_Birch_get_metadata_routing)`;
    return this._py`res_Birch_get_metadata_routing.tolist() if hasattr(res_Birch_get_metadata_routing, 'tolist') else res_Birch_get_metadata_routing`;
  }
  /**
    Online learning. Prevents rebuilding of CFTree from scratch.
   */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before partial_fit()");
    }
    await this._py.ex`pms_Birch_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_Birch_partial_fit = {k: v for k, v in pms_Birch_partial_fit.items() if v is not None}`;
    await this._py.ex`res_Birch_partial_fit = bridgeBirch[${this.id}].partial_fit(**pms_Birch_partial_fit)`;
    return this._py`res_Birch_partial_fit.tolist() if hasattr(res_Birch_partial_fit, 'tolist') else res_Birch_partial_fit`;
  }
  /**
      Predict data using the `centroids_` of subclusters.
  
      Avoid computation of the row norms of X.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before predict()");
    }
    await this._py.ex`pms_Birch_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_Birch_predict = {k: v for k, v in pms_Birch_predict.items() if v is not None}`;
    await this._py.ex`res_Birch_predict = bridgeBirch[${this.id}].predict(**pms_Birch_predict)`;
    return this._py`res_Birch_predict.tolist() if hasattr(res_Birch_predict, 'tolist') else res_Birch_predict`;
  }
  /**
      Set output container.
  
      See [Introducing the set_output API](https://scikit-learn.org/stable/modules/generated/../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before set_output()");
    }
    await this._py.ex`pms_Birch_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_Birch_set_output = {k: v for k, v in pms_Birch_set_output.items() if v is not None}`;
    await this._py.ex`res_Birch_set_output = bridgeBirch[${this.id}].set_output(**pms_Birch_set_output)`;
    return this._py`res_Birch_set_output.tolist() if hasattr(res_Birch_set_output, 'tolist') else res_Birch_set_output`;
  }
  /**
      Transform X into subcluster centroids dimension.
  
      Each dimension represents the distance from the sample point to each cluster centroid.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before transform()");
    }
    await this._py.ex`pms_Birch_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_Birch_transform = {k: v for k, v in pms_Birch_transform.items() if v is not None}`;
    await this._py.ex`res_Birch_transform = bridgeBirch[${this.id}].transform(**pms_Birch_transform)`;
    return this._py`res_Birch_transform.tolist() if hasattr(res_Birch_transform, 'tolist') else res_Birch_transform`;
  }
  /**
    Root of the CFTree.
   */
  get root_() {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before accessing root_");
    }
    return (async () => {
      await this._py.ex`attr_Birch_root_ = bridgeBirch[${this.id}].root_`;
      return this._py`attr_Birch_root_.tolist() if hasattr(attr_Birch_root_, 'tolist') else attr_Birch_root_`;
    })();
  }
  /**
    Start pointer to all the leaves.
   */
  get dummy_leaf_() {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before accessing dummy_leaf_");
    }
    return (async () => {
      await this._py.ex`attr_Birch_dummy_leaf_ = bridgeBirch[${this.id}].dummy_leaf_`;
      return this._py`attr_Birch_dummy_leaf_.tolist() if hasattr(attr_Birch_dummy_leaf_, 'tolist') else attr_Birch_dummy_leaf_`;
    })();
  }
  /**
    Centroids of all subclusters read directly from the leaves.
   */
  get subcluster_centers_() {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Birch must call init() before accessing subcluster_centers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Birch_subcluster_centers_ = bridgeBirch[${this.id}].subcluster_centers_`;
      return this._py`attr_Birch_subcluster_centers_.tolist() if hasattr(attr_Birch_subcluster_centers_, 'tolist') else attr_Birch_subcluster_centers_`;
    })();
  }
  /**
    Labels assigned to the centroids of the subclusters after they are clustered globally.
   */
  get subcluster_labels_() {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Birch must call init() before accessing subcluster_labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Birch_subcluster_labels_ = bridgeBirch[${this.id}].subcluster_labels_`;
      return this._py`attr_Birch_subcluster_labels_.tolist() if hasattr(attr_Birch_subcluster_labels_, 'tolist') else attr_Birch_subcluster_labels_`;
    })();
  }
  /**
    Array of labels assigned to the input data. if partial_fit is used instead of fit, they are assigned to the last batch of data.
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before accessing labels_");
    }
    return (async () => {
      await this._py.ex`attr_Birch_labels_ = bridgeBirch[${this.id}].labels_`;
      return this._py`attr_Birch_labels_.tolist() if hasattr(attr_Birch_labels_, 'tolist') else attr_Birch_labels_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("Birch must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_Birch_n_features_in_ = bridgeBirch[${this.id}].n_features_in_`;
      return this._py`attr_Birch_n_features_in_.tolist() if hasattr(attr_Birch_n_features_in_, 'tolist') else attr_Birch_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This Birch instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "Birch must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_Birch_feature_names_in_ = bridgeBirch[${this.id}].feature_names_in_`;
      return this._py`attr_Birch_feature_names_in_.tolist() if hasattr(attr_Birch_feature_names_in_, 'tolist') else attr_Birch_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/BisectingKMeans.ts
import crypto6 from "node:crypto";
var BisectingKMeans = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `BisectingKMeans${crypto6.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("BisectingKMeans.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import BisectingKMeans
try: bridgeBisectingKMeans
except NameError: bridgeBisectingKMeans = {}
`;
    await this._py.ex`ctor_BisectingKMeans = {'n_clusters': ${this.opts["n_clusters"] ?? void 0}, 'init': ${this.opts["init"] ?? void 0}, 'n_init': ${this.opts["n_init"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'copy_x': ${this.opts["copy_x"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'bisecting_strategy': ${this.opts["bisecting_strategy"] ?? void 0}}

ctor_BisectingKMeans = {k: v for k, v in ctor_BisectingKMeans.items() if v is not None}`;
    await this._py.ex`bridgeBisectingKMeans[${this.id}] = BisectingKMeans(**ctor_BisectingKMeans)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeBisectingKMeans[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute bisecting k-means clustering.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BisectingKMeans must call init() before fit()");
    }
    await this._py.ex`pms_BisectingKMeans_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BisectingKMeans_fit = {k: v for k, v in pms_BisectingKMeans_fit.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_fit = bridgeBisectingKMeans[${this.id}].fit(**pms_BisectingKMeans_fit)`;
    return this._py`res_BisectingKMeans_fit.tolist() if hasattr(res_BisectingKMeans_fit, 'tolist') else res_BisectingKMeans_fit`;
  }
  /**
      Compute cluster centers and predict cluster index for each sample.
  
      Convenience method; equivalent to calling fit(X) followed by predict(X).
     */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BisectingKMeans must call init() before fit_predict()");
    }
    await this._py.ex`pms_BisectingKMeans_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BisectingKMeans_fit_predict = {k: v for k, v in pms_BisectingKMeans_fit_predict.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_fit_predict = bridgeBisectingKMeans[${this.id}].fit_predict(**pms_BisectingKMeans_fit_predict)`;
    return this._py`res_BisectingKMeans_fit_predict.tolist() if hasattr(res_BisectingKMeans_fit_predict, 'tolist') else res_BisectingKMeans_fit_predict`;
  }
  /**
      Compute clustering and transform X to cluster-distance space.
  
      Equivalent to fit(X).transform(X), but more efficiently implemented.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BisectingKMeans must call init() before fit_transform()");
    }
    await this._py.ex`pms_BisectingKMeans_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BisectingKMeans_fit_transform = {k: v for k, v in pms_BisectingKMeans_fit_transform.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_fit_transform = bridgeBisectingKMeans[${this.id}].fit_transform(**pms_BisectingKMeans_fit_transform)`;
    return this._py`res_BisectingKMeans_fit_transform.tolist() if hasattr(res_BisectingKMeans_fit_transform, 'tolist') else res_BisectingKMeans_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class_name0", "class_name1", "class_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_BisectingKMeans_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_BisectingKMeans_get_feature_names_out = {k: v for k, v in pms_BisectingKMeans_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_get_feature_names_out = bridgeBisectingKMeans[${this.id}].get_feature_names_out(**pms_BisectingKMeans_get_feature_names_out)`;
    return this._py`res_BisectingKMeans_get_feature_names_out.tolist() if hasattr(res_BisectingKMeans_get_feature_names_out, 'tolist') else res_BisectingKMeans_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_BisectingKMeans_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_BisectingKMeans_get_metadata_routing = {k: v for k, v in pms_BisectingKMeans_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_get_metadata_routing = bridgeBisectingKMeans[${this.id}].get_metadata_routing(**pms_BisectingKMeans_get_metadata_routing)`;
    return this._py`res_BisectingKMeans_get_metadata_routing.tolist() if hasattr(res_BisectingKMeans_get_metadata_routing, 'tolist') else res_BisectingKMeans_get_metadata_routing`;
  }
  /**
      Predict which cluster each sample in X belongs to.
  
      Prediction is made by going down the hierarchical tree in searching of closest leaf cluster.
  
      In the vector quantization literature, `cluster_centers_` is called the code book and each value returned by `predict` is the index of the closest code in the code book.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BisectingKMeans must call init() before predict()");
    }
    await this._py.ex`pms_BisectingKMeans_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BisectingKMeans_predict = {k: v for k, v in pms_BisectingKMeans_predict.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_predict = bridgeBisectingKMeans[${this.id}].predict(**pms_BisectingKMeans_predict)`;
    return this._py`res_BisectingKMeans_predict.tolist() if hasattr(res_BisectingKMeans_predict, 'tolist') else res_BisectingKMeans_predict`;
  }
  /**
    Opposite of the value of X on the K-means objective.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BisectingKMeans must call init() before score()");
    }
    await this._py.ex`pms_BisectingKMeans_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BisectingKMeans_score = {k: v for k, v in pms_BisectingKMeans_score.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_score = bridgeBisectingKMeans[${this.id}].score(**pms_BisectingKMeans_score)`;
    return this._py`res_BisectingKMeans_score.tolist() if hasattr(res_BisectingKMeans_score, 'tolist') else res_BisectingKMeans_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_BisectingKMeans_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_BisectingKMeans_set_fit_request = {k: v for k, v in pms_BisectingKMeans_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_set_fit_request = bridgeBisectingKMeans[${this.id}].set_fit_request(**pms_BisectingKMeans_set_fit_request)`;
    return this._py`res_BisectingKMeans_set_fit_request.tolist() if hasattr(res_BisectingKMeans_set_fit_request, 'tolist') else res_BisectingKMeans_set_fit_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set_output API](https://scikit-learn.org/stable/modules/generated/../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BisectingKMeans must call init() before set_output()");
    }
    await this._py.ex`pms_BisectingKMeans_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_BisectingKMeans_set_output = {k: v for k, v in pms_BisectingKMeans_set_output.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_set_output = bridgeBisectingKMeans[${this.id}].set_output(**pms_BisectingKMeans_set_output)`;
    return this._py`res_BisectingKMeans_set_output.tolist() if hasattr(res_BisectingKMeans_set_output, 'tolist') else res_BisectingKMeans_set_output`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_BisectingKMeans_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_BisectingKMeans_set_score_request = {k: v for k, v in pms_BisectingKMeans_set_score_request.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_set_score_request = bridgeBisectingKMeans[${this.id}].set_score_request(**pms_BisectingKMeans_set_score_request)`;
    return this._py`res_BisectingKMeans_set_score_request.tolist() if hasattr(res_BisectingKMeans_set_score_request, 'tolist') else res_BisectingKMeans_set_score_request`;
  }
  /**
      Transform X to a cluster-distance space.
  
      In the new space, each dimension is the distance to the cluster centers. Note that even if X is sparse, the array returned by `transform` will typically be dense.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("BisectingKMeans must call init() before transform()");
    }
    await this._py.ex`pms_BisectingKMeans_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BisectingKMeans_transform = {k: v for k, v in pms_BisectingKMeans_transform.items() if v is not None}`;
    await this._py.ex`res_BisectingKMeans_transform = bridgeBisectingKMeans[${this.id}].transform(**pms_BisectingKMeans_transform)`;
    return this._py`res_BisectingKMeans_transform.tolist() if hasattr(res_BisectingKMeans_transform, 'tolist') else res_BisectingKMeans_transform`;
  }
  /**
    Coordinates of cluster centers. If the algorithm stops before fully converging (see `tol` and `max_iter`), these will not be consistent with `labels_`.
   */
  get cluster_centers_() {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before accessing cluster_centers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BisectingKMeans_cluster_centers_ = bridgeBisectingKMeans[${this.id}].cluster_centers_`;
      return this._py`attr_BisectingKMeans_cluster_centers_.tolist() if hasattr(attr_BisectingKMeans_cluster_centers_, 'tolist') else attr_BisectingKMeans_cluster_centers_`;
    })();
  }
  /**
    Labels of each point.
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before accessing labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BisectingKMeans_labels_ = bridgeBisectingKMeans[${this.id}].labels_`;
      return this._py`attr_BisectingKMeans_labels_.tolist() if hasattr(attr_BisectingKMeans_labels_, 'tolist') else attr_BisectingKMeans_labels_`;
    })();
  }
  /**
    Sum of squared distances of samples to their closest cluster center, weighted by the sample weights if provided.
   */
  get inertia_() {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before accessing inertia_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BisectingKMeans_inertia_ = bridgeBisectingKMeans[${this.id}].inertia_`;
      return this._py`attr_BisectingKMeans_inertia_.tolist() if hasattr(attr_BisectingKMeans_inertia_, 'tolist') else attr_BisectingKMeans_inertia_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BisectingKMeans_n_features_in_ = bridgeBisectingKMeans[${this.id}].n_features_in_`;
      return this._py`attr_BisectingKMeans_n_features_in_.tolist() if hasattr(attr_BisectingKMeans_n_features_in_, 'tolist') else attr_BisectingKMeans_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This BisectingKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "BisectingKMeans must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BisectingKMeans_feature_names_in_ = bridgeBisectingKMeans[${this.id}].feature_names_in_`;
      return this._py`attr_BisectingKMeans_feature_names_in_.tolist() if hasattr(attr_BisectingKMeans_feature_names_in_, 'tolist') else attr_BisectingKMeans_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/DBSCAN.ts
import crypto7 from "node:crypto";
var DBSCAN = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `DBSCAN${crypto7.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("DBSCAN.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import DBSCAN
try: bridgeDBSCAN
except NameError: bridgeDBSCAN = {}
`;
    await this._py.ex`ctor_DBSCAN = {'eps': ${this.opts["eps"] ?? void 0}, 'min_samples': ${this.opts["min_samples"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'p': ${this.opts["p"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_DBSCAN = {k: v for k, v in ctor_DBSCAN.items() if v is not None}`;
    await this._py.ex`bridgeDBSCAN[${this.id}] = DBSCAN(**ctor_DBSCAN)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeDBSCAN[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Perform DBSCAN clustering from features, or distance matrix.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DBSCAN must call init() before fit()");
    }
    await this._py.ex`pms_DBSCAN_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_DBSCAN_fit = {k: v for k, v in pms_DBSCAN_fit.items() if v is not None}`;
    await this._py.ex`res_DBSCAN_fit = bridgeDBSCAN[${this.id}].fit(**pms_DBSCAN_fit)`;
    return this._py`res_DBSCAN_fit.tolist() if hasattr(res_DBSCAN_fit, 'tolist') else res_DBSCAN_fit`;
  }
  /**
    Compute clusters from a data or distance matrix and predict labels.
   */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DBSCAN must call init() before fit_predict()");
    }
    await this._py.ex`pms_DBSCAN_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_DBSCAN_fit_predict = {k: v for k, v in pms_DBSCAN_fit_predict.items() if v is not None}`;
    await this._py.ex`res_DBSCAN_fit_predict = bridgeDBSCAN[${this.id}].fit_predict(**pms_DBSCAN_fit_predict)`;
    return this._py`res_DBSCAN_fit_predict.tolist() if hasattr(res_DBSCAN_fit_predict, 'tolist') else res_DBSCAN_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DBSCAN must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_DBSCAN_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_DBSCAN_get_metadata_routing = {k: v for k, v in pms_DBSCAN_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_DBSCAN_get_metadata_routing = bridgeDBSCAN[${this.id}].get_metadata_routing(**pms_DBSCAN_get_metadata_routing)`;
    return this._py`res_DBSCAN_get_metadata_routing.tolist() if hasattr(res_DBSCAN_get_metadata_routing, 'tolist') else res_DBSCAN_get_metadata_routing`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DBSCAN must call init() before set_fit_request()");
    }
    await this._py.ex`pms_DBSCAN_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_DBSCAN_set_fit_request = {k: v for k, v in pms_DBSCAN_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_DBSCAN_set_fit_request = bridgeDBSCAN[${this.id}].set_fit_request(**pms_DBSCAN_set_fit_request)`;
    return this._py`res_DBSCAN_set_fit_request.tolist() if hasattr(res_DBSCAN_set_fit_request, 'tolist') else res_DBSCAN_set_fit_request`;
  }
  /**
    Indices of core samples.
   */
  get core_sample_indices_() {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DBSCAN must call init() before accessing core_sample_indices_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DBSCAN_core_sample_indices_ = bridgeDBSCAN[${this.id}].core_sample_indices_`;
      return this._py`attr_DBSCAN_core_sample_indices_.tolist() if hasattr(attr_DBSCAN_core_sample_indices_, 'tolist') else attr_DBSCAN_core_sample_indices_`;
    })();
  }
  /**
    Copy of each core sample found by training.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DBSCAN must call init() before accessing components_");
    }
    return (async () => {
      await this._py.ex`attr_DBSCAN_components_ = bridgeDBSCAN[${this.id}].components_`;
      return this._py`attr_DBSCAN_components_.tolist() if hasattr(attr_DBSCAN_components_, 'tolist') else attr_DBSCAN_components_`;
    })();
  }
  /**
    Cluster labels for each point in the dataset given to fit(). Noisy samples are given the label -1.
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DBSCAN must call init() before accessing labels_");
    }
    return (async () => {
      await this._py.ex`attr_DBSCAN_labels_ = bridgeDBSCAN[${this.id}].labels_`;
      return this._py`attr_DBSCAN_labels_.tolist() if hasattr(attr_DBSCAN_labels_, 'tolist') else attr_DBSCAN_labels_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DBSCAN must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_DBSCAN_n_features_in_ = bridgeDBSCAN[${this.id}].n_features_in_`;
      return this._py`attr_DBSCAN_n_features_in_.tolist() if hasattr(attr_DBSCAN_n_features_in_, 'tolist') else attr_DBSCAN_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This DBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DBSCAN must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DBSCAN_feature_names_in_ = bridgeDBSCAN[${this.id}].feature_names_in_`;
      return this._py`attr_DBSCAN_feature_names_in_.tolist() if hasattr(attr_DBSCAN_feature_names_in_, 'tolist') else attr_DBSCAN_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/FeatureAgglomeration.ts
import crypto8 from "node:crypto";
var FeatureAgglomeration = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `FeatureAgglomeration${crypto8.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "FeatureAgglomeration.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import FeatureAgglomeration
try: bridgeFeatureAgglomeration
except NameError: bridgeFeatureAgglomeration = {}
`;
    await this._py.ex`ctor_FeatureAgglomeration = {'n_clusters': ${this.opts["n_clusters"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'memory': ${this.opts["memory"] ?? void 0}, 'connectivity': ${this.opts["connectivity"] ?? void 0}, 'compute_full_tree': ${this.opts["compute_full_tree"] ?? void 0}, 'linkage': ${this.opts["linkage"] ?? void 0}, 'pooling_func': ${this.opts["pooling_func"] ?? void 0}, 'distance_threshold': ${this.opts["distance_threshold"] ?? void 0}, 'compute_distances': ${this.opts["compute_distances"] ?? void 0}}

ctor_FeatureAgglomeration = {k: v for k, v in ctor_FeatureAgglomeration.items() if v is not None}`;
    await this._py.ex`bridgeFeatureAgglomeration[${this.id}] = FeatureAgglomeration(**ctor_FeatureAgglomeration)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeFeatureAgglomeration[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the hierarchical clustering on the data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("FeatureAgglomeration must call init() before fit()");
    }
    await this._py.ex`pms_FeatureAgglomeration_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_FeatureAgglomeration_fit = {k: v for k, v in pms_FeatureAgglomeration_fit.items() if v is not None}`;
    await this._py.ex`res_FeatureAgglomeration_fit = bridgeFeatureAgglomeration[${this.id}].fit(**pms_FeatureAgglomeration_fit)`;
    return this._py`res_FeatureAgglomeration_fit.tolist() if hasattr(res_FeatureAgglomeration_fit, 'tolist') else res_FeatureAgglomeration_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_FeatureAgglomeration_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_FeatureAgglomeration_fit_transform = {k: v for k, v in pms_FeatureAgglomeration_fit_transform.items() if v is not None}`;
    await this._py.ex`res_FeatureAgglomeration_fit_transform = bridgeFeatureAgglomeration[${this.id}].fit_transform(**pms_FeatureAgglomeration_fit_transform)`;
    return this._py`res_FeatureAgglomeration_fit_transform.tolist() if hasattr(res_FeatureAgglomeration_fit_transform, 'tolist') else res_FeatureAgglomeration_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class_name0", "class_name1", "class_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_FeatureAgglomeration_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_FeatureAgglomeration_get_feature_names_out = {k: v for k, v in pms_FeatureAgglomeration_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_FeatureAgglomeration_get_feature_names_out = bridgeFeatureAgglomeration[${this.id}].get_feature_names_out(**pms_FeatureAgglomeration_get_feature_names_out)`;
    return this._py`res_FeatureAgglomeration_get_feature_names_out.tolist() if hasattr(res_FeatureAgglomeration_get_feature_names_out, 'tolist') else res_FeatureAgglomeration_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_FeatureAgglomeration_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_FeatureAgglomeration_get_metadata_routing = {k: v for k, v in pms_FeatureAgglomeration_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_FeatureAgglomeration_get_metadata_routing = bridgeFeatureAgglomeration[${this.id}].get_metadata_routing(**pms_FeatureAgglomeration_get_metadata_routing)`;
    return this._py`res_FeatureAgglomeration_get_metadata_routing.tolist() if hasattr(res_FeatureAgglomeration_get_metadata_routing, 'tolist') else res_FeatureAgglomeration_get_metadata_routing`;
  }
  /**
    Inverse the transformation and return a vector of size `n_features`.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_FeatureAgglomeration_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Xt': np.array(${opts["Xt"] ?? void 0}) if ${opts["Xt"] !== void 0} else None}

pms_FeatureAgglomeration_inverse_transform = {k: v for k, v in pms_FeatureAgglomeration_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_FeatureAgglomeration_inverse_transform = bridgeFeatureAgglomeration[${this.id}].inverse_transform(**pms_FeatureAgglomeration_inverse_transform)`;
    return this._py`res_FeatureAgglomeration_inverse_transform.tolist() if hasattr(res_FeatureAgglomeration_inverse_transform, 'tolist') else res_FeatureAgglomeration_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set_output API](https://scikit-learn.org/stable/modules/generated/../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before set_output()"
      );
    }
    await this._py.ex`pms_FeatureAgglomeration_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_FeatureAgglomeration_set_output = {k: v for k, v in pms_FeatureAgglomeration_set_output.items() if v is not None}`;
    await this._py.ex`res_FeatureAgglomeration_set_output = bridgeFeatureAgglomeration[${this.id}].set_output(**pms_FeatureAgglomeration_set_output)`;
    return this._py`res_FeatureAgglomeration_set_output.tolist() if hasattr(res_FeatureAgglomeration_set_output, 'tolist') else res_FeatureAgglomeration_set_output`;
  }
  /**
    Transform a new matrix using the built clustering.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before transform()"
      );
    }
    await this._py.ex`pms_FeatureAgglomeration_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_FeatureAgglomeration_transform = {k: v for k, v in pms_FeatureAgglomeration_transform.items() if v is not None}`;
    await this._py.ex`res_FeatureAgglomeration_transform = bridgeFeatureAgglomeration[${this.id}].transform(**pms_FeatureAgglomeration_transform)`;
    return this._py`res_FeatureAgglomeration_transform.tolist() if hasattr(res_FeatureAgglomeration_transform, 'tolist') else res_FeatureAgglomeration_transform`;
  }
  /**
    The number of clusters found by the algorithm. If `distance_threshold=None`, it will be equal to the given `n_clusters`.
   */
  get n_clusters_() {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before accessing n_clusters_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FeatureAgglomeration_n_clusters_ = bridgeFeatureAgglomeration[${this.id}].n_clusters_`;
      return this._py`attr_FeatureAgglomeration_n_clusters_.tolist() if hasattr(attr_FeatureAgglomeration_n_clusters_, 'tolist') else attr_FeatureAgglomeration_n_clusters_`;
    })();
  }
  /**
    Cluster labels for each feature.
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before accessing labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FeatureAgglomeration_labels_ = bridgeFeatureAgglomeration[${this.id}].labels_`;
      return this._py`attr_FeatureAgglomeration_labels_.tolist() if hasattr(attr_FeatureAgglomeration_labels_, 'tolist') else attr_FeatureAgglomeration_labels_`;
    })();
  }
  /**
    Number of leaves in the hierarchical tree.
   */
  get n_leaves_() {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before accessing n_leaves_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FeatureAgglomeration_n_leaves_ = bridgeFeatureAgglomeration[${this.id}].n_leaves_`;
      return this._py`attr_FeatureAgglomeration_n_leaves_.tolist() if hasattr(attr_FeatureAgglomeration_n_leaves_, 'tolist') else attr_FeatureAgglomeration_n_leaves_`;
    })();
  }
  /**
    The estimated number of connected components in the graph.
   */
  get n_connected_components_() {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before accessing n_connected_components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FeatureAgglomeration_n_connected_components_ = bridgeFeatureAgglomeration[${this.id}].n_connected_components_`;
      return this._py`attr_FeatureAgglomeration_n_connected_components_.tolist() if hasattr(attr_FeatureAgglomeration_n_connected_components_, 'tolist') else attr_FeatureAgglomeration_n_connected_components_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FeatureAgglomeration_n_features_in_ = bridgeFeatureAgglomeration[${this.id}].n_features_in_`;
      return this._py`attr_FeatureAgglomeration_n_features_in_.tolist() if hasattr(attr_FeatureAgglomeration_n_features_in_, 'tolist') else attr_FeatureAgglomeration_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FeatureAgglomeration_feature_names_in_ = bridgeFeatureAgglomeration[${this.id}].feature_names_in_`;
      return this._py`attr_FeatureAgglomeration_feature_names_in_.tolist() if hasattr(attr_FeatureAgglomeration_feature_names_in_, 'tolist') else attr_FeatureAgglomeration_feature_names_in_`;
    })();
  }
  /**
    The children of each non-leaf node. Values less than `n_features` correspond to leaves of the tree which are the original samples. A node `i` greater than or equal to `n_features` is a non-leaf node and has children `children_\[i \- n_features\]`. Alternatively at the i-th iteration, children\[i\]\[0\] and children\[i\]\[1\] are merged to form node `n_features + i`.
   */
  get children_() {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before accessing children_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FeatureAgglomeration_children_ = bridgeFeatureAgglomeration[${this.id}].children_`;
      return this._py`attr_FeatureAgglomeration_children_.tolist() if hasattr(attr_FeatureAgglomeration_children_, 'tolist') else attr_FeatureAgglomeration_children_`;
    })();
  }
  /**
    Distances between nodes in the corresponding place in `children_`. Only computed if `distance_threshold` is used or `compute_distances` is set to `true`.
   */
  get distances_() {
    if (this._isDisposed) {
      throw new Error(
        "This FeatureAgglomeration instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "FeatureAgglomeration must call init() before accessing distances_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FeatureAgglomeration_distances_ = bridgeFeatureAgglomeration[${this.id}].distances_`;
      return this._py`attr_FeatureAgglomeration_distances_.tolist() if hasattr(attr_FeatureAgglomeration_distances_, 'tolist') else attr_FeatureAgglomeration_distances_`;
    })();
  }
};

// src/generated/cluster/HDBSCAN.ts
import crypto9 from "node:crypto";
var HDBSCAN = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `HDBSCAN${crypto9.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("HDBSCAN.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import HDBSCAN
try: bridgeHDBSCAN
except NameError: bridgeHDBSCAN = {}
`;
    await this._py.ex`ctor_HDBSCAN = {'min_cluster_size': ${this.opts["min_cluster_size"] ?? void 0}, 'min_samples': ${this.opts["min_samples"] ?? void 0}, 'cluster_selection_epsilon': ${this.opts["cluster_selection_epsilon"] ?? void 0}, 'max_cluster_size': ${this.opts["max_cluster_size"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'cluster_selection_method': ${this.opts["cluster_selection_method"] ?? void 0}, 'allow_single_cluster': ${this.opts["allow_single_cluster"] ?? void 0}, 'store_centers': ${this.opts["store_centers"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}}

ctor_HDBSCAN = {k: v for k, v in ctor_HDBSCAN.items() if v is not None}`;
    await this._py.ex`bridgeHDBSCAN[${this.id}] = HDBSCAN(**ctor_HDBSCAN)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeHDBSCAN[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Return clustering given by DBSCAN without border points.
  
      Return clustering that would be equivalent to running DBSCAN\* for a particular cut_distance (or epsilon) DBSCAN\* can be thought of as DBSCAN without the border points. As such these results may differ slightly from `cluster.DBSCAN` due to the difference in implementation over the non-core points.
  
      This can also be thought of as a flat clustering derived from constant height cut through the single linkage tree.
  
      This represents the result of selecting a cut value for robust single linkage clustering. The `min_cluster_size` allows the flat clustering to declare noise points (and cluster smaller than `min_cluster_size`).
     */
  async dbscan_clustering(opts) {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before dbscan_clustering()");
    }
    await this._py.ex`pms_HDBSCAN_dbscan_clustering = {'cut_distance': ${opts["cut_distance"] ?? void 0}, 'min_cluster_size': ${opts["min_cluster_size"] ?? void 0}}

pms_HDBSCAN_dbscan_clustering = {k: v for k, v in pms_HDBSCAN_dbscan_clustering.items() if v is not None}`;
    await this._py.ex`res_HDBSCAN_dbscan_clustering = bridgeHDBSCAN[${this.id}].dbscan_clustering(**pms_HDBSCAN_dbscan_clustering)`;
    return this._py`res_HDBSCAN_dbscan_clustering.tolist() if hasattr(res_HDBSCAN_dbscan_clustering, 'tolist') else res_HDBSCAN_dbscan_clustering`;
  }
  /**
    Find clusters based on hierarchical density-based clustering.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before fit()");
    }
    await this._py.ex`pms_HDBSCAN_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_HDBSCAN_fit = {k: v for k, v in pms_HDBSCAN_fit.items() if v is not None}`;
    await this._py.ex`res_HDBSCAN_fit = bridgeHDBSCAN[${this.id}].fit(**pms_HDBSCAN_fit)`;
    return this._py`res_HDBSCAN_fit.tolist() if hasattr(res_HDBSCAN_fit, 'tolist') else res_HDBSCAN_fit`;
  }
  /**
    Cluster X and return the associated cluster labels.
   */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before fit_predict()");
    }
    await this._py.ex`pms_HDBSCAN_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_HDBSCAN_fit_predict = {k: v for k, v in pms_HDBSCAN_fit_predict.items() if v is not None}`;
    await this._py.ex`res_HDBSCAN_fit_predict = bridgeHDBSCAN[${this.id}].fit_predict(**pms_HDBSCAN_fit_predict)`;
    return this._py`res_HDBSCAN_fit_predict.tolist() if hasattr(res_HDBSCAN_fit_predict, 'tolist') else res_HDBSCAN_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_HDBSCAN_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_HDBSCAN_get_metadata_routing = {k: v for k, v in pms_HDBSCAN_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_HDBSCAN_get_metadata_routing = bridgeHDBSCAN[${this.id}].get_metadata_routing(**pms_HDBSCAN_get_metadata_routing)`;
    return this._py`res_HDBSCAN_get_metadata_routing.tolist() if hasattr(res_HDBSCAN_get_metadata_routing, 'tolist') else res_HDBSCAN_get_metadata_routing`;
  }
  /**
    Cluster labels for each point in the dataset given to [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Outliers are labeled as follows:
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before accessing labels_");
    }
    return (async () => {
      await this._py.ex`attr_HDBSCAN_labels_ = bridgeHDBSCAN[${this.id}].labels_`;
      return this._py`attr_HDBSCAN_labels_.tolist() if hasattr(attr_HDBSCAN_labels_, 'tolist') else attr_HDBSCAN_labels_`;
    })();
  }
  /**
    The strength with which each sample is a member of its assigned cluster.
   */
  get probabilities_() {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HDBSCAN must call init() before accessing probabilities_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HDBSCAN_probabilities_ = bridgeHDBSCAN[${this.id}].probabilities_`;
      return this._py`attr_HDBSCAN_probabilities_.tolist() if hasattr(attr_HDBSCAN_probabilities_, 'tolist') else attr_HDBSCAN_probabilities_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HDBSCAN must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HDBSCAN_n_features_in_ = bridgeHDBSCAN[${this.id}].n_features_in_`;
      return this._py`attr_HDBSCAN_n_features_in_.tolist() if hasattr(attr_HDBSCAN_n_features_in_, 'tolist') else attr_HDBSCAN_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HDBSCAN must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HDBSCAN_feature_names_in_ = bridgeHDBSCAN[${this.id}].feature_names_in_`;
      return this._py`attr_HDBSCAN_feature_names_in_.tolist() if hasattr(attr_HDBSCAN_feature_names_in_, 'tolist') else attr_HDBSCAN_feature_names_in_`;
    })();
  }
  /**
      A collection containing the centroid of each cluster calculated under the standard euclidean metric. The centroids may fall “outside” their respective clusters if the clusters themselves are non-convex.
  
      Note that `n_clusters` only counts non-outlier clusters. That is to say, the `\-1, \-2, \-3` labels for the outlier clusters are excluded.
     */
  get centroids_() {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before accessing centroids_");
    }
    return (async () => {
      await this._py.ex`attr_HDBSCAN_centroids_ = bridgeHDBSCAN[${this.id}].centroids_`;
      return this._py`attr_HDBSCAN_centroids_.tolist() if hasattr(attr_HDBSCAN_centroids_, 'tolist') else attr_HDBSCAN_centroids_`;
    })();
  }
  /**
      A collection containing the medoid of each cluster calculated under the whichever metric was passed to the `metric` parameter. The medoids are points in the original cluster which minimize the average distance to all other points in that cluster under the chosen metric. These can be thought of as the result of projecting the `metric`\-based centroid back onto the cluster.
  
      Note that `n_clusters` only counts non-outlier clusters. That is to say, the `\-1, \-2, \-3` labels for the outlier clusters are excluded.
     */
  get medoids_() {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before accessing medoids_");
    }
    return (async () => {
      await this._py.ex`attr_HDBSCAN_medoids_ = bridgeHDBSCAN[${this.id}].medoids_`;
      return this._py`attr_HDBSCAN_medoids_.tolist() if hasattr(attr_HDBSCAN_medoids_, 'tolist') else attr_HDBSCAN_medoids_`;
    })();
  }
};

// src/generated/cluster/KMeans.ts
import crypto10 from "node:crypto";
var KMeans = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `KMeans${crypto10.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("KMeans.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import KMeans
try: bridgeKMeans
except NameError: bridgeKMeans = {}
`;
    await this._py.ex`ctor_KMeans = {'n_clusters': ${this.opts["n_clusters"] ?? void 0}, 'init': np.array(${this.opts["init"] ?? void 0}) if ${this.opts["init"] !== void 0} else None, 'n_init': ${this.opts["n_init"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'copy_x': ${this.opts["copy_x"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}}

ctor_KMeans = {k: v for k, v in ctor_KMeans.items() if v is not None}`;
    await this._py.ex`bridgeKMeans[${this.id}] = KMeans(**ctor_KMeans)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeKMeans[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute k-means clustering.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before fit()");
    }
    await this._py.ex`pms_KMeans_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_KMeans_fit = {k: v for k, v in pms_KMeans_fit.items() if v is not None}`;
    await this._py.ex`res_KMeans_fit = bridgeKMeans[${this.id}].fit(**pms_KMeans_fit)`;
    return this._py`res_KMeans_fit.tolist() if hasattr(res_KMeans_fit, 'tolist') else res_KMeans_fit`;
  }
  /**
      Compute cluster centers and predict cluster index for each sample.
  
      Convenience method; equivalent to calling fit(X) followed by predict(X).
     */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before fit_predict()");
    }
    await this._py.ex`pms_KMeans_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_KMeans_fit_predict = {k: v for k, v in pms_KMeans_fit_predict.items() if v is not None}`;
    await this._py.ex`res_KMeans_fit_predict = bridgeKMeans[${this.id}].fit_predict(**pms_KMeans_fit_predict)`;
    return this._py`res_KMeans_fit_predict.tolist() if hasattr(res_KMeans_fit_predict, 'tolist') else res_KMeans_fit_predict`;
  }
  /**
      Compute clustering and transform X to cluster-distance space.
  
      Equivalent to fit(X).transform(X), but more efficiently implemented.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before fit_transform()");
    }
    await this._py.ex`pms_KMeans_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_KMeans_fit_transform = {k: v for k, v in pms_KMeans_fit_transform.items() if v is not None}`;
    await this._py.ex`res_KMeans_fit_transform = bridgeKMeans[${this.id}].fit_transform(**pms_KMeans_fit_transform)`;
    return this._py`res_KMeans_fit_transform.tolist() if hasattr(res_KMeans_fit_transform, 'tolist') else res_KMeans_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class_name0", "class_name1", "class_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before get_feature_names_out()");
    }
    await this._py.ex`pms_KMeans_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_KMeans_get_feature_names_out = {k: v for k, v in pms_KMeans_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_KMeans_get_feature_names_out = bridgeKMeans[${this.id}].get_feature_names_out(**pms_KMeans_get_feature_names_out)`;
    return this._py`res_KMeans_get_feature_names_out.tolist() if hasattr(res_KMeans_get_feature_names_out, 'tolist') else res_KMeans_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_KMeans_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_KMeans_get_metadata_routing = {k: v for k, v in pms_KMeans_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_KMeans_get_metadata_routing = bridgeKMeans[${this.id}].get_metadata_routing(**pms_KMeans_get_metadata_routing)`;
    return this._py`res_KMeans_get_metadata_routing.tolist() if hasattr(res_KMeans_get_metadata_routing, 'tolist') else res_KMeans_get_metadata_routing`;
  }
  /**
      Predict the closest cluster each sample in X belongs to.
  
      In the vector quantization literature, `cluster_centers_` is called the code book and each value returned by `predict` is the index of the closest code in the code book.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before predict()");
    }
    await this._py.ex`pms_KMeans_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_KMeans_predict = {k: v for k, v in pms_KMeans_predict.items() if v is not None}`;
    await this._py.ex`res_KMeans_predict = bridgeKMeans[${this.id}].predict(**pms_KMeans_predict)`;
    return this._py`res_KMeans_predict.tolist() if hasattr(res_KMeans_predict, 'tolist') else res_KMeans_predict`;
  }
  /**
    Opposite of the value of X on the K-means objective.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before score()");
    }
    await this._py.ex`pms_KMeans_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_KMeans_score = {k: v for k, v in pms_KMeans_score.items() if v is not None}`;
    await this._py.ex`res_KMeans_score = bridgeKMeans[${this.id}].score(**pms_KMeans_score)`;
    return this._py`res_KMeans_score.tolist() if hasattr(res_KMeans_score, 'tolist') else res_KMeans_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before set_fit_request()");
    }
    await this._py.ex`pms_KMeans_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_KMeans_set_fit_request = {k: v for k, v in pms_KMeans_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_KMeans_set_fit_request = bridgeKMeans[${this.id}].set_fit_request(**pms_KMeans_set_fit_request)`;
    return this._py`res_KMeans_set_fit_request.tolist() if hasattr(res_KMeans_set_fit_request, 'tolist') else res_KMeans_set_fit_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set_output API](https://scikit-learn.org/stable/modules/generated/../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before set_output()");
    }
    await this._py.ex`pms_KMeans_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_KMeans_set_output = {k: v for k, v in pms_KMeans_set_output.items() if v is not None}`;
    await this._py.ex`res_KMeans_set_output = bridgeKMeans[${this.id}].set_output(**pms_KMeans_set_output)`;
    return this._py`res_KMeans_set_output.tolist() if hasattr(res_KMeans_set_output, 'tolist') else res_KMeans_set_output`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before set_score_request()");
    }
    await this._py.ex`pms_KMeans_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_KMeans_set_score_request = {k: v for k, v in pms_KMeans_set_score_request.items() if v is not None}`;
    await this._py.ex`res_KMeans_set_score_request = bridgeKMeans[${this.id}].set_score_request(**pms_KMeans_set_score_request)`;
    return this._py`res_KMeans_set_score_request.tolist() if hasattr(res_KMeans_set_score_request, 'tolist') else res_KMeans_set_score_request`;
  }
  /**
      Transform X to a cluster-distance space.
  
      In the new space, each dimension is the distance to the cluster centers. Note that even if X is sparse, the array returned by `transform` will typically be dense.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before transform()");
    }
    await this._py.ex`pms_KMeans_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_KMeans_transform = {k: v for k, v in pms_KMeans_transform.items() if v is not None}`;
    await this._py.ex`res_KMeans_transform = bridgeKMeans[${this.id}].transform(**pms_KMeans_transform)`;
    return this._py`res_KMeans_transform.tolist() if hasattr(res_KMeans_transform, 'tolist') else res_KMeans_transform`;
  }
  /**
    Coordinates of cluster centers. If the algorithm stops before fully converging (see `tol` and `max_iter`), these will not be consistent with `labels_`.
   */
  get cluster_centers_() {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KMeans must call init() before accessing cluster_centers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KMeans_cluster_centers_ = bridgeKMeans[${this.id}].cluster_centers_`;
      return this._py`attr_KMeans_cluster_centers_.tolist() if hasattr(attr_KMeans_cluster_centers_, 'tolist') else attr_KMeans_cluster_centers_`;
    })();
  }
  /**
    Labels of each point
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before accessing labels_");
    }
    return (async () => {
      await this._py.ex`attr_KMeans_labels_ = bridgeKMeans[${this.id}].labels_`;
      return this._py`attr_KMeans_labels_.tolist() if hasattr(attr_KMeans_labels_, 'tolist') else attr_KMeans_labels_`;
    })();
  }
  /**
    Sum of squared distances of samples to their closest cluster center, weighted by the sample weights if provided.
   */
  get inertia_() {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before accessing inertia_");
    }
    return (async () => {
      await this._py.ex`attr_KMeans_inertia_ = bridgeKMeans[${this.id}].inertia_`;
      return this._py`attr_KMeans_inertia_.tolist() if hasattr(attr_KMeans_inertia_, 'tolist') else attr_KMeans_inertia_`;
    })();
  }
  /**
    Number of iterations run.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_KMeans_n_iter_ = bridgeKMeans[${this.id}].n_iter_`;
      return this._py`attr_KMeans_n_iter_.tolist() if hasattr(attr_KMeans_n_iter_, 'tolist') else attr_KMeans_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KMeans must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_KMeans_n_features_in_ = bridgeKMeans[${this.id}].n_features_in_`;
      return this._py`attr_KMeans_n_features_in_.tolist() if hasattr(attr_KMeans_n_features_in_, 'tolist') else attr_KMeans_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This KMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KMeans must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KMeans_feature_names_in_ = bridgeKMeans[${this.id}].feature_names_in_`;
      return this._py`attr_KMeans_feature_names_in_.tolist() if hasattr(attr_KMeans_feature_names_in_, 'tolist') else attr_KMeans_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/MeanShift.ts
import crypto11 from "node:crypto";
var MeanShift = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `MeanShift${crypto11.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("MeanShift.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import MeanShift
try: bridgeMeanShift
except NameError: bridgeMeanShift = {}
`;
    await this._py.ex`ctor_MeanShift = {'bandwidth': ${this.opts["bandwidth"] ?? void 0}, 'seeds': np.array(${this.opts["seeds"] ?? void 0}) if ${this.opts["seeds"] !== void 0} else None, 'bin_seeding': ${this.opts["bin_seeding"] ?? void 0}, 'min_bin_freq': ${this.opts["min_bin_freq"] ?? void 0}, 'cluster_all': ${this.opts["cluster_all"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}}

ctor_MeanShift = {k: v for k, v in ctor_MeanShift.items() if v is not None}`;
    await this._py.ex`bridgeMeanShift[${this.id}] = MeanShift(**ctor_MeanShift)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMeanShift[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Perform clustering.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MeanShift must call init() before fit()");
    }
    await this._py.ex`pms_MeanShift_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MeanShift_fit = {k: v for k, v in pms_MeanShift_fit.items() if v is not None}`;
    await this._py.ex`res_MeanShift_fit = bridgeMeanShift[${this.id}].fit(**pms_MeanShift_fit)`;
    return this._py`res_MeanShift_fit.tolist() if hasattr(res_MeanShift_fit, 'tolist') else res_MeanShift_fit`;
  }
  /**
    Perform clustering on `X` and returns cluster labels.
   */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MeanShift must call init() before fit_predict()");
    }
    await this._py.ex`pms_MeanShift_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'kwargs': ${opts["kwargs"] ?? void 0}}

pms_MeanShift_fit_predict = {k: v for k, v in pms_MeanShift_fit_predict.items() if v is not None}`;
    await this._py.ex`res_MeanShift_fit_predict = bridgeMeanShift[${this.id}].fit_predict(**pms_MeanShift_fit_predict)`;
    return this._py`res_MeanShift_fit_predict.tolist() if hasattr(res_MeanShift_fit_predict, 'tolist') else res_MeanShift_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MeanShift must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MeanShift_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MeanShift_get_metadata_routing = {k: v for k, v in pms_MeanShift_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MeanShift_get_metadata_routing = bridgeMeanShift[${this.id}].get_metadata_routing(**pms_MeanShift_get_metadata_routing)`;
    return this._py`res_MeanShift_get_metadata_routing.tolist() if hasattr(res_MeanShift_get_metadata_routing, 'tolist') else res_MeanShift_get_metadata_routing`;
  }
  /**
    Predict the closest cluster each sample in X belongs to.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MeanShift must call init() before predict()");
    }
    await this._py.ex`pms_MeanShift_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MeanShift_predict = {k: v for k, v in pms_MeanShift_predict.items() if v is not None}`;
    await this._py.ex`res_MeanShift_predict = bridgeMeanShift[${this.id}].predict(**pms_MeanShift_predict)`;
    return this._py`res_MeanShift_predict.tolist() if hasattr(res_MeanShift_predict, 'tolist') else res_MeanShift_predict`;
  }
  /**
    Coordinates of cluster centers.
   */
  get cluster_centers_() {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MeanShift must call init() before accessing cluster_centers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MeanShift_cluster_centers_ = bridgeMeanShift[${this.id}].cluster_centers_`;
      return this._py`attr_MeanShift_cluster_centers_.tolist() if hasattr(attr_MeanShift_cluster_centers_, 'tolist') else attr_MeanShift_cluster_centers_`;
    })();
  }
  /**
    Labels of each point.
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MeanShift must call init() before accessing labels_");
    }
    return (async () => {
      await this._py.ex`attr_MeanShift_labels_ = bridgeMeanShift[${this.id}].labels_`;
      return this._py`attr_MeanShift_labels_.tolist() if hasattr(attr_MeanShift_labels_, 'tolist') else attr_MeanShift_labels_`;
    })();
  }
  /**
    Maximum number of iterations performed on each seed.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MeanShift must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_MeanShift_n_iter_ = bridgeMeanShift[${this.id}].n_iter_`;
      return this._py`attr_MeanShift_n_iter_.tolist() if hasattr(attr_MeanShift_n_iter_, 'tolist') else attr_MeanShift_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MeanShift must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MeanShift_n_features_in_ = bridgeMeanShift[${this.id}].n_features_in_`;
      return this._py`attr_MeanShift_n_features_in_.tolist() if hasattr(attr_MeanShift_n_features_in_, 'tolist') else attr_MeanShift_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This MeanShift instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MeanShift must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MeanShift_feature_names_in_ = bridgeMeanShift[${this.id}].feature_names_in_`;
      return this._py`attr_MeanShift_feature_names_in_.tolist() if hasattr(attr_MeanShift_feature_names_in_, 'tolist') else attr_MeanShift_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/MiniBatchKMeans.ts
import crypto12 from "node:crypto";
var MiniBatchKMeans = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `MiniBatchKMeans${crypto12.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("MiniBatchKMeans.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import MiniBatchKMeans
try: bridgeMiniBatchKMeans
except NameError: bridgeMiniBatchKMeans = {}
`;
    await this._py.ex`ctor_MiniBatchKMeans = {'n_clusters': ${this.opts["n_clusters"] ?? void 0}, 'init': np.array(${this.opts["init"] ?? void 0}) if ${this.opts["init"] !== void 0} else None, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'batch_size': ${this.opts["batch_size"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'compute_labels': ${this.opts["compute_labels"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'max_no_improvement': ${this.opts["max_no_improvement"] ?? void 0}, 'init_size': ${this.opts["init_size"] ?? void 0}, 'n_init': ${this.opts["n_init"] ?? void 0}, 'reassignment_ratio': ${this.opts["reassignment_ratio"] ?? void 0}}

ctor_MiniBatchKMeans = {k: v for k, v in ctor_MiniBatchKMeans.items() if v is not None}`;
    await this._py.ex`bridgeMiniBatchKMeans[${this.id}] = MiniBatchKMeans(**ctor_MiniBatchKMeans)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMiniBatchKMeans[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the centroids on X by chunking it into mini-batches.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchKMeans must call init() before fit()");
    }
    await this._py.ex`pms_MiniBatchKMeans_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MiniBatchKMeans_fit = {k: v for k, v in pms_MiniBatchKMeans_fit.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_fit = bridgeMiniBatchKMeans[${this.id}].fit(**pms_MiniBatchKMeans_fit)`;
    return this._py`res_MiniBatchKMeans_fit.tolist() if hasattr(res_MiniBatchKMeans_fit, 'tolist') else res_MiniBatchKMeans_fit`;
  }
  /**
      Compute cluster centers and predict cluster index for each sample.
  
      Convenience method; equivalent to calling fit(X) followed by predict(X).
     */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchKMeans must call init() before fit_predict()");
    }
    await this._py.ex`pms_MiniBatchKMeans_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MiniBatchKMeans_fit_predict = {k: v for k, v in pms_MiniBatchKMeans_fit_predict.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_fit_predict = bridgeMiniBatchKMeans[${this.id}].fit_predict(**pms_MiniBatchKMeans_fit_predict)`;
    return this._py`res_MiniBatchKMeans_fit_predict.tolist() if hasattr(res_MiniBatchKMeans_fit_predict, 'tolist') else res_MiniBatchKMeans_fit_predict`;
  }
  /**
      Compute clustering and transform X to cluster-distance space.
  
      Equivalent to fit(X).transform(X), but more efficiently implemented.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchKMeans must call init() before fit_transform()");
    }
    await this._py.ex`pms_MiniBatchKMeans_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MiniBatchKMeans_fit_transform = {k: v for k, v in pms_MiniBatchKMeans_fit_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_fit_transform = bridgeMiniBatchKMeans[${this.id}].fit_transform(**pms_MiniBatchKMeans_fit_transform)`;
    return this._py`res_MiniBatchKMeans_fit_transform.tolist() if hasattr(res_MiniBatchKMeans_fit_transform, 'tolist') else res_MiniBatchKMeans_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class_name0", "class_name1", "class_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_MiniBatchKMeans_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_MiniBatchKMeans_get_feature_names_out = {k: v for k, v in pms_MiniBatchKMeans_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_get_feature_names_out = bridgeMiniBatchKMeans[${this.id}].get_feature_names_out(**pms_MiniBatchKMeans_get_feature_names_out)`;
    return this._py`res_MiniBatchKMeans_get_feature_names_out.tolist() if hasattr(res_MiniBatchKMeans_get_feature_names_out, 'tolist') else res_MiniBatchKMeans_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MiniBatchKMeans_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MiniBatchKMeans_get_metadata_routing = {k: v for k, v in pms_MiniBatchKMeans_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_get_metadata_routing = bridgeMiniBatchKMeans[${this.id}].get_metadata_routing(**pms_MiniBatchKMeans_get_metadata_routing)`;
    return this._py`res_MiniBatchKMeans_get_metadata_routing.tolist() if hasattr(res_MiniBatchKMeans_get_metadata_routing, 'tolist') else res_MiniBatchKMeans_get_metadata_routing`;
  }
  /**
    Update k means estimate on a single mini-batch X.
   */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchKMeans must call init() before partial_fit()");
    }
    await this._py.ex`pms_MiniBatchKMeans_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MiniBatchKMeans_partial_fit = {k: v for k, v in pms_MiniBatchKMeans_partial_fit.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_partial_fit = bridgeMiniBatchKMeans[${this.id}].partial_fit(**pms_MiniBatchKMeans_partial_fit)`;
    return this._py`res_MiniBatchKMeans_partial_fit.tolist() if hasattr(res_MiniBatchKMeans_partial_fit, 'tolist') else res_MiniBatchKMeans_partial_fit`;
  }
  /**
      Predict the closest cluster each sample in X belongs to.
  
      In the vector quantization literature, `cluster_centers_` is called the code book and each value returned by `predict` is the index of the closest code in the code book.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchKMeans must call init() before predict()");
    }
    await this._py.ex`pms_MiniBatchKMeans_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MiniBatchKMeans_predict = {k: v for k, v in pms_MiniBatchKMeans_predict.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_predict = bridgeMiniBatchKMeans[${this.id}].predict(**pms_MiniBatchKMeans_predict)`;
    return this._py`res_MiniBatchKMeans_predict.tolist() if hasattr(res_MiniBatchKMeans_predict, 'tolist') else res_MiniBatchKMeans_predict`;
  }
  /**
    Opposite of the value of X on the K-means objective.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchKMeans must call init() before score()");
    }
    await this._py.ex`pms_MiniBatchKMeans_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_MiniBatchKMeans_score = {k: v for k, v in pms_MiniBatchKMeans_score.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_score = bridgeMiniBatchKMeans[${this.id}].score(**pms_MiniBatchKMeans_score)`;
    return this._py`res_MiniBatchKMeans_score.tolist() if hasattr(res_MiniBatchKMeans_score, 'tolist') else res_MiniBatchKMeans_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_MiniBatchKMeans_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MiniBatchKMeans_set_fit_request = {k: v for k, v in pms_MiniBatchKMeans_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_set_fit_request = bridgeMiniBatchKMeans[${this.id}].set_fit_request(**pms_MiniBatchKMeans_set_fit_request)`;
    return this._py`res_MiniBatchKMeans_set_fit_request.tolist() if hasattr(res_MiniBatchKMeans_set_fit_request, 'tolist') else res_MiniBatchKMeans_set_fit_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set_output API](https://scikit-learn.org/stable/modules/generated/../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchKMeans must call init() before set_output()");
    }
    await this._py.ex`pms_MiniBatchKMeans_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_MiniBatchKMeans_set_output = {k: v for k, v in pms_MiniBatchKMeans_set_output.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_set_output = bridgeMiniBatchKMeans[${this.id}].set_output(**pms_MiniBatchKMeans_set_output)`;
    return this._py`res_MiniBatchKMeans_set_output.tolist() if hasattr(res_MiniBatchKMeans_set_output, 'tolist') else res_MiniBatchKMeans_set_output`;
  }
  /**
      Request metadata passed to the `partial_fit` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_MiniBatchKMeans_set_partial_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MiniBatchKMeans_set_partial_fit_request = {k: v for k, v in pms_MiniBatchKMeans_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_set_partial_fit_request = bridgeMiniBatchKMeans[${this.id}].set_partial_fit_request(**pms_MiniBatchKMeans_set_partial_fit_request)`;
    return this._py`res_MiniBatchKMeans_set_partial_fit_request.tolist() if hasattr(res_MiniBatchKMeans_set_partial_fit_request, 'tolist') else res_MiniBatchKMeans_set_partial_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_MiniBatchKMeans_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_MiniBatchKMeans_set_score_request = {k: v for k, v in pms_MiniBatchKMeans_set_score_request.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_set_score_request = bridgeMiniBatchKMeans[${this.id}].set_score_request(**pms_MiniBatchKMeans_set_score_request)`;
    return this._py`res_MiniBatchKMeans_set_score_request.tolist() if hasattr(res_MiniBatchKMeans_set_score_request, 'tolist') else res_MiniBatchKMeans_set_score_request`;
  }
  /**
      Transform X to a cluster-distance space.
  
      In the new space, each dimension is the distance to the cluster centers. Note that even if X is sparse, the array returned by `transform` will typically be dense.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchKMeans must call init() before transform()");
    }
    await this._py.ex`pms_MiniBatchKMeans_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MiniBatchKMeans_transform = {k: v for k, v in pms_MiniBatchKMeans_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchKMeans_transform = bridgeMiniBatchKMeans[${this.id}].transform(**pms_MiniBatchKMeans_transform)`;
    return this._py`res_MiniBatchKMeans_transform.tolist() if hasattr(res_MiniBatchKMeans_transform, 'tolist') else res_MiniBatchKMeans_transform`;
  }
  /**
    Coordinates of cluster centers.
   */
  get cluster_centers_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before accessing cluster_centers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchKMeans_cluster_centers_ = bridgeMiniBatchKMeans[${this.id}].cluster_centers_`;
      return this._py`attr_MiniBatchKMeans_cluster_centers_.tolist() if hasattr(attr_MiniBatchKMeans_cluster_centers_, 'tolist') else attr_MiniBatchKMeans_cluster_centers_`;
    })();
  }
  /**
    Labels of each point (if compute_labels is set to `true`).
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before accessing labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchKMeans_labels_ = bridgeMiniBatchKMeans[${this.id}].labels_`;
      return this._py`attr_MiniBatchKMeans_labels_.tolist() if hasattr(attr_MiniBatchKMeans_labels_, 'tolist') else attr_MiniBatchKMeans_labels_`;
    })();
  }
  /**
    The value of the inertia criterion associated with the chosen partition if compute_labels is set to `true`. If compute_labels is set to `false`, it’s an approximation of the inertia based on an exponentially weighted average of the batch inertiae. The inertia is defined as the sum of square distances of samples to their cluster center, weighted by the sample weights if provided.
   */
  get inertia_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before accessing inertia_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchKMeans_inertia_ = bridgeMiniBatchKMeans[${this.id}].inertia_`;
      return this._py`attr_MiniBatchKMeans_inertia_.tolist() if hasattr(attr_MiniBatchKMeans_inertia_, 'tolist') else attr_MiniBatchKMeans_inertia_`;
    })();
  }
  /**
    Number of iterations over the full dataset.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchKMeans_n_iter_ = bridgeMiniBatchKMeans[${this.id}].n_iter_`;
      return this._py`attr_MiniBatchKMeans_n_iter_.tolist() if hasattr(attr_MiniBatchKMeans_n_iter_, 'tolist') else attr_MiniBatchKMeans_n_iter_`;
    })();
  }
  /**
    Number of minibatches processed.
   */
  get n_steps_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before accessing n_steps_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchKMeans_n_steps_ = bridgeMiniBatchKMeans[${this.id}].n_steps_`;
      return this._py`attr_MiniBatchKMeans_n_steps_.tolist() if hasattr(attr_MiniBatchKMeans_n_steps_, 'tolist') else attr_MiniBatchKMeans_n_steps_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchKMeans_n_features_in_ = bridgeMiniBatchKMeans[${this.id}].n_features_in_`;
      return this._py`attr_MiniBatchKMeans_n_features_in_.tolist() if hasattr(attr_MiniBatchKMeans_n_features_in_, 'tolist') else attr_MiniBatchKMeans_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchKMeans instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchKMeans must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchKMeans_feature_names_in_ = bridgeMiniBatchKMeans[${this.id}].feature_names_in_`;
      return this._py`attr_MiniBatchKMeans_feature_names_in_.tolist() if hasattr(attr_MiniBatchKMeans_feature_names_in_, 'tolist') else attr_MiniBatchKMeans_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/OPTICS.ts
import crypto13 from "node:crypto";
var OPTICS = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `OPTICS${crypto13.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("OPTICS.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import OPTICS
try: bridgeOPTICS
except NameError: bridgeOPTICS = {}
`;
    await this._py.ex`ctor_OPTICS = {'min_samples': ${this.opts["min_samples"] ?? void 0}, 'max_eps': ${this.opts["max_eps"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'p': ${this.opts["p"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}, 'cluster_method': ${this.opts["cluster_method"] ?? void 0}, 'eps': ${this.opts["eps"] ?? void 0}, 'xi': ${this.opts["xi"] ?? void 0}, 'predecessor_correction': ${this.opts["predecessor_correction"] ?? void 0}, 'min_cluster_size': ${this.opts["min_cluster_size"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'memory': ${this.opts["memory"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_OPTICS = {k: v for k, v in ctor_OPTICS.items() if v is not None}`;
    await this._py.ex`bridgeOPTICS[${this.id}] = OPTICS(**ctor_OPTICS)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeOPTICS[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Perform OPTICS clustering.
  
      Extracts an ordered list of points and reachability distances, and performs initial clustering using `max_eps` distance specified at OPTICS object instantiation.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OPTICS must call init() before fit()");
    }
    await this._py.ex`pms_OPTICS_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_OPTICS_fit = {k: v for k, v in pms_OPTICS_fit.items() if v is not None}`;
    await this._py.ex`res_OPTICS_fit = bridgeOPTICS[${this.id}].fit(**pms_OPTICS_fit)`;
    return this._py`res_OPTICS_fit.tolist() if hasattr(res_OPTICS_fit, 'tolist') else res_OPTICS_fit`;
  }
  /**
    Perform clustering on `X` and returns cluster labels.
   */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OPTICS must call init() before fit_predict()");
    }
    await this._py.ex`pms_OPTICS_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'kwargs': ${opts["kwargs"] ?? void 0}}

pms_OPTICS_fit_predict = {k: v for k, v in pms_OPTICS_fit_predict.items() if v is not None}`;
    await this._py.ex`res_OPTICS_fit_predict = bridgeOPTICS[${this.id}].fit_predict(**pms_OPTICS_fit_predict)`;
    return this._py`res_OPTICS_fit_predict.tolist() if hasattr(res_OPTICS_fit_predict, 'tolist') else res_OPTICS_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OPTICS must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_OPTICS_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_OPTICS_get_metadata_routing = {k: v for k, v in pms_OPTICS_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_OPTICS_get_metadata_routing = bridgeOPTICS[${this.id}].get_metadata_routing(**pms_OPTICS_get_metadata_routing)`;
    return this._py`res_OPTICS_get_metadata_routing.tolist() if hasattr(res_OPTICS_get_metadata_routing, 'tolist') else res_OPTICS_get_metadata_routing`;
  }
  /**
    Cluster labels for each point in the dataset given to fit(). Noisy samples and points which are not included in a leaf cluster of `cluster_hierarchy_` are labeled as -1.
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OPTICS must call init() before accessing labels_");
    }
    return (async () => {
      await this._py.ex`attr_OPTICS_labels_ = bridgeOPTICS[${this.id}].labels_`;
      return this._py`attr_OPTICS_labels_.tolist() if hasattr(attr_OPTICS_labels_, 'tolist') else attr_OPTICS_labels_`;
    })();
  }
  /**
    Reachability distances per sample, indexed by object order. Use `clust.reachability_\[clust.ordering_\]` to access in cluster order.
   */
  get reachability_() {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OPTICS must call init() before accessing reachability_");
    }
    return (async () => {
      await this._py.ex`attr_OPTICS_reachability_ = bridgeOPTICS[${this.id}].reachability_`;
      return this._py`attr_OPTICS_reachability_.tolist() if hasattr(attr_OPTICS_reachability_, 'tolist') else attr_OPTICS_reachability_`;
    })();
  }
  /**
    The cluster ordered list of sample indices.
   */
  get ordering_() {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OPTICS must call init() before accessing ordering_");
    }
    return (async () => {
      await this._py.ex`attr_OPTICS_ordering_ = bridgeOPTICS[${this.id}].ordering_`;
      return this._py`attr_OPTICS_ordering_.tolist() if hasattr(attr_OPTICS_ordering_, 'tolist') else attr_OPTICS_ordering_`;
    })();
  }
  /**
    Distance at which each sample becomes a core point, indexed by object order. Points which will never be core have a distance of inf. Use `clust.core_distances_\[clust.ordering_\]` to access in cluster order.
   */
  get core_distances_() {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OPTICS must call init() before accessing core_distances_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OPTICS_core_distances_ = bridgeOPTICS[${this.id}].core_distances_`;
      return this._py`attr_OPTICS_core_distances_.tolist() if hasattr(attr_OPTICS_core_distances_, 'tolist') else attr_OPTICS_core_distances_`;
    })();
  }
  /**
    Point that a sample was reached from, indexed by object order. Seed points have a predecessor of -1.
   */
  get predecessor_() {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OPTICS must call init() before accessing predecessor_");
    }
    return (async () => {
      await this._py.ex`attr_OPTICS_predecessor_ = bridgeOPTICS[${this.id}].predecessor_`;
      return this._py`attr_OPTICS_predecessor_.tolist() if hasattr(attr_OPTICS_predecessor_, 'tolist') else attr_OPTICS_predecessor_`;
    })();
  }
  /**
    The list of clusters in the form of `\[start, end\]` in each row, with all indices inclusive. The clusters are ordered according to `(end, \-start)` (ascending) so that larger clusters encompassing smaller clusters come after those smaller ones. Since `labels_` does not reflect the hierarchy, usually `len(cluster_hierarchy_) > np.unique(optics.labels_)`. Please also note that these indices are of the `ordering_`, i.e. `X\[ordering_\]\[start:end + 1\]` form a cluster. Only available when `cluster_method='xi'`.
   */
  get cluster_hierarchy_() {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OPTICS must call init() before accessing cluster_hierarchy_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OPTICS_cluster_hierarchy_ = bridgeOPTICS[${this.id}].cluster_hierarchy_`;
      return this._py`attr_OPTICS_cluster_hierarchy_.tolist() if hasattr(attr_OPTICS_cluster_hierarchy_, 'tolist') else attr_OPTICS_cluster_hierarchy_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OPTICS must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_OPTICS_n_features_in_ = bridgeOPTICS[${this.id}].n_features_in_`;
      return this._py`attr_OPTICS_n_features_in_.tolist() if hasattr(attr_OPTICS_n_features_in_, 'tolist') else attr_OPTICS_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This OPTICS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "OPTICS must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_OPTICS_feature_names_in_ = bridgeOPTICS[${this.id}].feature_names_in_`;
      return this._py`attr_OPTICS_feature_names_in_.tolist() if hasattr(attr_OPTICS_feature_names_in_, 'tolist') else attr_OPTICS_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/SpectralBiclustering.ts
import crypto14 from "node:crypto";
var SpectralBiclustering = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `SpectralBiclustering${crypto14.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "SpectralBiclustering.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import SpectralBiclustering
try: bridgeSpectralBiclustering
except NameError: bridgeSpectralBiclustering = {}
`;
    await this._py.ex`ctor_SpectralBiclustering = {'n_clusters': ${this.opts["n_clusters"] ?? void 0}, 'method': ${this.opts["method"] ?? void 0}, 'n_components': ${this.opts["n_components"] ?? void 0}, 'n_best': ${this.opts["n_best"] ?? void 0}, 'svd_method': ${this.opts["svd_method"] ?? void 0}, 'n_svd_vecs': ${this.opts["n_svd_vecs"] ?? void 0}, 'mini_batch': ${this.opts["mini_batch"] ?? void 0}, 'init': np.array(${this.opts["init"] ?? void 0}) if ${this.opts["init"] !== void 0} else None, 'n_init': ${this.opts["n_init"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_SpectralBiclustering = {k: v for k, v in ctor_SpectralBiclustering.items() if v is not None}`;
    await this._py.ex`bridgeSpectralBiclustering[${this.id}] = SpectralBiclustering(**ctor_SpectralBiclustering)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSpectralBiclustering[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Create a biclustering for X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SpectralBiclustering must call init() before fit()");
    }
    await this._py.ex`pms_SpectralBiclustering_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_SpectralBiclustering_fit = {k: v for k, v in pms_SpectralBiclustering_fit.items() if v is not None}`;
    await this._py.ex`res_SpectralBiclustering_fit = bridgeSpectralBiclustering[${this.id}].fit(**pms_SpectralBiclustering_fit)`;
    return this._py`res_SpectralBiclustering_fit.tolist() if hasattr(res_SpectralBiclustering_fit, 'tolist') else res_SpectralBiclustering_fit`;
  }
  /**
      Row and column indices of the `i`’th bicluster.
  
      Only works if `rows_` and `columns_` attributes exist.
     */
  async get_indices(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before get_indices()"
      );
    }
    await this._py.ex`pms_SpectralBiclustering_get_indices = {'i': ${opts["i"] ?? void 0}}

pms_SpectralBiclustering_get_indices = {k: v for k, v in pms_SpectralBiclustering_get_indices.items() if v is not None}`;
    await this._py.ex`res_SpectralBiclustering_get_indices = bridgeSpectralBiclustering[${this.id}].get_indices(**pms_SpectralBiclustering_get_indices)`;
    return this._py`res_SpectralBiclustering_get_indices.tolist() if hasattr(res_SpectralBiclustering_get_indices, 'tolist') else res_SpectralBiclustering_get_indices`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SpectralBiclustering_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SpectralBiclustering_get_metadata_routing = {k: v for k, v in pms_SpectralBiclustering_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SpectralBiclustering_get_metadata_routing = bridgeSpectralBiclustering[${this.id}].get_metadata_routing(**pms_SpectralBiclustering_get_metadata_routing)`;
    return this._py`res_SpectralBiclustering_get_metadata_routing.tolist() if hasattr(res_SpectralBiclustering_get_metadata_routing, 'tolist') else res_SpectralBiclustering_get_metadata_routing`;
  }
  /**
    Shape of the `i`’th bicluster.
   */
  async get_shape(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before get_shape()"
      );
    }
    await this._py.ex`pms_SpectralBiclustering_get_shape = {'i': ${opts["i"] ?? void 0}}

pms_SpectralBiclustering_get_shape = {k: v for k, v in pms_SpectralBiclustering_get_shape.items() if v is not None}`;
    await this._py.ex`res_SpectralBiclustering_get_shape = bridgeSpectralBiclustering[${this.id}].get_shape(**pms_SpectralBiclustering_get_shape)`;
    return this._py`res_SpectralBiclustering_get_shape.tolist() if hasattr(res_SpectralBiclustering_get_shape, 'tolist') else res_SpectralBiclustering_get_shape`;
  }
  /**
    Return the submatrix corresponding to bicluster `i`.
   */
  async get_submatrix(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before get_submatrix()"
      );
    }
    await this._py.ex`pms_SpectralBiclustering_get_submatrix = {'i': ${opts["i"] ?? void 0}, 'data': np.array(${opts["data"] ?? void 0}) if ${opts["data"] !== void 0} else None}

pms_SpectralBiclustering_get_submatrix = {k: v for k, v in pms_SpectralBiclustering_get_submatrix.items() if v is not None}`;
    await this._py.ex`res_SpectralBiclustering_get_submatrix = bridgeSpectralBiclustering[${this.id}].get_submatrix(**pms_SpectralBiclustering_get_submatrix)`;
    return this._py`res_SpectralBiclustering_get_submatrix.tolist() if hasattr(res_SpectralBiclustering_get_submatrix, 'tolist') else res_SpectralBiclustering_get_submatrix`;
  }
  /**
    Results of the clustering. `rows\[i, r\]` is `true` if cluster `i` contains row `r`. Available only after calling `fit`.
   */
  get rows_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before accessing rows_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralBiclustering_rows_ = bridgeSpectralBiclustering[${this.id}].rows_`;
      return this._py`attr_SpectralBiclustering_rows_.tolist() if hasattr(attr_SpectralBiclustering_rows_, 'tolist') else attr_SpectralBiclustering_rows_`;
    })();
  }
  /**
    Results of the clustering, like `rows`.
   */
  get columns_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before accessing columns_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralBiclustering_columns_ = bridgeSpectralBiclustering[${this.id}].columns_`;
      return this._py`attr_SpectralBiclustering_columns_.tolist() if hasattr(attr_SpectralBiclustering_columns_, 'tolist') else attr_SpectralBiclustering_columns_`;
    })();
  }
  /**
    Row partition labels.
   */
  get row_labels_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before accessing row_labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralBiclustering_row_labels_ = bridgeSpectralBiclustering[${this.id}].row_labels_`;
      return this._py`attr_SpectralBiclustering_row_labels_.tolist() if hasattr(attr_SpectralBiclustering_row_labels_, 'tolist') else attr_SpectralBiclustering_row_labels_`;
    })();
  }
  /**
    Column partition labels.
   */
  get column_labels_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before accessing column_labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralBiclustering_column_labels_ = bridgeSpectralBiclustering[${this.id}].column_labels_`;
      return this._py`attr_SpectralBiclustering_column_labels_.tolist() if hasattr(attr_SpectralBiclustering_column_labels_, 'tolist') else attr_SpectralBiclustering_column_labels_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralBiclustering_n_features_in_ = bridgeSpectralBiclustering[${this.id}].n_features_in_`;
      return this._py`attr_SpectralBiclustering_n_features_in_.tolist() if hasattr(attr_SpectralBiclustering_n_features_in_, 'tolist') else attr_SpectralBiclustering_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralBiclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralBiclustering must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralBiclustering_feature_names_in_ = bridgeSpectralBiclustering[${this.id}].feature_names_in_`;
      return this._py`attr_SpectralBiclustering_feature_names_in_.tolist() if hasattr(attr_SpectralBiclustering_feature_names_in_, 'tolist') else attr_SpectralBiclustering_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/SpectralClustering.ts
import crypto15 from "node:crypto";
var SpectralClustering = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `SpectralClustering${crypto15.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralClustering instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "SpectralClustering.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import SpectralClustering
try: bridgeSpectralClustering
except NameError: bridgeSpectralClustering = {}
`;
    await this._py.ex`ctor_SpectralClustering = {'n_clusters': ${this.opts["n_clusters"] ?? void 0}, 'eigen_solver': ${this.opts["eigen_solver"] ?? void 0}, 'n_components': ${this.opts["n_components"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'n_init': ${this.opts["n_init"] ?? void 0}, 'gamma': ${this.opts["gamma"] ?? void 0}, 'affinity': ${this.opts["affinity"] ?? void 0}, 'n_neighbors': ${this.opts["n_neighbors"] ?? void 0}, 'eigen_tol': ${this.opts["eigen_tol"] ?? void 0}, 'assign_labels': ${this.opts["assign_labels"] ?? void 0}, 'degree': ${this.opts["degree"] ?? void 0}, 'coef0': ${this.opts["coef0"] ?? void 0}, 'kernel_params': ${this.opts["kernel_params"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_SpectralClustering = {k: v for k, v in ctor_SpectralClustering.items() if v is not None}`;
    await this._py.ex`bridgeSpectralClustering[${this.id}] = SpectralClustering(**ctor_SpectralClustering)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSpectralClustering[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Perform spectral clustering from features, or affinity matrix.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SpectralClustering must call init() before fit()");
    }
    await this._py.ex`pms_SpectralClustering_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_SpectralClustering_fit = {k: v for k, v in pms_SpectralClustering_fit.items() if v is not None}`;
    await this._py.ex`res_SpectralClustering_fit = bridgeSpectralClustering[${this.id}].fit(**pms_SpectralClustering_fit)`;
    return this._py`res_SpectralClustering_fit.tolist() if hasattr(res_SpectralClustering_fit, 'tolist') else res_SpectralClustering_fit`;
  }
  /**
    Perform spectral clustering on `X` and return cluster labels.
   */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralClustering must call init() before fit_predict()"
      );
    }
    await this._py.ex`pms_SpectralClustering_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_SpectralClustering_fit_predict = {k: v for k, v in pms_SpectralClustering_fit_predict.items() if v is not None}`;
    await this._py.ex`res_SpectralClustering_fit_predict = bridgeSpectralClustering[${this.id}].fit_predict(**pms_SpectralClustering_fit_predict)`;
    return this._py`res_SpectralClustering_fit_predict.tolist() if hasattr(res_SpectralClustering_fit_predict, 'tolist') else res_SpectralClustering_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralClustering must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SpectralClustering_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SpectralClustering_get_metadata_routing = {k: v for k, v in pms_SpectralClustering_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SpectralClustering_get_metadata_routing = bridgeSpectralClustering[${this.id}].get_metadata_routing(**pms_SpectralClustering_get_metadata_routing)`;
    return this._py`res_SpectralClustering_get_metadata_routing.tolist() if hasattr(res_SpectralClustering_get_metadata_routing, 'tolist') else res_SpectralClustering_get_metadata_routing`;
  }
  /**
    Affinity matrix used for clustering. Available only after calling `fit`.
   */
  get affinity_matrix_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralClustering must call init() before accessing affinity_matrix_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralClustering_affinity_matrix_ = bridgeSpectralClustering[${this.id}].affinity_matrix_`;
      return this._py`attr_SpectralClustering_affinity_matrix_.tolist() if hasattr(attr_SpectralClustering_affinity_matrix_, 'tolist') else attr_SpectralClustering_affinity_matrix_`;
    })();
  }
  /**
    Labels of each point
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralClustering must call init() before accessing labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralClustering_labels_ = bridgeSpectralClustering[${this.id}].labels_`;
      return this._py`attr_SpectralClustering_labels_.tolist() if hasattr(attr_SpectralClustering_labels_, 'tolist') else attr_SpectralClustering_labels_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralClustering must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralClustering_n_features_in_ = bridgeSpectralClustering[${this.id}].n_features_in_`;
      return this._py`attr_SpectralClustering_n_features_in_.tolist() if hasattr(attr_SpectralClustering_n_features_in_, 'tolist') else attr_SpectralClustering_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralClustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralClustering must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralClustering_feature_names_in_ = bridgeSpectralClustering[${this.id}].feature_names_in_`;
      return this._py`attr_SpectralClustering_feature_names_in_.tolist() if hasattr(attr_SpectralClustering_feature_names_in_, 'tolist') else attr_SpectralClustering_feature_names_in_`;
    })();
  }
};

// src/generated/cluster/SpectralCoclustering.ts
import crypto16 from "node:crypto";
var SpectralCoclustering = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `SpectralCoclustering${crypto16.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "SpectralCoclustering.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import SpectralCoclustering
try: bridgeSpectralCoclustering
except NameError: bridgeSpectralCoclustering = {}
`;
    await this._py.ex`ctor_SpectralCoclustering = {'n_clusters': ${this.opts["n_clusters"] ?? void 0}, 'svd_method': ${this.opts["svd_method"] ?? void 0}, 'n_svd_vecs': ${this.opts["n_svd_vecs"] ?? void 0}, 'mini_batch': ${this.opts["mini_batch"] ?? void 0}, 'init': np.array(${this.opts["init"] ?? void 0}) if ${this.opts["init"] !== void 0} else None, 'n_init': ${this.opts["n_init"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_SpectralCoclustering = {k: v for k, v in ctor_SpectralCoclustering.items() if v is not None}`;
    await this._py.ex`bridgeSpectralCoclustering[${this.id}] = SpectralCoclustering(**ctor_SpectralCoclustering)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSpectralCoclustering[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Create a biclustering for X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("SpectralCoclustering must call init() before fit()");
    }
    await this._py.ex`pms_SpectralCoclustering_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_SpectralCoclustering_fit = {k: v for k, v in pms_SpectralCoclustering_fit.items() if v is not None}`;
    await this._py.ex`res_SpectralCoclustering_fit = bridgeSpectralCoclustering[${this.id}].fit(**pms_SpectralCoclustering_fit)`;
    return this._py`res_SpectralCoclustering_fit.tolist() if hasattr(res_SpectralCoclustering_fit, 'tolist') else res_SpectralCoclustering_fit`;
  }
  /**
      Row and column indices of the `i`’th bicluster.
  
      Only works if `rows_` and `columns_` attributes exist.
     */
  async get_indices(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before get_indices()"
      );
    }
    await this._py.ex`pms_SpectralCoclustering_get_indices = {'i': ${opts["i"] ?? void 0}}

pms_SpectralCoclustering_get_indices = {k: v for k, v in pms_SpectralCoclustering_get_indices.items() if v is not None}`;
    await this._py.ex`res_SpectralCoclustering_get_indices = bridgeSpectralCoclustering[${this.id}].get_indices(**pms_SpectralCoclustering_get_indices)`;
    return this._py`res_SpectralCoclustering_get_indices.tolist() if hasattr(res_SpectralCoclustering_get_indices, 'tolist') else res_SpectralCoclustering_get_indices`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SpectralCoclustering_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SpectralCoclustering_get_metadata_routing = {k: v for k, v in pms_SpectralCoclustering_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SpectralCoclustering_get_metadata_routing = bridgeSpectralCoclustering[${this.id}].get_metadata_routing(**pms_SpectralCoclustering_get_metadata_routing)`;
    return this._py`res_SpectralCoclustering_get_metadata_routing.tolist() if hasattr(res_SpectralCoclustering_get_metadata_routing, 'tolist') else res_SpectralCoclustering_get_metadata_routing`;
  }
  /**
    Shape of the `i`’th bicluster.
   */
  async get_shape(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before get_shape()"
      );
    }
    await this._py.ex`pms_SpectralCoclustering_get_shape = {'i': ${opts["i"] ?? void 0}}

pms_SpectralCoclustering_get_shape = {k: v for k, v in pms_SpectralCoclustering_get_shape.items() if v is not None}`;
    await this._py.ex`res_SpectralCoclustering_get_shape = bridgeSpectralCoclustering[${this.id}].get_shape(**pms_SpectralCoclustering_get_shape)`;
    return this._py`res_SpectralCoclustering_get_shape.tolist() if hasattr(res_SpectralCoclustering_get_shape, 'tolist') else res_SpectralCoclustering_get_shape`;
  }
  /**
    Return the submatrix corresponding to bicluster `i`.
   */
  async get_submatrix(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before get_submatrix()"
      );
    }
    await this._py.ex`pms_SpectralCoclustering_get_submatrix = {'i': ${opts["i"] ?? void 0}, 'data': np.array(${opts["data"] ?? void 0}) if ${opts["data"] !== void 0} else None}

pms_SpectralCoclustering_get_submatrix = {k: v for k, v in pms_SpectralCoclustering_get_submatrix.items() if v is not None}`;
    await this._py.ex`res_SpectralCoclustering_get_submatrix = bridgeSpectralCoclustering[${this.id}].get_submatrix(**pms_SpectralCoclustering_get_submatrix)`;
    return this._py`res_SpectralCoclustering_get_submatrix.tolist() if hasattr(res_SpectralCoclustering_get_submatrix, 'tolist') else res_SpectralCoclustering_get_submatrix`;
  }
  /**
    Results of the clustering. `rows\[i, r\]` is `true` if cluster `i` contains row `r`. Available only after calling `fit`.
   */
  get rows_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before accessing rows_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralCoclustering_rows_ = bridgeSpectralCoclustering[${this.id}].rows_`;
      return this._py`attr_SpectralCoclustering_rows_.tolist() if hasattr(attr_SpectralCoclustering_rows_, 'tolist') else attr_SpectralCoclustering_rows_`;
    })();
  }
  /**
    Results of the clustering, like `rows`.
   */
  get columns_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before accessing columns_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralCoclustering_columns_ = bridgeSpectralCoclustering[${this.id}].columns_`;
      return this._py`attr_SpectralCoclustering_columns_.tolist() if hasattr(attr_SpectralCoclustering_columns_, 'tolist') else attr_SpectralCoclustering_columns_`;
    })();
  }
  /**
    The bicluster label of each row.
   */
  get row_labels_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before accessing row_labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralCoclustering_row_labels_ = bridgeSpectralCoclustering[${this.id}].row_labels_`;
      return this._py`attr_SpectralCoclustering_row_labels_.tolist() if hasattr(attr_SpectralCoclustering_row_labels_, 'tolist') else attr_SpectralCoclustering_row_labels_`;
    })();
  }
  /**
    The bicluster label of each column.
   */
  get column_labels_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before accessing column_labels_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralCoclustering_column_labels_ = bridgeSpectralCoclustering[${this.id}].column_labels_`;
      return this._py`attr_SpectralCoclustering_column_labels_.tolist() if hasattr(attr_SpectralCoclustering_column_labels_, 'tolist') else attr_SpectralCoclustering_column_labels_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralCoclustering_n_features_in_ = bridgeSpectralCoclustering[${this.id}].n_features_in_`;
      return this._py`attr_SpectralCoclustering_n_features_in_.tolist() if hasattr(attr_SpectralCoclustering_n_features_in_, 'tolist') else attr_SpectralCoclustering_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This SpectralCoclustering instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "SpectralCoclustering must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SpectralCoclustering_feature_names_in_ = bridgeSpectralCoclustering[${this.id}].feature_names_in_`;
      return this._py`attr_SpectralCoclustering_feature_names_in_.tolist() if hasattr(attr_SpectralCoclustering_feature_names_in_, 'tolist') else attr_SpectralCoclustering_feature_names_in_`;
    })();
  }
};

// src/generated/compose/ColumnTransformer.ts
import crypto17 from "node:crypto";
var ColumnTransformer = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `ColumnTransformer${crypto17.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This ColumnTransformer instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("ColumnTransformer.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.compose import ColumnTransformer
try: bridgeColumnTransformer
except NameError: bridgeColumnTransformer = {}
`;
    await this._py.ex`ctor_ColumnTransformer = {'transformers': ${this.opts["transformers"] ?? void 0}, 'remainder': ${this.opts["remainder"] ?? void 0}, 'sparse_threshold': ${this.opts["sparse_threshold"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'transformer_weights': ${this.opts["transformer_weights"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'verbose_feature_names_out': ${this.opts["verbose_feature_names_out"] ?? void 0}, 'force_int_remainder_cols': ${this.opts["force_int_remainder_cols"] ?? void 0}}

ctor_ColumnTransformer = {k: v for k, v in ctor_ColumnTransformer.items() if v is not None}`;
    await this._py.ex`bridgeColumnTransformer[${this.id}] = ColumnTransformer(**ctor_ColumnTransformer)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeColumnTransformer[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit all transformers using X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ColumnTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ColumnTransformer must call init() before fit()");
    }
    await this._py.ex`pms_ColumnTransformer_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'params': ${opts["params"] ?? void 0}}

pms_ColumnTransformer_fit = {k: v for k, v in pms_ColumnTransformer_fit.items() if v is not None}`;
    await this._py.ex`res_ColumnTransformer_fit = bridgeColumnTransformer[${this.id}].fit(**pms_ColumnTransformer_fit)`;
    return this._py`res_ColumnTransformer_fit.tolist() if hasattr(res_ColumnTransformer_fit, 'tolist') else res_ColumnTransformer_fit`;
  }
  /**
    Fit all transformers, transform the data and concatenate results.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ColumnTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ColumnTransformer must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_ColumnTransformer_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'params': ${opts["params"] ?? void 0}}

pms_ColumnTransformer_fit_transform = {k: v for k, v in pms_ColumnTransformer_fit_transform.items() if v is not None}`;
    await this._py.ex`res_ColumnTransformer_fit_transform = bridgeColumnTransformer[${this.id}].fit_transform(**pms_ColumnTransformer_fit_transform)`;
    return this._py`res_ColumnTransformer_fit_transform.tolist() if hasattr(res_ColumnTransformer_fit_transform, 'tolist') else res_ColumnTransformer_fit_transform`;
  }
  /**
    Get output feature names for transformation.
   */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ColumnTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ColumnTransformer must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_ColumnTransformer_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_ColumnTransformer_get_feature_names_out = {k: v for k, v in pms_ColumnTransformer_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_ColumnTransformer_get_feature_names_out = bridgeColumnTransformer[${this.id}].get_feature_names_out(**pms_ColumnTransformer_get_feature_names_out)`;
    return this._py`res_ColumnTransformer_get_feature_names_out.tolist() if hasattr(res_ColumnTransformer_get_feature_names_out, 'tolist') else res_ColumnTransformer_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ColumnTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ColumnTransformer must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_ColumnTransformer_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_ColumnTransformer_get_metadata_routing = {k: v for k, v in pms_ColumnTransformer_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_ColumnTransformer_get_metadata_routing = bridgeColumnTransformer[${this.id}].get_metadata_routing(**pms_ColumnTransformer_get_metadata_routing)`;
    return this._py`res_ColumnTransformer_get_metadata_routing.tolist() if hasattr(res_ColumnTransformer_get_metadata_routing, 'tolist') else res_ColumnTransformer_get_metadata_routing`;
  }
  /**
      Set the output container when `"transform"` and `"fit_transform"` are called.
  
      Calling `set_output` will set the output of all estimators in `transformers` and `transformers_`.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ColumnTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ColumnTransformer must call init() before set_output()");
    }
    await this._py.ex`pms_ColumnTransformer_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_ColumnTransformer_set_output = {k: v for k, v in pms_ColumnTransformer_set_output.items() if v is not None}`;
    await this._py.ex`res_ColumnTransformer_set_output = bridgeColumnTransformer[${this.id}].set_output(**pms_ColumnTransformer_set_output)`;
    return this._py`res_ColumnTransformer_set_output.tolist() if hasattr(res_ColumnTransformer_set_output, 'tolist') else res_ColumnTransformer_set_output`;
  }
  /**
    Transform X separately by each transformer, concatenate results.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ColumnTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ColumnTransformer must call init() before transform()");
    }
    await this._py.ex`pms_ColumnTransformer_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'params': ${opts["params"] ?? void 0}}

pms_ColumnTransformer_transform = {k: v for k, v in pms_ColumnTransformer_transform.items() if v is not None}`;
    await this._py.ex`res_ColumnTransformer_transform = bridgeColumnTransformer[${this.id}].transform(**pms_ColumnTransformer_transform)`;
    return this._py`res_ColumnTransformer_transform.tolist() if hasattr(res_ColumnTransformer_transform, 'tolist') else res_ColumnTransformer_transform`;
  }
  /**
    The collection of fitted transformers as tuples of (name, fitted_transformer, column). `fitted_transformer` can be an estimator, or `'drop'`; `'passthrough'` is replaced with an equivalent [`FunctionTransformer`](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.FunctionTransformer.html#sklearn.preprocessing.FunctionTransformer "sklearn.preprocessing.FunctionTransformer"). In case there were no columns selected, this will be the unfitted transformer. If there are remaining columns, the final element is a tuple of the form: (‘remainder’, transformer, remaining_columns) corresponding to the `remainder` parameter. If there are remaining columns, then `len(transformers_)==len(transformers)+1`, otherwise `len(transformers_)==len(transformers)`.
   */
  get transformers_() {
    if (this._isDisposed) {
      throw new Error(
        "This ColumnTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ColumnTransformer must call init() before accessing transformers_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ColumnTransformer_transformers_ = bridgeColumnTransformer[${this.id}].transformers_`;
      return this._py`attr_ColumnTransformer_transformers_.tolist() if hasattr(attr_ColumnTransformer_transformers_, 'tolist') else attr_ColumnTransformer_transformers_`;
    })();
  }
  /**
    Boolean flag indicating whether the output of `transform` is a sparse matrix or a dense numpy array, which depends on the output of the individual transformers and the `sparse_threshold` keyword.
   */
  get sparse_output_() {
    if (this._isDisposed) {
      throw new Error(
        "This ColumnTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ColumnTransformer must call init() before accessing sparse_output_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ColumnTransformer_sparse_output_ = bridgeColumnTransformer[${this.id}].sparse_output_`;
      return this._py`attr_ColumnTransformer_sparse_output_.tolist() if hasattr(attr_ColumnTransformer_sparse_output_, 'tolist') else attr_ColumnTransformer_sparse_output_`;
    })();
  }
  /**
    A dictionary from each transformer name to a slice, where the slice corresponds to indices in the transformed output. This is useful to inspect which transformer is responsible for which transformed feature(s).
   */
  get output_indices_() {
    if (this._isDisposed) {
      throw new Error(
        "This ColumnTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ColumnTransformer must call init() before accessing output_indices_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ColumnTransformer_output_indices_ = bridgeColumnTransformer[${this.id}].output_indices_`;
      return this._py`attr_ColumnTransformer_output_indices_.tolist() if hasattr(attr_ColumnTransformer_output_indices_, 'tolist') else attr_ColumnTransformer_output_indices_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Only defined if the underlying transformers expose such an attribute when fit.
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This ColumnTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ColumnTransformer must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ColumnTransformer_n_features_in_ = bridgeColumnTransformer[${this.id}].n_features_in_`;
      return this._py`attr_ColumnTransformer_n_features_in_.tolist() if hasattr(attr_ColumnTransformer_n_features_in_, 'tolist') else attr_ColumnTransformer_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This ColumnTransformer instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ColumnTransformer must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ColumnTransformer_feature_names_in_ = bridgeColumnTransformer[${this.id}].feature_names_in_`;
      return this._py`attr_ColumnTransformer_feature_names_in_.tolist() if hasattr(attr_ColumnTransformer_feature_names_in_, 'tolist') else attr_ColumnTransformer_feature_names_in_`;
    })();
  }
};

// src/generated/compose/TransformedTargetRegressor.ts
import crypto18 from "node:crypto";
var TransformedTargetRegressor = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `TransformedTargetRegressor${crypto18.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This TransformedTargetRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "TransformedTargetRegressor.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.compose import TransformedTargetRegressor
try: bridgeTransformedTargetRegressor
except NameError: bridgeTransformedTargetRegressor = {}
`;
    await this._py.ex`ctor_TransformedTargetRegressor = {'regressor': ${this.opts["regressor"] ?? void 0}, 'transformer': ${this.opts["transformer"] ?? void 0}, 'func': ${this.opts["func"] ?? void 0}, 'inverse_func': ${this.opts["inverse_func"] ?? void 0}, 'check_inverse': ${this.opts["check_inverse"] ?? void 0}}

ctor_TransformedTargetRegressor = {k: v for k, v in ctor_TransformedTargetRegressor.items() if v is not None}`;
    await this._py.ex`bridgeTransformedTargetRegressor[${this.id}] = TransformedTargetRegressor(**ctor_TransformedTargetRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeTransformedTargetRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model according to the given training data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TransformedTargetRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TransformedTargetRegressor must call init() before fit()"
      );
    }
    await this._py.ex`pms_TransformedTargetRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_TransformedTargetRegressor_fit = {k: v for k, v in pms_TransformedTargetRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_TransformedTargetRegressor_fit = bridgeTransformedTargetRegressor[${this.id}].fit(**pms_TransformedTargetRegressor_fit)`;
    return this._py`res_TransformedTargetRegressor_fit.tolist() if hasattr(res_TransformedTargetRegressor_fit, 'tolist') else res_TransformedTargetRegressor_fit`;
  }
  /**
      Raise `NotImplementedError`.
  
      This estimator does not support metadata routing yet.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TransformedTargetRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TransformedTargetRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_TransformedTargetRegressor_get_metadata_routing = {}

pms_TransformedTargetRegressor_get_metadata_routing = {k: v for k, v in pms_TransformedTargetRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_TransformedTargetRegressor_get_metadata_routing = bridgeTransformedTargetRegressor[${this.id}].get_metadata_routing(**pms_TransformedTargetRegressor_get_metadata_routing)`;
    return this._py`res_TransformedTargetRegressor_get_metadata_routing.tolist() if hasattr(res_TransformedTargetRegressor_get_metadata_routing, 'tolist') else res_TransformedTargetRegressor_get_metadata_routing`;
  }
  /**
      Predict using the base regressor, applying inverse.
  
      The regressor is used to predict and the `inverse_func` or `inverse_transform` is applied before returning the prediction.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TransformedTargetRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TransformedTargetRegressor must call init() before predict()"
      );
    }
    await this._py.ex`pms_TransformedTargetRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'predict_params': ${opts["predict_params"] ?? void 0}}

pms_TransformedTargetRegressor_predict = {k: v for k, v in pms_TransformedTargetRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_TransformedTargetRegressor_predict = bridgeTransformedTargetRegressor[${this.id}].predict(**pms_TransformedTargetRegressor_predict)`;
    return this._py`res_TransformedTargetRegressor_predict.tolist() if hasattr(res_TransformedTargetRegressor_predict, 'tolist') else res_TransformedTargetRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y_true \- y_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y_true \- y_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TransformedTargetRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TransformedTargetRegressor must call init() before score()"
      );
    }
    await this._py.ex`pms_TransformedTargetRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_TransformedTargetRegressor_score = {k: v for k, v in pms_TransformedTargetRegressor_score.items() if v is not None}`;
    await this._py.ex`res_TransformedTargetRegressor_score = bridgeTransformedTargetRegressor[${this.id}].score(**pms_TransformedTargetRegressor_score)`;
    return this._py`res_TransformedTargetRegressor_score.tolist() if hasattr(res_TransformedTargetRegressor_score, 'tolist') else res_TransformedTargetRegressor_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This TransformedTargetRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TransformedTargetRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_TransformedTargetRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_TransformedTargetRegressor_set_score_request = {k: v for k, v in pms_TransformedTargetRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_TransformedTargetRegressor_set_score_request = bridgeTransformedTargetRegressor[${this.id}].set_score_request(**pms_TransformedTargetRegressor_set_score_request)`;
    return this._py`res_TransformedTargetRegressor_set_score_request.tolist() if hasattr(res_TransformedTargetRegressor_set_score_request, 'tolist') else res_TransformedTargetRegressor_set_score_request`;
  }
  /**
    Fitted regressor.
   */
  get regressor_() {
    if (this._isDisposed) {
      throw new Error(
        "This TransformedTargetRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TransformedTargetRegressor must call init() before accessing regressor_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TransformedTargetRegressor_regressor_ = bridgeTransformedTargetRegressor[${this.id}].regressor_`;
      return this._py`attr_TransformedTargetRegressor_regressor_.tolist() if hasattr(attr_TransformedTargetRegressor_regressor_, 'tolist') else attr_TransformedTargetRegressor_regressor_`;
    })();
  }
  /**
    Transformer used in [`fit`](https://scikit-learn.org/stable/modules/generated/#sklearn.compose.TransformedTargetRegressor.fit "sklearn.compose.TransformedTargetRegressor.fit") and [`predict`](https://scikit-learn.org/stable/modules/generated/#sklearn.compose.TransformedTargetRegressor.predict "sklearn.compose.TransformedTargetRegressor.predict").
   */
  get transformer_() {
    if (this._isDisposed) {
      throw new Error(
        "This TransformedTargetRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TransformedTargetRegressor must call init() before accessing transformer_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TransformedTargetRegressor_transformer_ = bridgeTransformedTargetRegressor[${this.id}].transformer_`;
      return this._py`attr_TransformedTargetRegressor_transformer_.tolist() if hasattr(attr_TransformedTargetRegressor_transformer_, 'tolist') else attr_TransformedTargetRegressor_transformer_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This TransformedTargetRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "TransformedTargetRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TransformedTargetRegressor_feature_names_in_ = bridgeTransformedTargetRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_TransformedTargetRegressor_feature_names_in_.tolist() if hasattr(attr_TransformedTargetRegressor_feature_names_in_, 'tolist') else attr_TransformedTargetRegressor_feature_names_in_`;
    })();
  }
};

// src/generated/covariance/EllipticEnvelope.ts
import crypto19 from "node:crypto";
var EllipticEnvelope = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `EllipticEnvelope${crypto19.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("EllipticEnvelope.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.covariance import EllipticEnvelope
try: bridgeEllipticEnvelope
except NameError: bridgeEllipticEnvelope = {}
`;
    await this._py.ex`ctor_EllipticEnvelope = {'store_precision': ${this.opts["store_precision"] ?? void 0}, 'assume_centered': ${this.opts["assume_centered"] ?? void 0}, 'support_fraction': ${this.opts["support_fraction"] ?? void 0}, 'contamination': ${this.opts["contamination"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_EllipticEnvelope = {k: v for k, v in ctor_EllipticEnvelope.items() if v is not None}`;
    await this._py.ex`bridgeEllipticEnvelope[${this.id}] = EllipticEnvelope(**ctor_EllipticEnvelope)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeEllipticEnvelope[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Apply a correction to raw Minimum Covariance Determinant estimates.
  
      Correction using the empirical correction factor suggested by Rousseeuw and Van Driessen in [\[RVD\]](https://scikit-learn.org/stable/modules/generated/#rbb2ba44703ed-rvd).
     */
  async correct_covariance(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before correct_covariance()"
      );
    }
    await this._py.ex`pms_EllipticEnvelope_correct_covariance = {'data': np.array(${opts["data"] ?? void 0}) if ${opts["data"] !== void 0} else None}

pms_EllipticEnvelope_correct_covariance = {k: v for k, v in pms_EllipticEnvelope_correct_covariance.items() if v is not None}`;
    await this._py.ex`res_EllipticEnvelope_correct_covariance = bridgeEllipticEnvelope[${this.id}].correct_covariance(**pms_EllipticEnvelope_correct_covariance)`;
    return this._py`res_EllipticEnvelope_correct_covariance.tolist() if hasattr(res_EllipticEnvelope_correct_covariance, 'tolist') else res_EllipticEnvelope_correct_covariance`;
  }
  /**
    Compute the decision function of the given observations.
   */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_EllipticEnvelope_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_EllipticEnvelope_decision_function = {k: v for k, v in pms_EllipticEnvelope_decision_function.items() if v is not None}`;
    await this._py.ex`res_EllipticEnvelope_decision_function = bridgeEllipticEnvelope[${this.id}].decision_function(**pms_EllipticEnvelope_decision_function)`;
    return this._py`res_EllipticEnvelope_decision_function.tolist() if hasattr(res_EllipticEnvelope_decision_function, 'tolist') else res_EllipticEnvelope_decision_function`;
  }
  /**
    Compute the Mean Squared Error between two covariance estimators.
   */
  async error_norm(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("EllipticEnvelope must call init() before error_norm()");
    }
    await this._py.ex`pms_EllipticEnvelope_error_norm = {'comp_cov': np.array(${opts["comp_cov"] ?? void 0}) if ${opts["comp_cov"] !== void 0} else None, 'norm': ${opts["norm"] ?? void 0}, 'scaling': ${opts["scaling"] ?? void 0}, 'squared': ${opts["squared"] ?? void 0}}

pms_EllipticEnvelope_error_norm = {k: v for k, v in pms_EllipticEnvelope_error_norm.items() if v is not None}`;
    await this._py.ex`res_EllipticEnvelope_error_norm = bridgeEllipticEnvelope[${this.id}].error_norm(**pms_EllipticEnvelope_error_norm)`;
    return this._py`res_EllipticEnvelope_error_norm.tolist() if hasattr(res_EllipticEnvelope_error_norm, 'tolist') else res_EllipticEnvelope_error_norm`;
  }
  /**
    Fit the EllipticEnvelope model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("EllipticEnvelope must call init() before fit()");
    }
    await this._py.ex`pms_EllipticEnvelope_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_EllipticEnvelope_fit = {k: v for k, v in pms_EllipticEnvelope_fit.items() if v is not None}`;
    await this._py.ex`res_EllipticEnvelope_fit = bridgeEllipticEnvelope[${this.id}].fit(**pms_EllipticEnvelope_fit)`;
    return this._py`res_EllipticEnvelope_fit.tolist() if hasattr(res_EllipticEnvelope_fit, 'tolist') else res_EllipticEnvelope_fit`;
  }
  /**
      Perform fit on X and returns labels for X.
  
      Returns -1 for outliers and 1 for inliers.
     */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("EllipticEnvelope must call init() before fit_predict()");
    }
    await this._py.ex`pms_EllipticEnvelope_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'kwargs': ${opts["kwargs"] ?? void 0}}

pms_EllipticEnvelope_fit_predict = {k: v for k, v in pms_EllipticEnvelope_fit_predict.items() if v is not None}`;
    await this._py.ex`res_EllipticEnvelope_fit_predict = bridgeEllipticEnvelope[${this.id}].fit_predict(**pms_EllipticEnvelope_fit_predict)`;
    return this._py`res_EllipticEnvelope_fit_predict.tolist() if hasattr(res_EllipticEnvelope_fit_predict, 'tolist') else res_EllipticEnvelope_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_EllipticEnvelope_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_EllipticEnvelope_get_metadata_routing = {k: v for k, v in pms_EllipticEnvelope_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_EllipticEnvelope_get_metadata_routing = bridgeEllipticEnvelope[${this.id}].get_metadata_routing(**pms_EllipticEnvelope_get_metadata_routing)`;
    return this._py`res_EllipticEnvelope_get_metadata_routing.tolist() if hasattr(res_EllipticEnvelope_get_metadata_routing, 'tolist') else res_EllipticEnvelope_get_metadata_routing`;
  }
  /**
    Getter for the precision matrix.
   */
  async get_precision(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before get_precision()"
      );
    }
    await this._py.ex`pms_EllipticEnvelope_get_precision = {'precision_': np.array(${opts["precision_"] ?? void 0}) if ${opts["precision_"] !== void 0} else None}

pms_EllipticEnvelope_get_precision = {k: v for k, v in pms_EllipticEnvelope_get_precision.items() if v is not None}`;
    await this._py.ex`res_EllipticEnvelope_get_precision = bridgeEllipticEnvelope[${this.id}].get_precision(**pms_EllipticEnvelope_get_precision)`;
    return this._py`res_EllipticEnvelope_get_precision.tolist() if hasattr(res_EllipticEnvelope_get_precision, 'tolist') else res_EllipticEnvelope_get_precision`;
  }
  /**
    Compute the squared Mahalanobis distances of given observations.
   */
  async mahalanobis(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("EllipticEnvelope must call init() before mahalanobis()");
    }
    await this._py.ex`pms_EllipticEnvelope_mahalanobis = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_EllipticEnvelope_mahalanobis = {k: v for k, v in pms_EllipticEnvelope_mahalanobis.items() if v is not None}`;
    await this._py.ex`res_EllipticEnvelope_mahalanobis = bridgeEllipticEnvelope[${this.id}].mahalanobis(**pms_EllipticEnvelope_mahalanobis)`;
    return this._py`res_EllipticEnvelope_mahalanobis.tolist() if hasattr(res_EllipticEnvelope_mahalanobis, 'tolist') else res_EllipticEnvelope_mahalanobis`;
  }
  /**
    Predict labels (1 inlier, -1 outlier) of X according to fitted model.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("EllipticEnvelope must call init() before predict()");
    }
    await this._py.ex`pms_EllipticEnvelope_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_EllipticEnvelope_predict = {k: v for k, v in pms_EllipticEnvelope_predict.items() if v is not None}`;
    await this._py.ex`res_EllipticEnvelope_predict = bridgeEllipticEnvelope[${this.id}].predict(**pms_EllipticEnvelope_predict)`;
    return this._py`res_EllipticEnvelope_predict.tolist() if hasattr(res_EllipticEnvelope_predict, 'tolist') else res_EllipticEnvelope_predict`;
  }
  /**
      Re-weight raw Minimum Covariance Determinant estimates.
  
      Re-weight observations using Rousseeuw’s method (equivalent to deleting outlying observations from the data set before computing location and covariance estimates) described in [\[RVDriessen\]](https://scikit-learn.org/stable/modules/generated/#rd2c89e63f1c9-rvdriessen).
     */
  async reweight_covariance(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before reweight_covariance()"
      );
    }
    await this._py.ex`pms_EllipticEnvelope_reweight_covariance = {'data': np.array(${opts["data"] ?? void 0}) if ${opts["data"] !== void 0} else None}

pms_EllipticEnvelope_reweight_covariance = {k: v for k, v in pms_EllipticEnvelope_reweight_covariance.items() if v is not None}`;
    await this._py.ex`res_EllipticEnvelope_reweight_covariance = bridgeEllipticEnvelope[${this.id}].reweight_covariance(**pms_EllipticEnvelope_reweight_covariance)`;
    return this._py`res_EllipticEnvelope_reweight_covariance.tolist() if hasattr(res_EllipticEnvelope_reweight_covariance, 'tolist') else res_EllipticEnvelope_reweight_covariance`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("EllipticEnvelope must call init() before score()");
    }
    await this._py.ex`pms_EllipticEnvelope_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_EllipticEnvelope_score = {k: v for k, v in pms_EllipticEnvelope_score.items() if v is not None}`;
    await this._py.ex`res_EllipticEnvelope_score = bridgeEllipticEnvelope[${this.id}].score(**pms_EllipticEnvelope_score)`;
    return this._py`res_EllipticEnvelope_score.tolist() if hasattr(res_EllipticEnvelope_score, 'tolist') else res_EllipticEnvelope_score`;
  }
  /**
    Compute the negative Mahalanobis distances.
   */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before score_samples()"
      );
    }
    await this._py.ex`pms_EllipticEnvelope_score_samples = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_EllipticEnvelope_score_samples = {k: v for k, v in pms_EllipticEnvelope_score_samples.items() if v is not None}`;
    await this._py.ex`res_EllipticEnvelope_score_samples = bridgeEllipticEnvelope[${this.id}].score_samples(**pms_EllipticEnvelope_score_samples)`;
    return this._py`res_EllipticEnvelope_score_samples.tolist() if hasattr(res_EllipticEnvelope_score_samples, 'tolist') else res_EllipticEnvelope_score_samples`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_EllipticEnvelope_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_EllipticEnvelope_set_score_request = {k: v for k, v in pms_EllipticEnvelope_set_score_request.items() if v is not None}`;
    await this._py.ex`res_EllipticEnvelope_set_score_request = bridgeEllipticEnvelope[${this.id}].set_score_request(**pms_EllipticEnvelope_set_score_request)`;
    return this._py`res_EllipticEnvelope_set_score_request.tolist() if hasattr(res_EllipticEnvelope_set_score_request, 'tolist') else res_EllipticEnvelope_set_score_request`;
  }
  /**
    Estimated robust location.
   */
  get location_() {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before accessing location_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EllipticEnvelope_location_ = bridgeEllipticEnvelope[${this.id}].location_`;
      return this._py`attr_EllipticEnvelope_location_.tolist() if hasattr(attr_EllipticEnvelope_location_, 'tolist') else attr_EllipticEnvelope_location_`;
    })();
  }
  /**
    Estimated robust covariance matrix.
   */
  get covariance_() {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before accessing covariance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EllipticEnvelope_covariance_ = bridgeEllipticEnvelope[${this.id}].covariance_`;
      return this._py`attr_EllipticEnvelope_covariance_.tolist() if hasattr(attr_EllipticEnvelope_covariance_, 'tolist') else attr_EllipticEnvelope_covariance_`;
    })();
  }
  /**
    Estimated pseudo inverse matrix. (stored only if store_precision is `true`)
   */
  get precision_() {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before accessing precision_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EllipticEnvelope_precision_ = bridgeEllipticEnvelope[${this.id}].precision_`;
      return this._py`attr_EllipticEnvelope_precision_.tolist() if hasattr(attr_EllipticEnvelope_precision_, 'tolist') else attr_EllipticEnvelope_precision_`;
    })();
  }
  /**
    A mask of the observations that have been used to compute the robust estimates of location and shape.
   */
  get support_() {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before accessing support_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EllipticEnvelope_support_ = bridgeEllipticEnvelope[${this.id}].support_`;
      return this._py`attr_EllipticEnvelope_support_.tolist() if hasattr(attr_EllipticEnvelope_support_, 'tolist') else attr_EllipticEnvelope_support_`;
    })();
  }
  /**
    Offset used to define the decision function from the raw scores. We have the relation: `decision_function \= score_samples \- offset_`. The offset depends on the contamination parameter and is defined in such a way we obtain the expected number of outliers (samples with decision function < 0) in training.
   */
  get offset_() {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before accessing offset_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EllipticEnvelope_offset_ = bridgeEllipticEnvelope[${this.id}].offset_`;
      return this._py`attr_EllipticEnvelope_offset_.tolist() if hasattr(attr_EllipticEnvelope_offset_, 'tolist') else attr_EllipticEnvelope_offset_`;
    })();
  }
  /**
    The raw robust estimated location before correction and re-weighting.
   */
  get raw_location_() {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before accessing raw_location_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EllipticEnvelope_raw_location_ = bridgeEllipticEnvelope[${this.id}].raw_location_`;
      return this._py`attr_EllipticEnvelope_raw_location_.tolist() if hasattr(attr_EllipticEnvelope_raw_location_, 'tolist') else attr_EllipticEnvelope_raw_location_`;
    })();
  }
  /**
    The raw robust estimated covariance before correction and re-weighting.
   */
  get raw_covariance_() {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before accessing raw_covariance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EllipticEnvelope_raw_covariance_ = bridgeEllipticEnvelope[${this.id}].raw_covariance_`;
      return this._py`attr_EllipticEnvelope_raw_covariance_.tolist() if hasattr(attr_EllipticEnvelope_raw_covariance_, 'tolist') else attr_EllipticEnvelope_raw_covariance_`;
    })();
  }
  /**
    A mask of the observations that have been used to compute the raw robust estimates of location and shape, before correction and re-weighting.
   */
  get raw_support_() {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before accessing raw_support_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EllipticEnvelope_raw_support_ = bridgeEllipticEnvelope[${this.id}].raw_support_`;
      return this._py`attr_EllipticEnvelope_raw_support_.tolist() if hasattr(attr_EllipticEnvelope_raw_support_, 'tolist') else attr_EllipticEnvelope_raw_support_`;
    })();
  }
  /**
    Mahalanobis distances of the training set (on which [`fit`](https://scikit-learn.org/stable/modules/generated/#sklearn.covariance.EllipticEnvelope.fit "sklearn.covariance.EllipticEnvelope.fit") is called) observations.
   */
  get dist_() {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before accessing dist_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EllipticEnvelope_dist_ = bridgeEllipticEnvelope[${this.id}].dist_`;
      return this._py`attr_EllipticEnvelope_dist_.tolist() if hasattr(attr_EllipticEnvelope_dist_, 'tolist') else attr_EllipticEnvelope_dist_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EllipticEnvelope_n_features_in_ = bridgeEllipticEnvelope[${this.id}].n_features_in_`;
      return this._py`attr_EllipticEnvelope_n_features_in_.tolist() if hasattr(attr_EllipticEnvelope_n_features_in_, 'tolist') else attr_EllipticEnvelope_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This EllipticEnvelope instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EllipticEnvelope must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EllipticEnvelope_feature_names_in_ = bridgeEllipticEnvelope[${this.id}].feature_names_in_`;
      return this._py`attr_EllipticEnvelope_feature_names_in_.tolist() if hasattr(attr_EllipticEnvelope_feature_names_in_, 'tolist') else attr_EllipticEnvelope_feature_names_in_`;
    })();
  }
};

// src/generated/covariance/EmpiricalCovariance.ts
import crypto20 from "node:crypto";
var EmpiricalCovariance = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `EmpiricalCovariance${crypto20.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This EmpiricalCovariance instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "EmpiricalCovariance.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.covariance import EmpiricalCovariance
try: bridgeEmpiricalCovariance
except NameError: bridgeEmpiricalCovariance = {}
`;
    await this._py.ex`ctor_EmpiricalCovariance = {'store_precision': ${this.opts["store_precision"] ?? void 0}, 'assume_centered': ${this.opts["assume_centered"] ?? void 0}}

ctor_EmpiricalCovariance = {k: v for k, v in ctor_EmpiricalCovariance.items() if v is not None}`;
    await this._py.ex`bridgeEmpiricalCovariance[${this.id}] = EmpiricalCovariance(**ctor_EmpiricalCovariance)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeEmpiricalCovariance[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the Mean Squared Error between two covariance estimators.
   */
  async error_norm(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EmpiricalCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EmpiricalCovariance must call init() before error_norm()"
      );
    }
    await this._py.ex`pms_EmpiricalCovariance_error_norm = {'comp_cov': np.array(${opts["comp_cov"] ?? void 0}) if ${opts["comp_cov"] !== void 0} else None, 'norm': ${opts["norm"] ?? void 0}, 'scaling': ${opts["scaling"] ?? void 0}, 'squared': ${opts["squared"] ?? void 0}}

pms_EmpiricalCovariance_error_norm = {k: v for k, v in pms_EmpiricalCovariance_error_norm.items() if v is not None}`;
    await this._py.ex`res_EmpiricalCovariance_error_norm = bridgeEmpiricalCovariance[${this.id}].error_norm(**pms_EmpiricalCovariance_error_norm)`;
    return this._py`res_EmpiricalCovariance_error_norm.tolist() if hasattr(res_EmpiricalCovariance_error_norm, 'tolist') else res_EmpiricalCovariance_error_norm`;
  }
  /**
    Fit the maximum likelihood covariance estimator to X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EmpiricalCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("EmpiricalCovariance must call init() before fit()");
    }
    await this._py.ex`pms_EmpiricalCovariance_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_EmpiricalCovariance_fit = {k: v for k, v in pms_EmpiricalCovariance_fit.items() if v is not None}`;
    await this._py.ex`res_EmpiricalCovariance_fit = bridgeEmpiricalCovariance[${this.id}].fit(**pms_EmpiricalCovariance_fit)`;
    return this._py`res_EmpiricalCovariance_fit.tolist() if hasattr(res_EmpiricalCovariance_fit, 'tolist') else res_EmpiricalCovariance_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EmpiricalCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EmpiricalCovariance must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_EmpiricalCovariance_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_EmpiricalCovariance_get_metadata_routing = {k: v for k, v in pms_EmpiricalCovariance_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_EmpiricalCovariance_get_metadata_routing = bridgeEmpiricalCovariance[${this.id}].get_metadata_routing(**pms_EmpiricalCovariance_get_metadata_routing)`;
    return this._py`res_EmpiricalCovariance_get_metadata_routing.tolist() if hasattr(res_EmpiricalCovariance_get_metadata_routing, 'tolist') else res_EmpiricalCovariance_get_metadata_routing`;
  }
  /**
    Getter for the precision matrix.
   */
  async get_precision(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EmpiricalCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EmpiricalCovariance must call init() before get_precision()"
      );
    }
    await this._py.ex`pms_EmpiricalCovariance_get_precision = {'precision_': np.array(${opts["precision_"] ?? void 0}) if ${opts["precision_"] !== void 0} else None}

pms_EmpiricalCovariance_get_precision = {k: v for k, v in pms_EmpiricalCovariance_get_precision.items() if v is not None}`;
    await this._py.ex`res_EmpiricalCovariance_get_precision = bridgeEmpiricalCovariance[${this.id}].get_precision(**pms_EmpiricalCovariance_get_precision)`;
    return this._py`res_EmpiricalCovariance_get_precision.tolist() if hasattr(res_EmpiricalCovariance_get_precision, 'tolist') else res_EmpiricalCovariance_get_precision`;
  }
  /**
    Compute the squared Mahalanobis distances of given observations.
   */
  async mahalanobis(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EmpiricalCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EmpiricalCovariance must call init() before mahalanobis()"
      );
    }
    await this._py.ex`pms_EmpiricalCovariance_mahalanobis = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_EmpiricalCovariance_mahalanobis = {k: v for k, v in pms_EmpiricalCovariance_mahalanobis.items() if v is not None}`;
    await this._py.ex`res_EmpiricalCovariance_mahalanobis = bridgeEmpiricalCovariance[${this.id}].mahalanobis(**pms_EmpiricalCovariance_mahalanobis)`;
    return this._py`res_EmpiricalCovariance_mahalanobis.tolist() if hasattr(res_EmpiricalCovariance_mahalanobis, 'tolist') else res_EmpiricalCovariance_mahalanobis`;
  }
  /**
      Compute the log-likelihood of `X_test` under the estimated Gaussian model.
  
      The Gaussian model is defined by its mean and covariance matrix which are represented respectively by `self.location_` and `self.covariance_`.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EmpiricalCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("EmpiricalCovariance must call init() before score()");
    }
    await this._py.ex`pms_EmpiricalCovariance_score = {'X_test': np.array(${opts["X_test"] ?? void 0}) if ${opts["X_test"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_EmpiricalCovariance_score = {k: v for k, v in pms_EmpiricalCovariance_score.items() if v is not None}`;
    await this._py.ex`res_EmpiricalCovariance_score = bridgeEmpiricalCovariance[${this.id}].score(**pms_EmpiricalCovariance_score)`;
    return this._py`res_EmpiricalCovariance_score.tolist() if hasattr(res_EmpiricalCovariance_score, 'tolist') else res_EmpiricalCovariance_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This EmpiricalCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EmpiricalCovariance must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_EmpiricalCovariance_set_score_request = {'X_test': ${opts["X_test"] ?? void 0}}

pms_EmpiricalCovariance_set_score_request = {k: v for k, v in pms_EmpiricalCovariance_set_score_request.items() if v is not None}`;
    await this._py.ex`res_EmpiricalCovariance_set_score_request = bridgeEmpiricalCovariance[${this.id}].set_score_request(**pms_EmpiricalCovariance_set_score_request)`;
    return this._py`res_EmpiricalCovariance_set_score_request.tolist() if hasattr(res_EmpiricalCovariance_set_score_request, 'tolist') else res_EmpiricalCovariance_set_score_request`;
  }
  /**
    Estimated location, i.e. the estimated mean.
   */
  get location_() {
    if (this._isDisposed) {
      throw new Error(
        "This EmpiricalCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EmpiricalCovariance must call init() before accessing location_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EmpiricalCovariance_location_ = bridgeEmpiricalCovariance[${this.id}].location_`;
      return this._py`attr_EmpiricalCovariance_location_.tolist() if hasattr(attr_EmpiricalCovariance_location_, 'tolist') else attr_EmpiricalCovariance_location_`;
    })();
  }
  /**
    Estimated covariance matrix
   */
  get covariance_() {
    if (this._isDisposed) {
      throw new Error(
        "This EmpiricalCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EmpiricalCovariance must call init() before accessing covariance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EmpiricalCovariance_covariance_ = bridgeEmpiricalCovariance[${this.id}].covariance_`;
      return this._py`attr_EmpiricalCovariance_covariance_.tolist() if hasattr(attr_EmpiricalCovariance_covariance_, 'tolist') else attr_EmpiricalCovariance_covariance_`;
    })();
  }
  /**
    Estimated pseudo-inverse matrix. (stored only if store_precision is `true`)
   */
  get precision_() {
    if (this._isDisposed) {
      throw new Error(
        "This EmpiricalCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EmpiricalCovariance must call init() before accessing precision_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EmpiricalCovariance_precision_ = bridgeEmpiricalCovariance[${this.id}].precision_`;
      return this._py`attr_EmpiricalCovariance_precision_.tolist() if hasattr(attr_EmpiricalCovariance_precision_, 'tolist') else attr_EmpiricalCovariance_precision_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This EmpiricalCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EmpiricalCovariance must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EmpiricalCovariance_n_features_in_ = bridgeEmpiricalCovariance[${this.id}].n_features_in_`;
      return this._py`attr_EmpiricalCovariance_n_features_in_.tolist() if hasattr(attr_EmpiricalCovariance_n_features_in_, 'tolist') else attr_EmpiricalCovariance_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This EmpiricalCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "EmpiricalCovariance must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_EmpiricalCovariance_feature_names_in_ = bridgeEmpiricalCovariance[${this.id}].feature_names_in_`;
      return this._py`attr_EmpiricalCovariance_feature_names_in_.tolist() if hasattr(attr_EmpiricalCovariance_feature_names_in_, 'tolist') else attr_EmpiricalCovariance_feature_names_in_`;
    })();
  }
};

// src/generated/covariance/GraphicalLasso.ts
import crypto21 from "node:crypto";
var GraphicalLasso = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `GraphicalLasso${crypto21.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("GraphicalLasso.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.covariance import GraphicalLasso
try: bridgeGraphicalLasso
except NameError: bridgeGraphicalLasso = {}
`;
    await this._py.ex`ctor_GraphicalLasso = {'alpha': ${this.opts["alpha"] ?? void 0}, 'mode': ${this.opts["mode"] ?? void 0}, 'covariance': ${this.opts["covariance"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'enet_tol': ${this.opts["enet_tol"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'eps': ${this.opts["eps"] ?? void 0}, 'assume_centered': ${this.opts["assume_centered"] ?? void 0}}

ctor_GraphicalLasso = {k: v for k, v in ctor_GraphicalLasso.items() if v is not None}`;
    await this._py.ex`bridgeGraphicalLasso[${this.id}] = GraphicalLasso(**ctor_GraphicalLasso)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeGraphicalLasso[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the Mean Squared Error between two covariance estimators.
   */
  async error_norm(opts) {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GraphicalLasso must call init() before error_norm()");
    }
    await this._py.ex`pms_GraphicalLasso_error_norm = {'comp_cov': np.array(${opts["comp_cov"] ?? void 0}) if ${opts["comp_cov"] !== void 0} else None, 'norm': ${opts["norm"] ?? void 0}, 'scaling': ${opts["scaling"] ?? void 0}, 'squared': ${opts["squared"] ?? void 0}}

pms_GraphicalLasso_error_norm = {k: v for k, v in pms_GraphicalLasso_error_norm.items() if v is not None}`;
    await this._py.ex`res_GraphicalLasso_error_norm = bridgeGraphicalLasso[${this.id}].error_norm(**pms_GraphicalLasso_error_norm)`;
    return this._py`res_GraphicalLasso_error_norm.tolist() if hasattr(res_GraphicalLasso_error_norm, 'tolist') else res_GraphicalLasso_error_norm`;
  }
  /**
    Fit the GraphicalLasso model to X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GraphicalLasso must call init() before fit()");
    }
    await this._py.ex`pms_GraphicalLasso_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_GraphicalLasso_fit = {k: v for k, v in pms_GraphicalLasso_fit.items() if v is not None}`;
    await this._py.ex`res_GraphicalLasso_fit = bridgeGraphicalLasso[${this.id}].fit(**pms_GraphicalLasso_fit)`;
    return this._py`res_GraphicalLasso_fit.tolist() if hasattr(res_GraphicalLasso_fit, 'tolist') else res_GraphicalLasso_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLasso must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_GraphicalLasso_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_GraphicalLasso_get_metadata_routing = {k: v for k, v in pms_GraphicalLasso_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_GraphicalLasso_get_metadata_routing = bridgeGraphicalLasso[${this.id}].get_metadata_routing(**pms_GraphicalLasso_get_metadata_routing)`;
    return this._py`res_GraphicalLasso_get_metadata_routing.tolist() if hasattr(res_GraphicalLasso_get_metadata_routing, 'tolist') else res_GraphicalLasso_get_metadata_routing`;
  }
  /**
    Getter for the precision matrix.
   */
  async get_precision(opts) {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GraphicalLasso must call init() before get_precision()");
    }
    await this._py.ex`pms_GraphicalLasso_get_precision = {'precision_': np.array(${opts["precision_"] ?? void 0}) if ${opts["precision_"] !== void 0} else None}

pms_GraphicalLasso_get_precision = {k: v for k, v in pms_GraphicalLasso_get_precision.items() if v is not None}`;
    await this._py.ex`res_GraphicalLasso_get_precision = bridgeGraphicalLasso[${this.id}].get_precision(**pms_GraphicalLasso_get_precision)`;
    return this._py`res_GraphicalLasso_get_precision.tolist() if hasattr(res_GraphicalLasso_get_precision, 'tolist') else res_GraphicalLasso_get_precision`;
  }
  /**
    Compute the squared Mahalanobis distances of given observations.
   */
  async mahalanobis(opts) {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GraphicalLasso must call init() before mahalanobis()");
    }
    await this._py.ex`pms_GraphicalLasso_mahalanobis = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GraphicalLasso_mahalanobis = {k: v for k, v in pms_GraphicalLasso_mahalanobis.items() if v is not None}`;
    await this._py.ex`res_GraphicalLasso_mahalanobis = bridgeGraphicalLasso[${this.id}].mahalanobis(**pms_GraphicalLasso_mahalanobis)`;
    return this._py`res_GraphicalLasso_mahalanobis.tolist() if hasattr(res_GraphicalLasso_mahalanobis, 'tolist') else res_GraphicalLasso_mahalanobis`;
  }
  /**
      Compute the log-likelihood of `X_test` under the estimated Gaussian model.
  
      The Gaussian model is defined by its mean and covariance matrix which are represented respectively by `self.location_` and `self.covariance_`.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GraphicalLasso must call init() before score()");
    }
    await this._py.ex`pms_GraphicalLasso_score = {'X_test': np.array(${opts["X_test"] ?? void 0}) if ${opts["X_test"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_GraphicalLasso_score = {k: v for k, v in pms_GraphicalLasso_score.items() if v is not None}`;
    await this._py.ex`res_GraphicalLasso_score = bridgeGraphicalLasso[${this.id}].score(**pms_GraphicalLasso_score)`;
    return this._py`res_GraphicalLasso_score.tolist() if hasattr(res_GraphicalLasso_score, 'tolist') else res_GraphicalLasso_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLasso must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_GraphicalLasso_set_score_request = {'X_test': ${opts["X_test"] ?? void 0}}

pms_GraphicalLasso_set_score_request = {k: v for k, v in pms_GraphicalLasso_set_score_request.items() if v is not None}`;
    await this._py.ex`res_GraphicalLasso_set_score_request = bridgeGraphicalLasso[${this.id}].set_score_request(**pms_GraphicalLasso_set_score_request)`;
    return this._py`res_GraphicalLasso_set_score_request.tolist() if hasattr(res_GraphicalLasso_set_score_request, 'tolist') else res_GraphicalLasso_set_score_request`;
  }
  /**
    Estimated location, i.e. the estimated mean.
   */
  get location_() {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLasso must call init() before accessing location_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLasso_location_ = bridgeGraphicalLasso[${this.id}].location_`;
      return this._py`attr_GraphicalLasso_location_.tolist() if hasattr(attr_GraphicalLasso_location_, 'tolist') else attr_GraphicalLasso_location_`;
    })();
  }
  /**
    Estimated covariance matrix
   */
  get covariance_() {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLasso must call init() before accessing covariance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLasso_covariance_ = bridgeGraphicalLasso[${this.id}].covariance_`;
      return this._py`attr_GraphicalLasso_covariance_.tolist() if hasattr(attr_GraphicalLasso_covariance_, 'tolist') else attr_GraphicalLasso_covariance_`;
    })();
  }
  /**
    Estimated pseudo inverse matrix.
   */
  get precision_() {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLasso must call init() before accessing precision_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLasso_precision_ = bridgeGraphicalLasso[${this.id}].precision_`;
      return this._py`attr_GraphicalLasso_precision_.tolist() if hasattr(attr_GraphicalLasso_precision_, 'tolist') else attr_GraphicalLasso_precision_`;
    })();
  }
  /**
    Number of iterations run.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLasso must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLasso_n_iter_ = bridgeGraphicalLasso[${this.id}].n_iter_`;
      return this._py`attr_GraphicalLasso_n_iter_.tolist() if hasattr(attr_GraphicalLasso_n_iter_, 'tolist') else attr_GraphicalLasso_n_iter_`;
    })();
  }
  /**
    The list of values of the objective function and the dual gap at each iteration. Returned only if return_costs is `true`.
   */
  get costs_() {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("GraphicalLasso must call init() before accessing costs_");
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLasso_costs_ = bridgeGraphicalLasso[${this.id}].costs_`;
      return this._py`attr_GraphicalLasso_costs_.tolist() if hasattr(attr_GraphicalLasso_costs_, 'tolist') else attr_GraphicalLasso_costs_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLasso must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLasso_n_features_in_ = bridgeGraphicalLasso[${this.id}].n_features_in_`;
      return this._py`attr_GraphicalLasso_n_features_in_.tolist() if hasattr(attr_GraphicalLasso_n_features_in_, 'tolist') else attr_GraphicalLasso_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This GraphicalLasso instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLasso must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLasso_feature_names_in_ = bridgeGraphicalLasso[${this.id}].feature_names_in_`;
      return this._py`attr_GraphicalLasso_feature_names_in_.tolist() if hasattr(attr_GraphicalLasso_feature_names_in_, 'tolist') else attr_GraphicalLasso_feature_names_in_`;
    })();
  }
};

// src/generated/covariance/GraphicalLassoCV.ts
import crypto22 from "node:crypto";
var GraphicalLassoCV = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `GraphicalLassoCV${crypto22.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("GraphicalLassoCV.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.covariance import GraphicalLassoCV
try: bridgeGraphicalLassoCV
except NameError: bridgeGraphicalLassoCV = {}
`;
    await this._py.ex`ctor_GraphicalLassoCV = {'alphas': np.array(${this.opts["alphas"] ?? void 0}) if ${this.opts["alphas"] !== void 0} else None, 'n_refinements': ${this.opts["n_refinements"] ?? void 0}, 'cv': ${this.opts["cv"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'enet_tol': ${this.opts["enet_tol"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'mode': ${this.opts["mode"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'eps': ${this.opts["eps"] ?? void 0}, 'assume_centered': ${this.opts["assume_centered"] ?? void 0}}

ctor_GraphicalLassoCV = {k: v for k, v in ctor_GraphicalLassoCV.items() if v is not None}`;
    await this._py.ex`bridgeGraphicalLassoCV[${this.id}] = GraphicalLassoCV(**ctor_GraphicalLassoCV)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeGraphicalLassoCV[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the Mean Squared Error between two covariance estimators.
   */
  async error_norm(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("GraphicalLassoCV must call init() before error_norm()");
    }
    await this._py.ex`pms_GraphicalLassoCV_error_norm = {'comp_cov': np.array(${opts["comp_cov"] ?? void 0}) if ${opts["comp_cov"] !== void 0} else None, 'norm': ${opts["norm"] ?? void 0}, 'scaling': ${opts["scaling"] ?? void 0}, 'squared': ${opts["squared"] ?? void 0}}

pms_GraphicalLassoCV_error_norm = {k: v for k, v in pms_GraphicalLassoCV_error_norm.items() if v is not None}`;
    await this._py.ex`res_GraphicalLassoCV_error_norm = bridgeGraphicalLassoCV[${this.id}].error_norm(**pms_GraphicalLassoCV_error_norm)`;
    return this._py`res_GraphicalLassoCV_error_norm.tolist() if hasattr(res_GraphicalLassoCV_error_norm, 'tolist') else res_GraphicalLassoCV_error_norm`;
  }
  /**
    Fit the GraphicalLasso covariance model to X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("GraphicalLassoCV must call init() before fit()");
    }
    await this._py.ex`pms_GraphicalLassoCV_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'params': ${opts["params"] ?? void 0}}

pms_GraphicalLassoCV_fit = {k: v for k, v in pms_GraphicalLassoCV_fit.items() if v is not None}`;
    await this._py.ex`res_GraphicalLassoCV_fit = bridgeGraphicalLassoCV[${this.id}].fit(**pms_GraphicalLassoCV_fit)`;
    return this._py`res_GraphicalLassoCV_fit.tolist() if hasattr(res_GraphicalLassoCV_fit, 'tolist') else res_GraphicalLassoCV_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLassoCV must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_GraphicalLassoCV_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_GraphicalLassoCV_get_metadata_routing = {k: v for k, v in pms_GraphicalLassoCV_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_GraphicalLassoCV_get_metadata_routing = bridgeGraphicalLassoCV[${this.id}].get_metadata_routing(**pms_GraphicalLassoCV_get_metadata_routing)`;
    return this._py`res_GraphicalLassoCV_get_metadata_routing.tolist() if hasattr(res_GraphicalLassoCV_get_metadata_routing, 'tolist') else res_GraphicalLassoCV_get_metadata_routing`;
  }
  /**
    Getter for the precision matrix.
   */
  async get_precision(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLassoCV must call init() before get_precision()"
      );
    }
    await this._py.ex`pms_GraphicalLassoCV_get_precision = {'precision_': np.array(${opts["precision_"] ?? void 0}) if ${opts["precision_"] !== void 0} else None}

pms_GraphicalLassoCV_get_precision = {k: v for k, v in pms_GraphicalLassoCV_get_precision.items() if v is not None}`;
    await this._py.ex`res_GraphicalLassoCV_get_precision = bridgeGraphicalLassoCV[${this.id}].get_precision(**pms_GraphicalLassoCV_get_precision)`;
    return this._py`res_GraphicalLassoCV_get_precision.tolist() if hasattr(res_GraphicalLassoCV_get_precision, 'tolist') else res_GraphicalLassoCV_get_precision`;
  }
  /**
    Compute the squared Mahalanobis distances of given observations.
   */
  async mahalanobis(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("GraphicalLassoCV must call init() before mahalanobis()");
    }
    await this._py.ex`pms_GraphicalLassoCV_mahalanobis = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GraphicalLassoCV_mahalanobis = {k: v for k, v in pms_GraphicalLassoCV_mahalanobis.items() if v is not None}`;
    await this._py.ex`res_GraphicalLassoCV_mahalanobis = bridgeGraphicalLassoCV[${this.id}].mahalanobis(**pms_GraphicalLassoCV_mahalanobis)`;
    return this._py`res_GraphicalLassoCV_mahalanobis.tolist() if hasattr(res_GraphicalLassoCV_mahalanobis, 'tolist') else res_GraphicalLassoCV_mahalanobis`;
  }
  /**
      Compute the log-likelihood of `X_test` under the estimated Gaussian model.
  
      The Gaussian model is defined by its mean and covariance matrix which are represented respectively by `self.location_` and `self.covariance_`.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("GraphicalLassoCV must call init() before score()");
    }
    await this._py.ex`pms_GraphicalLassoCV_score = {'X_test': np.array(${opts["X_test"] ?? void 0}) if ${opts["X_test"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_GraphicalLassoCV_score = {k: v for k, v in pms_GraphicalLassoCV_score.items() if v is not None}`;
    await this._py.ex`res_GraphicalLassoCV_score = bridgeGraphicalLassoCV[${this.id}].score(**pms_GraphicalLassoCV_score)`;
    return this._py`res_GraphicalLassoCV_score.tolist() if hasattr(res_GraphicalLassoCV_score, 'tolist') else res_GraphicalLassoCV_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLassoCV must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_GraphicalLassoCV_set_score_request = {'X_test': ${opts["X_test"] ?? void 0}}

pms_GraphicalLassoCV_set_score_request = {k: v for k, v in pms_GraphicalLassoCV_set_score_request.items() if v is not None}`;
    await this._py.ex`res_GraphicalLassoCV_set_score_request = bridgeGraphicalLassoCV[${this.id}].set_score_request(**pms_GraphicalLassoCV_set_score_request)`;
    return this._py`res_GraphicalLassoCV_set_score_request.tolist() if hasattr(res_GraphicalLassoCV_set_score_request, 'tolist') else res_GraphicalLassoCV_set_score_request`;
  }
  /**
    Estimated location, i.e. the estimated mean.
   */
  get location_() {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLassoCV must call init() before accessing location_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLassoCV_location_ = bridgeGraphicalLassoCV[${this.id}].location_`;
      return this._py`attr_GraphicalLassoCV_location_.tolist() if hasattr(attr_GraphicalLassoCV_location_, 'tolist') else attr_GraphicalLassoCV_location_`;
    })();
  }
  /**
    Estimated covariance matrix.
   */
  get covariance_() {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLassoCV must call init() before accessing covariance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLassoCV_covariance_ = bridgeGraphicalLassoCV[${this.id}].covariance_`;
      return this._py`attr_GraphicalLassoCV_covariance_.tolist() if hasattr(attr_GraphicalLassoCV_covariance_, 'tolist') else attr_GraphicalLassoCV_covariance_`;
    })();
  }
  /**
    Estimated precision matrix (inverse covariance).
   */
  get precision_() {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLassoCV must call init() before accessing precision_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLassoCV_precision_ = bridgeGraphicalLassoCV[${this.id}].precision_`;
      return this._py`attr_GraphicalLassoCV_precision_.tolist() if hasattr(attr_GraphicalLassoCV_precision_, 'tolist') else attr_GraphicalLassoCV_precision_`;
    })();
  }
  /**
    The list of values of the objective function and the dual gap at each iteration. Returned only if return_costs is `true`.
   */
  get costs_() {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLassoCV must call init() before accessing costs_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLassoCV_costs_ = bridgeGraphicalLassoCV[${this.id}].costs_`;
      return this._py`attr_GraphicalLassoCV_costs_.tolist() if hasattr(attr_GraphicalLassoCV_costs_, 'tolist') else attr_GraphicalLassoCV_costs_`;
    })();
  }
  /**
    Penalization parameter selected.
   */
  get alpha_() {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLassoCV must call init() before accessing alpha_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLassoCV_alpha_ = bridgeGraphicalLassoCV[${this.id}].alpha_`;
      return this._py`attr_GraphicalLassoCV_alpha_.tolist() if hasattr(attr_GraphicalLassoCV_alpha_, 'tolist') else attr_GraphicalLassoCV_alpha_`;
    })();
  }
  /**
    A dict with keys:
   */
  get cv_results_() {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLassoCV must call init() before accessing cv_results_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLassoCV_cv_results_ = bridgeGraphicalLassoCV[${this.id}].cv_results_`;
      return this._py`attr_GraphicalLassoCV_cv_results_.tolist() if hasattr(attr_GraphicalLassoCV_cv_results_, 'tolist') else attr_GraphicalLassoCV_cv_results_`;
    })();
  }
  /**
    Number of iterations run for the optimal alpha.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLassoCV must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLassoCV_n_iter_ = bridgeGraphicalLassoCV[${this.id}].n_iter_`;
      return this._py`attr_GraphicalLassoCV_n_iter_.tolist() if hasattr(attr_GraphicalLassoCV_n_iter_, 'tolist') else attr_GraphicalLassoCV_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLassoCV must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLassoCV_n_features_in_ = bridgeGraphicalLassoCV[${this.id}].n_features_in_`;
      return this._py`attr_GraphicalLassoCV_n_features_in_.tolist() if hasattr(attr_GraphicalLassoCV_n_features_in_, 'tolist') else attr_GraphicalLassoCV_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GraphicalLassoCV instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GraphicalLassoCV must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GraphicalLassoCV_feature_names_in_ = bridgeGraphicalLassoCV[${this.id}].feature_names_in_`;
      return this._py`attr_GraphicalLassoCV_feature_names_in_.tolist() if hasattr(attr_GraphicalLassoCV_feature_names_in_, 'tolist') else attr_GraphicalLassoCV_feature_names_in_`;
    })();
  }
};

// src/generated/covariance/LedoitWolf.ts
import crypto23 from "node:crypto";
var LedoitWolf = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `LedoitWolf${crypto23.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("LedoitWolf.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.covariance import LedoitWolf
try: bridgeLedoitWolf
except NameError: bridgeLedoitWolf = {}
`;
    await this._py.ex`ctor_LedoitWolf = {'store_precision': ${this.opts["store_precision"] ?? void 0}, 'assume_centered': ${this.opts["assume_centered"] ?? void 0}, 'block_size': ${this.opts["block_size"] ?? void 0}}

ctor_LedoitWolf = {k: v for k, v in ctor_LedoitWolf.items() if v is not None}`;
    await this._py.ex`bridgeLedoitWolf[${this.id}] = LedoitWolf(**ctor_LedoitWolf)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLedoitWolf[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the Mean Squared Error between two covariance estimators.
   */
  async error_norm(opts) {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LedoitWolf must call init() before error_norm()");
    }
    await this._py.ex`pms_LedoitWolf_error_norm = {'comp_cov': np.array(${opts["comp_cov"] ?? void 0}) if ${opts["comp_cov"] !== void 0} else None, 'norm': ${opts["norm"] ?? void 0}, 'scaling': ${opts["scaling"] ?? void 0}, 'squared': ${opts["squared"] ?? void 0}}

pms_LedoitWolf_error_norm = {k: v for k, v in pms_LedoitWolf_error_norm.items() if v is not None}`;
    await this._py.ex`res_LedoitWolf_error_norm = bridgeLedoitWolf[${this.id}].error_norm(**pms_LedoitWolf_error_norm)`;
    return this._py`res_LedoitWolf_error_norm.tolist() if hasattr(res_LedoitWolf_error_norm, 'tolist') else res_LedoitWolf_error_norm`;
  }
  /**
    Fit the Ledoit-Wolf shrunk covariance model to X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LedoitWolf must call init() before fit()");
    }
    await this._py.ex`pms_LedoitWolf_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_LedoitWolf_fit = {k: v for k, v in pms_LedoitWolf_fit.items() if v is not None}`;
    await this._py.ex`res_LedoitWolf_fit = bridgeLedoitWolf[${this.id}].fit(**pms_LedoitWolf_fit)`;
    return this._py`res_LedoitWolf_fit.tolist() if hasattr(res_LedoitWolf_fit, 'tolist') else res_LedoitWolf_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LedoitWolf must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LedoitWolf_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LedoitWolf_get_metadata_routing = {k: v for k, v in pms_LedoitWolf_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LedoitWolf_get_metadata_routing = bridgeLedoitWolf[${this.id}].get_metadata_routing(**pms_LedoitWolf_get_metadata_routing)`;
    return this._py`res_LedoitWolf_get_metadata_routing.tolist() if hasattr(res_LedoitWolf_get_metadata_routing, 'tolist') else res_LedoitWolf_get_metadata_routing`;
  }
  /**
    Getter for the precision matrix.
   */
  async get_precision(opts) {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LedoitWolf must call init() before get_precision()");
    }
    await this._py.ex`pms_LedoitWolf_get_precision = {'precision_': np.array(${opts["precision_"] ?? void 0}) if ${opts["precision_"] !== void 0} else None}

pms_LedoitWolf_get_precision = {k: v for k, v in pms_LedoitWolf_get_precision.items() if v is not None}`;
    await this._py.ex`res_LedoitWolf_get_precision = bridgeLedoitWolf[${this.id}].get_precision(**pms_LedoitWolf_get_precision)`;
    return this._py`res_LedoitWolf_get_precision.tolist() if hasattr(res_LedoitWolf_get_precision, 'tolist') else res_LedoitWolf_get_precision`;
  }
  /**
    Compute the squared Mahalanobis distances of given observations.
   */
  async mahalanobis(opts) {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LedoitWolf must call init() before mahalanobis()");
    }
    await this._py.ex`pms_LedoitWolf_mahalanobis = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LedoitWolf_mahalanobis = {k: v for k, v in pms_LedoitWolf_mahalanobis.items() if v is not None}`;
    await this._py.ex`res_LedoitWolf_mahalanobis = bridgeLedoitWolf[${this.id}].mahalanobis(**pms_LedoitWolf_mahalanobis)`;
    return this._py`res_LedoitWolf_mahalanobis.tolist() if hasattr(res_LedoitWolf_mahalanobis, 'tolist') else res_LedoitWolf_mahalanobis`;
  }
  /**
      Compute the log-likelihood of `X_test` under the estimated Gaussian model.
  
      The Gaussian model is defined by its mean and covariance matrix which are represented respectively by `self.location_` and `self.covariance_`.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LedoitWolf must call init() before score()");
    }
    await this._py.ex`pms_LedoitWolf_score = {'X_test': np.array(${opts["X_test"] ?? void 0}) if ${opts["X_test"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_LedoitWolf_score = {k: v for k, v in pms_LedoitWolf_score.items() if v is not None}`;
    await this._py.ex`res_LedoitWolf_score = bridgeLedoitWolf[${this.id}].score(**pms_LedoitWolf_score)`;
    return this._py`res_LedoitWolf_score.tolist() if hasattr(res_LedoitWolf_score, 'tolist') else res_LedoitWolf_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LedoitWolf must call init() before set_score_request()");
    }
    await this._py.ex`pms_LedoitWolf_set_score_request = {'X_test': ${opts["X_test"] ?? void 0}}

pms_LedoitWolf_set_score_request = {k: v for k, v in pms_LedoitWolf_set_score_request.items() if v is not None}`;
    await this._py.ex`res_LedoitWolf_set_score_request = bridgeLedoitWolf[${this.id}].set_score_request(**pms_LedoitWolf_set_score_request)`;
    return this._py`res_LedoitWolf_set_score_request.tolist() if hasattr(res_LedoitWolf_set_score_request, 'tolist') else res_LedoitWolf_set_score_request`;
  }
  /**
    Estimated covariance matrix.
   */
  get covariance_() {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LedoitWolf must call init() before accessing covariance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LedoitWolf_covariance_ = bridgeLedoitWolf[${this.id}].covariance_`;
      return this._py`attr_LedoitWolf_covariance_.tolist() if hasattr(attr_LedoitWolf_covariance_, 'tolist') else attr_LedoitWolf_covariance_`;
    })();
  }
  /**
    Estimated location, i.e. the estimated mean.
   */
  get location_() {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LedoitWolf must call init() before accessing location_");
    }
    return (async () => {
      await this._py.ex`attr_LedoitWolf_location_ = bridgeLedoitWolf[${this.id}].location_`;
      return this._py`attr_LedoitWolf_location_.tolist() if hasattr(attr_LedoitWolf_location_, 'tolist') else attr_LedoitWolf_location_`;
    })();
  }
  /**
    Estimated pseudo inverse matrix. (stored only if store_precision is `true`)
   */
  get precision_() {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LedoitWolf must call init() before accessing precision_");
    }
    return (async () => {
      await this._py.ex`attr_LedoitWolf_precision_ = bridgeLedoitWolf[${this.id}].precision_`;
      return this._py`attr_LedoitWolf_precision_.tolist() if hasattr(attr_LedoitWolf_precision_, 'tolist') else attr_LedoitWolf_precision_`;
    })();
  }
  /**
    Coefficient in the convex combination used for the computation of the shrunk estimate. Range is \[0, 1\].
   */
  get shrinkage_() {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("LedoitWolf must call init() before accessing shrinkage_");
    }
    return (async () => {
      await this._py.ex`attr_LedoitWolf_shrinkage_ = bridgeLedoitWolf[${this.id}].shrinkage_`;
      return this._py`attr_LedoitWolf_shrinkage_.tolist() if hasattr(attr_LedoitWolf_shrinkage_, 'tolist') else attr_LedoitWolf_shrinkage_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LedoitWolf must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LedoitWolf_n_features_in_ = bridgeLedoitWolf[${this.id}].n_features_in_`;
      return this._py`attr_LedoitWolf_n_features_in_.tolist() if hasattr(attr_LedoitWolf_n_features_in_, 'tolist') else attr_LedoitWolf_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This LedoitWolf instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "LedoitWolf must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LedoitWolf_feature_names_in_ = bridgeLedoitWolf[${this.id}].feature_names_in_`;
      return this._py`attr_LedoitWolf_feature_names_in_.tolist() if hasattr(attr_LedoitWolf_feature_names_in_, 'tolist') else attr_LedoitWolf_feature_names_in_`;
    })();
  }
};

// src/generated/covariance/MinCovDet.ts
import crypto24 from "node:crypto";
var MinCovDet = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `MinCovDet${crypto24.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("MinCovDet.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.covariance import MinCovDet
try: bridgeMinCovDet
except NameError: bridgeMinCovDet = {}
`;
    await this._py.ex`ctor_MinCovDet = {'store_precision': ${this.opts["store_precision"] ?? void 0}, 'assume_centered': ${this.opts["assume_centered"] ?? void 0}, 'support_fraction': ${this.opts["support_fraction"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_MinCovDet = {k: v for k, v in ctor_MinCovDet.items() if v is not None}`;
    await this._py.ex`bridgeMinCovDet[${this.id}] = MinCovDet(**ctor_MinCovDet)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMinCovDet[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Apply a correction to raw Minimum Covariance Determinant estimates.
  
      Correction using the empirical correction factor suggested by Rousseeuw and Van Driessen in [\[RVD\]](https://scikit-learn.org/stable/modules/generated/#r491365aeaa84-rvd).
     */
  async correct_covariance(opts) {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinCovDet must call init() before correct_covariance()");
    }
    await this._py.ex`pms_MinCovDet_correct_covariance = {'data': np.array(${opts["data"] ?? void 0}) if ${opts["data"] !== void 0} else None}

pms_MinCovDet_correct_covariance = {k: v for k, v in pms_MinCovDet_correct_covariance.items() if v is not None}`;
    await this._py.ex`res_MinCovDet_correct_covariance = bridgeMinCovDet[${this.id}].correct_covariance(**pms_MinCovDet_correct_covariance)`;
    return this._py`res_MinCovDet_correct_covariance.tolist() if hasattr(res_MinCovDet_correct_covariance, 'tolist') else res_MinCovDet_correct_covariance`;
  }
  /**
    Compute the Mean Squared Error between two covariance estimators.
   */
  async error_norm(opts) {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinCovDet must call init() before error_norm()");
    }
    await this._py.ex`pms_MinCovDet_error_norm = {'comp_cov': np.array(${opts["comp_cov"] ?? void 0}) if ${opts["comp_cov"] !== void 0} else None, 'norm': ${opts["norm"] ?? void 0}, 'scaling': ${opts["scaling"] ?? void 0}, 'squared': ${opts["squared"] ?? void 0}}

pms_MinCovDet_error_norm = {k: v for k, v in pms_MinCovDet_error_norm.items() if v is not None}`;
    await this._py.ex`res_MinCovDet_error_norm = bridgeMinCovDet[${this.id}].error_norm(**pms_MinCovDet_error_norm)`;
    return this._py`res_MinCovDet_error_norm.tolist() if hasattr(res_MinCovDet_error_norm, 'tolist') else res_MinCovDet_error_norm`;
  }
  /**
    Fit a Minimum Covariance Determinant with the FastMCD algorithm.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinCovDet must call init() before fit()");
    }
    await this._py.ex`pms_MinCovDet_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MinCovDet_fit = {k: v for k, v in pms_MinCovDet_fit.items() if v is not None}`;
    await this._py.ex`res_MinCovDet_fit = bridgeMinCovDet[${this.id}].fit(**pms_MinCovDet_fit)`;
    return this._py`res_MinCovDet_fit.tolist() if hasattr(res_MinCovDet_fit, 'tolist') else res_MinCovDet_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinCovDet must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MinCovDet_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MinCovDet_get_metadata_routing = {k: v for k, v in pms_MinCovDet_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MinCovDet_get_metadata_routing = bridgeMinCovDet[${this.id}].get_metadata_routing(**pms_MinCovDet_get_metadata_routing)`;
    return this._py`res_MinCovDet_get_metadata_routing.tolist() if hasattr(res_MinCovDet_get_metadata_routing, 'tolist') else res_MinCovDet_get_metadata_routing`;
  }
  /**
    Getter for the precision matrix.
   */
  async get_precision(opts) {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinCovDet must call init() before get_precision()");
    }
    await this._py.ex`pms_MinCovDet_get_precision = {'precision_': np.array(${opts["precision_"] ?? void 0}) if ${opts["precision_"] !== void 0} else None}

pms_MinCovDet_get_precision = {k: v for k, v in pms_MinCovDet_get_precision.items() if v is not None}`;
    await this._py.ex`res_MinCovDet_get_precision = bridgeMinCovDet[${this.id}].get_precision(**pms_MinCovDet_get_precision)`;
    return this._py`res_MinCovDet_get_precision.tolist() if hasattr(res_MinCovDet_get_precision, 'tolist') else res_MinCovDet_get_precision`;
  }
  /**
    Compute the squared Mahalanobis distances of given observations.
   */
  async mahalanobis(opts) {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinCovDet must call init() before mahalanobis()");
    }
    await this._py.ex`pms_MinCovDet_mahalanobis = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MinCovDet_mahalanobis = {k: v for k, v in pms_MinCovDet_mahalanobis.items() if v is not None}`;
    await this._py.ex`res_MinCovDet_mahalanobis = bridgeMinCovDet[${this.id}].mahalanobis(**pms_MinCovDet_mahalanobis)`;
    return this._py`res_MinCovDet_mahalanobis.tolist() if hasattr(res_MinCovDet_mahalanobis, 'tolist') else res_MinCovDet_mahalanobis`;
  }
  /**
      Re-weight raw Minimum Covariance Determinant estimates.
  
      Re-weight observations using Rousseeuw’s method (equivalent to deleting outlying observations from the data set before computing location and covariance estimates) described in [\[RVDriessen\]](https://scikit-learn.org/stable/modules/generated/#r9465bad4668c-rvdriessen).
     */
  async reweight_covariance(opts) {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinCovDet must call init() before reweight_covariance()");
    }
    await this._py.ex`pms_MinCovDet_reweight_covariance = {'data': np.array(${opts["data"] ?? void 0}) if ${opts["data"] !== void 0} else None}

pms_MinCovDet_reweight_covariance = {k: v for k, v in pms_MinCovDet_reweight_covariance.items() if v is not None}`;
    await this._py.ex`res_MinCovDet_reweight_covariance = bridgeMinCovDet[${this.id}].reweight_covariance(**pms_MinCovDet_reweight_covariance)`;
    return this._py`res_MinCovDet_reweight_covariance.tolist() if hasattr(res_MinCovDet_reweight_covariance, 'tolist') else res_MinCovDet_reweight_covariance`;
  }
  /**
      Compute the log-likelihood of `X_test` under the estimated Gaussian model.
  
      The Gaussian model is defined by its mean and covariance matrix which are represented respectively by `self.location_` and `self.covariance_`.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinCovDet must call init() before score()");
    }
    await this._py.ex`pms_MinCovDet_score = {'X_test': np.array(${opts["X_test"] ?? void 0}) if ${opts["X_test"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MinCovDet_score = {k: v for k, v in pms_MinCovDet_score.items() if v is not None}`;
    await this._py.ex`res_MinCovDet_score = bridgeMinCovDet[${this.id}].score(**pms_MinCovDet_score)`;
    return this._py`res_MinCovDet_score.tolist() if hasattr(res_MinCovDet_score, 'tolist') else res_MinCovDet_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinCovDet must call init() before set_score_request()");
    }
    await this._py.ex`pms_MinCovDet_set_score_request = {'X_test': ${opts["X_test"] ?? void 0}}

pms_MinCovDet_set_score_request = {k: v for k, v in pms_MinCovDet_set_score_request.items() if v is not None}`;
    await this._py.ex`res_MinCovDet_set_score_request = bridgeMinCovDet[${this.id}].set_score_request(**pms_MinCovDet_set_score_request)`;
    return this._py`res_MinCovDet_set_score_request.tolist() if hasattr(res_MinCovDet_set_score_request, 'tolist') else res_MinCovDet_set_score_request`;
  }
  /**
    The raw robust estimated location before correction and re-weighting.
   */
  get raw_location_() {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinCovDet must call init() before accessing raw_location_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MinCovDet_raw_location_ = bridgeMinCovDet[${this.id}].raw_location_`;
      return this._py`attr_MinCovDet_raw_location_.tolist() if hasattr(attr_MinCovDet_raw_location_, 'tolist') else attr_MinCovDet_raw_location_`;
    })();
  }
  /**
    The raw robust estimated covariance before correction and re-weighting.
   */
  get raw_covariance_() {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinCovDet must call init() before accessing raw_covariance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MinCovDet_raw_covariance_ = bridgeMinCovDet[${this.id}].raw_covariance_`;
      return this._py`attr_MinCovDet_raw_covariance_.tolist() if hasattr(attr_MinCovDet_raw_covariance_, 'tolist') else attr_MinCovDet_raw_covariance_`;
    })();
  }
  /**
    A mask of the observations that have been used to compute the raw robust estimates of location and shape, before correction and re-weighting.
   */
  get raw_support_() {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinCovDet must call init() before accessing raw_support_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MinCovDet_raw_support_ = bridgeMinCovDet[${this.id}].raw_support_`;
      return this._py`attr_MinCovDet_raw_support_.tolist() if hasattr(attr_MinCovDet_raw_support_, 'tolist') else attr_MinCovDet_raw_support_`;
    })();
  }
  /**
    Estimated robust location.
   */
  get location_() {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinCovDet must call init() before accessing location_");
    }
    return (async () => {
      await this._py.ex`attr_MinCovDet_location_ = bridgeMinCovDet[${this.id}].location_`;
      return this._py`attr_MinCovDet_location_.tolist() if hasattr(attr_MinCovDet_location_, 'tolist') else attr_MinCovDet_location_`;
    })();
  }
  /**
    Estimated robust covariance matrix.
   */
  get covariance_() {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinCovDet must call init() before accessing covariance_");
    }
    return (async () => {
      await this._py.ex`attr_MinCovDet_covariance_ = bridgeMinCovDet[${this.id}].covariance_`;
      return this._py`attr_MinCovDet_covariance_.tolist() if hasattr(attr_MinCovDet_covariance_, 'tolist') else attr_MinCovDet_covariance_`;
    })();
  }
  /**
    Estimated pseudo inverse matrix. (stored only if store_precision is `true`)
   */
  get precision_() {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinCovDet must call init() before accessing precision_");
    }
    return (async () => {
      await this._py.ex`attr_MinCovDet_precision_ = bridgeMinCovDet[${this.id}].precision_`;
      return this._py`attr_MinCovDet_precision_.tolist() if hasattr(attr_MinCovDet_precision_, 'tolist') else attr_MinCovDet_precision_`;
    })();
  }
  /**
    A mask of the observations that have been used to compute the robust estimates of location and shape.
   */
  get support_() {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinCovDet must call init() before accessing support_");
    }
    return (async () => {
      await this._py.ex`attr_MinCovDet_support_ = bridgeMinCovDet[${this.id}].support_`;
      return this._py`attr_MinCovDet_support_.tolist() if hasattr(attr_MinCovDet_support_, 'tolist') else attr_MinCovDet_support_`;
    })();
  }
  /**
    Mahalanobis distances of the training set (on which [`fit`](https://scikit-learn.org/stable/modules/generated/#sklearn.covariance.MinCovDet.fit "sklearn.covariance.MinCovDet.fit") is called) observations.
   */
  get dist_() {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MinCovDet must call init() before accessing dist_");
    }
    return (async () => {
      await this._py.ex`attr_MinCovDet_dist_ = bridgeMinCovDet[${this.id}].dist_`;
      return this._py`attr_MinCovDet_dist_.tolist() if hasattr(attr_MinCovDet_dist_, 'tolist') else attr_MinCovDet_dist_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinCovDet must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MinCovDet_n_features_in_ = bridgeMinCovDet[${this.id}].n_features_in_`;
      return this._py`attr_MinCovDet_n_features_in_.tolist() if hasattr(attr_MinCovDet_n_features_in_, 'tolist') else attr_MinCovDet_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This MinCovDet instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MinCovDet must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MinCovDet_feature_names_in_ = bridgeMinCovDet[${this.id}].feature_names_in_`;
      return this._py`attr_MinCovDet_feature_names_in_.tolist() if hasattr(attr_MinCovDet_feature_names_in_, 'tolist') else attr_MinCovDet_feature_names_in_`;
    })();
  }
};

// src/generated/covariance/OAS.ts
import crypto25 from "node:crypto";
var OAS = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `OAS${crypto25.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("OAS.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.covariance import OAS
try: bridgeOAS
except NameError: bridgeOAS = {}
`;
    await this._py.ex`ctor_OAS = {'store_precision': ${this.opts["store_precision"] ?? void 0}, 'assume_centered': ${this.opts["assume_centered"] ?? void 0}}

ctor_OAS = {k: v for k, v in ctor_OAS.items() if v is not None}`;
    await this._py.ex`bridgeOAS[${this.id}] = OAS(**ctor_OAS)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeOAS[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the Mean Squared Error between two covariance estimators.
   */
  async error_norm(opts) {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OAS must call init() before error_norm()");
    }
    await this._py.ex`pms_OAS_error_norm = {'comp_cov': np.array(${opts["comp_cov"] ?? void 0}) if ${opts["comp_cov"] !== void 0} else None, 'norm': ${opts["norm"] ?? void 0}, 'scaling': ${opts["scaling"] ?? void 0}, 'squared': ${opts["squared"] ?? void 0}}

pms_OAS_error_norm = {k: v for k, v in pms_OAS_error_norm.items() if v is not None}`;
    await this._py.ex`res_OAS_error_norm = bridgeOAS[${this.id}].error_norm(**pms_OAS_error_norm)`;
    return this._py`res_OAS_error_norm.tolist() if hasattr(res_OAS_error_norm, 'tolist') else res_OAS_error_norm`;
  }
  /**
    Fit the Oracle Approximating Shrinkage covariance model to X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OAS must call init() before fit()");
    }
    await this._py.ex`pms_OAS_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_OAS_fit = {k: v for k, v in pms_OAS_fit.items() if v is not None}`;
    await this._py.ex`res_OAS_fit = bridgeOAS[${this.id}].fit(**pms_OAS_fit)`;
    return this._py`res_OAS_fit.tolist() if hasattr(res_OAS_fit, 'tolist') else res_OAS_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OAS must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_OAS_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_OAS_get_metadata_routing = {k: v for k, v in pms_OAS_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_OAS_get_metadata_routing = bridgeOAS[${this.id}].get_metadata_routing(**pms_OAS_get_metadata_routing)`;
    return this._py`res_OAS_get_metadata_routing.tolist() if hasattr(res_OAS_get_metadata_routing, 'tolist') else res_OAS_get_metadata_routing`;
  }
  /**
    Getter for the precision matrix.
   */
  async get_precision(opts) {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OAS must call init() before get_precision()");
    }
    await this._py.ex`pms_OAS_get_precision = {'precision_': np.array(${opts["precision_"] ?? void 0}) if ${opts["precision_"] !== void 0} else None}

pms_OAS_get_precision = {k: v for k, v in pms_OAS_get_precision.items() if v is not None}`;
    await this._py.ex`res_OAS_get_precision = bridgeOAS[${this.id}].get_precision(**pms_OAS_get_precision)`;
    return this._py`res_OAS_get_precision.tolist() if hasattr(res_OAS_get_precision, 'tolist') else res_OAS_get_precision`;
  }
  /**
    Compute the squared Mahalanobis distances of given observations.
   */
  async mahalanobis(opts) {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OAS must call init() before mahalanobis()");
    }
    await this._py.ex`pms_OAS_mahalanobis = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_OAS_mahalanobis = {k: v for k, v in pms_OAS_mahalanobis.items() if v is not None}`;
    await this._py.ex`res_OAS_mahalanobis = bridgeOAS[${this.id}].mahalanobis(**pms_OAS_mahalanobis)`;
    return this._py`res_OAS_mahalanobis.tolist() if hasattr(res_OAS_mahalanobis, 'tolist') else res_OAS_mahalanobis`;
  }
  /**
      Compute the log-likelihood of `X_test` under the estimated Gaussian model.
  
      The Gaussian model is defined by its mean and covariance matrix which are represented respectively by `self.location_` and `self.covariance_`.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OAS must call init() before score()");
    }
    await this._py.ex`pms_OAS_score = {'X_test': np.array(${opts["X_test"] ?? void 0}) if ${opts["X_test"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_OAS_score = {k: v for k, v in pms_OAS_score.items() if v is not None}`;
    await this._py.ex`res_OAS_score = bridgeOAS[${this.id}].score(**pms_OAS_score)`;
    return this._py`res_OAS_score.tolist() if hasattr(res_OAS_score, 'tolist') else res_OAS_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OAS must call init() before set_score_request()");
    }
    await this._py.ex`pms_OAS_set_score_request = {'X_test': ${opts["X_test"] ?? void 0}}

pms_OAS_set_score_request = {k: v for k, v in pms_OAS_set_score_request.items() if v is not None}`;
    await this._py.ex`res_OAS_set_score_request = bridgeOAS[${this.id}].set_score_request(**pms_OAS_set_score_request)`;
    return this._py`res_OAS_set_score_request.tolist() if hasattr(res_OAS_set_score_request, 'tolist') else res_OAS_set_score_request`;
  }
  /**
    Estimated covariance matrix.
   */
  get covariance_() {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OAS must call init() before accessing covariance_");
    }
    return (async () => {
      await this._py.ex`attr_OAS_covariance_ = bridgeOAS[${this.id}].covariance_`;
      return this._py`attr_OAS_covariance_.tolist() if hasattr(attr_OAS_covariance_, 'tolist') else attr_OAS_covariance_`;
    })();
  }
  /**
    Estimated location, i.e. the estimated mean.
   */
  get location_() {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OAS must call init() before accessing location_");
    }
    return (async () => {
      await this._py.ex`attr_OAS_location_ = bridgeOAS[${this.id}].location_`;
      return this._py`attr_OAS_location_.tolist() if hasattr(attr_OAS_location_, 'tolist') else attr_OAS_location_`;
    })();
  }
  /**
    Estimated pseudo inverse matrix. (stored only if store_precision is `true`)
   */
  get precision_() {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OAS must call init() before accessing precision_");
    }
    return (async () => {
      await this._py.ex`attr_OAS_precision_ = bridgeOAS[${this.id}].precision_`;
      return this._py`attr_OAS_precision_.tolist() if hasattr(attr_OAS_precision_, 'tolist') else attr_OAS_precision_`;
    })();
  }
  /**
    coefficient in the convex combination used for the computation of the shrunk estimate. Range is \[0, 1\].
   */
  get shrinkage_() {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OAS must call init() before accessing shrinkage_");
    }
    return (async () => {
      await this._py.ex`attr_OAS_shrinkage_ = bridgeOAS[${this.id}].shrinkage_`;
      return this._py`attr_OAS_shrinkage_.tolist() if hasattr(attr_OAS_shrinkage_, 'tolist') else attr_OAS_shrinkage_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OAS must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_OAS_n_features_in_ = bridgeOAS[${this.id}].n_features_in_`;
      return this._py`attr_OAS_n_features_in_.tolist() if hasattr(attr_OAS_n_features_in_, 'tolist') else attr_OAS_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This OAS instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("OAS must call init() before accessing feature_names_in_");
    }
    return (async () => {
      await this._py.ex`attr_OAS_feature_names_in_ = bridgeOAS[${this.id}].feature_names_in_`;
      return this._py`attr_OAS_feature_names_in_.tolist() if hasattr(attr_OAS_feature_names_in_, 'tolist') else attr_OAS_feature_names_in_`;
    })();
  }
};

// src/generated/covariance/ShrunkCovariance.ts
import crypto26 from "node:crypto";
var ShrunkCovariance = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `ShrunkCovariance${crypto26.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This ShrunkCovariance instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("ShrunkCovariance.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.covariance import ShrunkCovariance
try: bridgeShrunkCovariance
except NameError: bridgeShrunkCovariance = {}
`;
    await this._py.ex`ctor_ShrunkCovariance = {'store_precision': ${this.opts["store_precision"] ?? void 0}, 'assume_centered': ${this.opts["assume_centered"] ?? void 0}, 'shrinkage': ${this.opts["shrinkage"] ?? void 0}}

ctor_ShrunkCovariance = {k: v for k, v in ctor_ShrunkCovariance.items() if v is not None}`;
    await this._py.ex`bridgeShrunkCovariance[${this.id}] = ShrunkCovariance(**ctor_ShrunkCovariance)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeShrunkCovariance[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the Mean Squared Error between two covariance estimators.
   */
  async error_norm(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ShrunkCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ShrunkCovariance must call init() before error_norm()");
    }
    await this._py.ex`pms_ShrunkCovariance_error_norm = {'comp_cov': np.array(${opts["comp_cov"] ?? void 0}) if ${opts["comp_cov"] !== void 0} else None, 'norm': ${opts["norm"] ?? void 0}, 'scaling': ${opts["scaling"] ?? void 0}, 'squared': ${opts["squared"] ?? void 0}}

pms_ShrunkCovariance_error_norm = {k: v for k, v in pms_ShrunkCovariance_error_norm.items() if v is not None}`;
    await this._py.ex`res_ShrunkCovariance_error_norm = bridgeShrunkCovariance[${this.id}].error_norm(**pms_ShrunkCovariance_error_norm)`;
    return this._py`res_ShrunkCovariance_error_norm.tolist() if hasattr(res_ShrunkCovariance_error_norm, 'tolist') else res_ShrunkCovariance_error_norm`;
  }
  /**
    Fit the shrunk covariance model to X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ShrunkCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ShrunkCovariance must call init() before fit()");
    }
    await this._py.ex`pms_ShrunkCovariance_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_ShrunkCovariance_fit = {k: v for k, v in pms_ShrunkCovariance_fit.items() if v is not None}`;
    await this._py.ex`res_ShrunkCovariance_fit = bridgeShrunkCovariance[${this.id}].fit(**pms_ShrunkCovariance_fit)`;
    return this._py`res_ShrunkCovariance_fit.tolist() if hasattr(res_ShrunkCovariance_fit, 'tolist') else res_ShrunkCovariance_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ShrunkCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ShrunkCovariance must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_ShrunkCovariance_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_ShrunkCovariance_get_metadata_routing = {k: v for k, v in pms_ShrunkCovariance_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_ShrunkCovariance_get_metadata_routing = bridgeShrunkCovariance[${this.id}].get_metadata_routing(**pms_ShrunkCovariance_get_metadata_routing)`;
    return this._py`res_ShrunkCovariance_get_metadata_routing.tolist() if hasattr(res_ShrunkCovariance_get_metadata_routing, 'tolist') else res_ShrunkCovariance_get_metadata_routing`;
  }
  /**
    Getter for the precision matrix.
   */
  async get_precision(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ShrunkCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ShrunkCovariance must call init() before get_precision()"
      );
    }
    await this._py.ex`pms_ShrunkCovariance_get_precision = {'precision_': np.array(${opts["precision_"] ?? void 0}) if ${opts["precision_"] !== void 0} else None}

pms_ShrunkCovariance_get_precision = {k: v for k, v in pms_ShrunkCovariance_get_precision.items() if v is not None}`;
    await this._py.ex`res_ShrunkCovariance_get_precision = bridgeShrunkCovariance[${this.id}].get_precision(**pms_ShrunkCovariance_get_precision)`;
    return this._py`res_ShrunkCovariance_get_precision.tolist() if hasattr(res_ShrunkCovariance_get_precision, 'tolist') else res_ShrunkCovariance_get_precision`;
  }
  /**
    Compute the squared Mahalanobis distances of given observations.
   */
  async mahalanobis(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ShrunkCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ShrunkCovariance must call init() before mahalanobis()");
    }
    await this._py.ex`pms_ShrunkCovariance_mahalanobis = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ShrunkCovariance_mahalanobis = {k: v for k, v in pms_ShrunkCovariance_mahalanobis.items() if v is not None}`;
    await this._py.ex`res_ShrunkCovariance_mahalanobis = bridgeShrunkCovariance[${this.id}].mahalanobis(**pms_ShrunkCovariance_mahalanobis)`;
    return this._py`res_ShrunkCovariance_mahalanobis.tolist() if hasattr(res_ShrunkCovariance_mahalanobis, 'tolist') else res_ShrunkCovariance_mahalanobis`;
  }
  /**
      Compute the log-likelihood of `X_test` under the estimated Gaussian model.
  
      The Gaussian model is defined by its mean and covariance matrix which are represented respectively by `self.location_` and `self.covariance_`.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ShrunkCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ShrunkCovariance must call init() before score()");
    }
    await this._py.ex`pms_ShrunkCovariance_score = {'X_test': np.array(${opts["X_test"] ?? void 0}) if ${opts["X_test"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_ShrunkCovariance_score = {k: v for k, v in pms_ShrunkCovariance_score.items() if v is not None}`;
    await this._py.ex`res_ShrunkCovariance_score = bridgeShrunkCovariance[${this.id}].score(**pms_ShrunkCovariance_score)`;
    return this._py`res_ShrunkCovariance_score.tolist() if hasattr(res_ShrunkCovariance_score, 'tolist') else res_ShrunkCovariance_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ShrunkCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ShrunkCovariance must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_ShrunkCovariance_set_score_request = {'X_test': ${opts["X_test"] ?? void 0}}

pms_ShrunkCovariance_set_score_request = {k: v for k, v in pms_ShrunkCovariance_set_score_request.items() if v is not None}`;
    await this._py.ex`res_ShrunkCovariance_set_score_request = bridgeShrunkCovariance[${this.id}].set_score_request(**pms_ShrunkCovariance_set_score_request)`;
    return this._py`res_ShrunkCovariance_set_score_request.tolist() if hasattr(res_ShrunkCovariance_set_score_request, 'tolist') else res_ShrunkCovariance_set_score_request`;
  }
  /**
    Estimated covariance matrix
   */
  get covariance_() {
    if (this._isDisposed) {
      throw new Error(
        "This ShrunkCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ShrunkCovariance must call init() before accessing covariance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ShrunkCovariance_covariance_ = bridgeShrunkCovariance[${this.id}].covariance_`;
      return this._py`attr_ShrunkCovariance_covariance_.tolist() if hasattr(attr_ShrunkCovariance_covariance_, 'tolist') else attr_ShrunkCovariance_covariance_`;
    })();
  }
  /**
    Estimated location, i.e. the estimated mean.
   */
  get location_() {
    if (this._isDisposed) {
      throw new Error(
        "This ShrunkCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ShrunkCovariance must call init() before accessing location_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ShrunkCovariance_location_ = bridgeShrunkCovariance[${this.id}].location_`;
      return this._py`attr_ShrunkCovariance_location_.tolist() if hasattr(attr_ShrunkCovariance_location_, 'tolist') else attr_ShrunkCovariance_location_`;
    })();
  }
  /**
    Estimated pseudo inverse matrix. (stored only if store_precision is `true`)
   */
  get precision_() {
    if (this._isDisposed) {
      throw new Error(
        "This ShrunkCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ShrunkCovariance must call init() before accessing precision_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ShrunkCovariance_precision_ = bridgeShrunkCovariance[${this.id}].precision_`;
      return this._py`attr_ShrunkCovariance_precision_.tolist() if hasattr(attr_ShrunkCovariance_precision_, 'tolist') else attr_ShrunkCovariance_precision_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This ShrunkCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ShrunkCovariance must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ShrunkCovariance_n_features_in_ = bridgeShrunkCovariance[${this.id}].n_features_in_`;
      return this._py`attr_ShrunkCovariance_n_features_in_.tolist() if hasattr(attr_ShrunkCovariance_n_features_in_, 'tolist') else attr_ShrunkCovariance_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This ShrunkCovariance instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ShrunkCovariance must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ShrunkCovariance_feature_names_in_ = bridgeShrunkCovariance[${this.id}].feature_names_in_`;
      return this._py`attr_ShrunkCovariance_feature_names_in_.tolist() if hasattr(attr_ShrunkCovariance_feature_names_in_, 'tolist') else attr_ShrunkCovariance_feature_names_in_`;
    })();
  }
};

// src/generated/cross_decomposition/CCA.ts
import crypto27 from "node:crypto";
var CCA = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `CCA${crypto27.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("CCA.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cross_decomposition import CCA
try: bridgeCCA
except NameError: bridgeCCA = {}
`;
    await this._py.ex`ctor_CCA = {'n_components': ${this.opts["n_components"] ?? void 0}, 'scale': ${this.opts["scale"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}}

ctor_CCA = {k: v for k, v in ctor_CCA.items() if v is not None}`;
    await this._py.ex`bridgeCCA[${this.id}] = CCA(**ctor_CCA)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeCCA[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit model to data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before fit()");
    }
    await this._py.ex`pms_CCA_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None}

pms_CCA_fit = {k: v for k, v in pms_CCA_fit.items() if v is not None}`;
    await this._py.ex`res_CCA_fit = bridgeCCA[${this.id}].fit(**pms_CCA_fit)`;
    return this._py`res_CCA_fit.tolist() if hasattr(res_CCA_fit, 'tolist') else res_CCA_fit`;
  }
  /**
    Learn and apply the dimension reduction on the train data.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before fit_transform()");
    }
    await this._py.ex`pms_CCA_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_CCA_fit_transform = {k: v for k, v in pms_CCA_fit_transform.items() if v is not None}`;
    await this._py.ex`res_CCA_fit_transform = bridgeCCA[${this.id}].fit_transform(**pms_CCA_fit_transform)`;
    return this._py`res_CCA_fit_transform.tolist() if hasattr(res_CCA_fit_transform, 'tolist') else res_CCA_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class_name0", "class_name1", "class_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before get_feature_names_out()");
    }
    await this._py.ex`pms_CCA_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_CCA_get_feature_names_out = {k: v for k, v in pms_CCA_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_CCA_get_feature_names_out = bridgeCCA[${this.id}].get_feature_names_out(**pms_CCA_get_feature_names_out)`;
    return this._py`res_CCA_get_feature_names_out.tolist() if hasattr(res_CCA_get_feature_names_out, 'tolist') else res_CCA_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_CCA_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_CCA_get_metadata_routing = {k: v for k, v in pms_CCA_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_CCA_get_metadata_routing = bridgeCCA[${this.id}].get_metadata_routing(**pms_CCA_get_metadata_routing)`;
    return this._py`res_CCA_get_metadata_routing.tolist() if hasattr(res_CCA_get_metadata_routing, 'tolist') else res_CCA_get_metadata_routing`;
  }
  /**
    Transform data back to its original space.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before inverse_transform()");
    }
    await this._py.ex`pms_CCA_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None}

pms_CCA_inverse_transform = {k: v for k, v in pms_CCA_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_CCA_inverse_transform = bridgeCCA[${this.id}].inverse_transform(**pms_CCA_inverse_transform)`;
    return this._py`res_CCA_inverse_transform.tolist() if hasattr(res_CCA_inverse_transform, 'tolist') else res_CCA_inverse_transform`;
  }
  /**
    Predict targets of given samples.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before predict()");
    }
    await this._py.ex`pms_CCA_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_CCA_predict = {k: v for k, v in pms_CCA_predict.items() if v is not None}`;
    await this._py.ex`res_CCA_predict = bridgeCCA[${this.id}].predict(**pms_CCA_predict)`;
    return this._py`res_CCA_predict.tolist() if hasattr(res_CCA_predict, 'tolist') else res_CCA_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y_true \- y_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y_true \- y_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before score()");
    }
    await this._py.ex`pms_CCA_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_CCA_score = {k: v for k, v in pms_CCA_score.items() if v is not None}`;
    await this._py.ex`res_CCA_score = bridgeCCA[${this.id}].score(**pms_CCA_score)`;
    return this._py`res_CCA_score.tolist() if hasattr(res_CCA_score, 'tolist') else res_CCA_score`;
  }
  /**
      Set output container.
  
      See [Introducing the set_output API](https://scikit-learn.org/stable/modules/generated/../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before set_output()");
    }
    await this._py.ex`pms_CCA_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_CCA_set_output = {k: v for k, v in pms_CCA_set_output.items() if v is not None}`;
    await this._py.ex`res_CCA_set_output = bridgeCCA[${this.id}].set_output(**pms_CCA_set_output)`;
    return this._py`res_CCA_set_output.tolist() if hasattr(res_CCA_set_output, 'tolist') else res_CCA_set_output`;
  }
  /**
      Request metadata passed to the `predict` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_predict_request(opts) {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before set_predict_request()");
    }
    await this._py.ex`pms_CCA_set_predict_request = {'copy': ${opts["copy"] ?? void 0}}

pms_CCA_set_predict_request = {k: v for k, v in pms_CCA_set_predict_request.items() if v is not None}`;
    await this._py.ex`res_CCA_set_predict_request = bridgeCCA[${this.id}].set_predict_request(**pms_CCA_set_predict_request)`;
    return this._py`res_CCA_set_predict_request.tolist() if hasattr(res_CCA_set_predict_request, 'tolist') else res_CCA_set_predict_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before set_score_request()");
    }
    await this._py.ex`pms_CCA_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_CCA_set_score_request = {k: v for k, v in pms_CCA_set_score_request.items() if v is not None}`;
    await this._py.ex`res_CCA_set_score_request = bridgeCCA[${this.id}].set_score_request(**pms_CCA_set_score_request)`;
    return this._py`res_CCA_set_score_request.tolist() if hasattr(res_CCA_set_score_request, 'tolist') else res_CCA_set_score_request`;
  }
  /**
      Request metadata passed to the `transform` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before set_transform_request()");
    }
    await this._py.ex`pms_CCA_set_transform_request = {'copy': ${opts["copy"] ?? void 0}}

pms_CCA_set_transform_request = {k: v for k, v in pms_CCA_set_transform_request.items() if v is not None}`;
    await this._py.ex`res_CCA_set_transform_request = bridgeCCA[${this.id}].set_transform_request(**pms_CCA_set_transform_request)`;
    return this._py`res_CCA_set_transform_request.tolist() if hasattr(res_CCA_set_transform_request, 'tolist') else res_CCA_set_transform_request`;
  }
  /**
    Apply the dimension reduction.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before transform()");
    }
    await this._py.ex`pms_CCA_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_CCA_transform = {k: v for k, v in pms_CCA_transform.items() if v is not None}`;
    await this._py.ex`res_CCA_transform = bridgeCCA[${this.id}].transform(**pms_CCA_transform)`;
    return this._py`res_CCA_transform.tolist() if hasattr(res_CCA_transform, 'tolist') else res_CCA_transform`;
  }
  /**
    The left singular vectors of the cross-covariance matrices of each iteration.
   */
  get x_weights_() {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before accessing x_weights_");
    }
    return (async () => {
      await this._py.ex`attr_CCA_x_weights_ = bridgeCCA[${this.id}].x_weights_`;
      return this._py`attr_CCA_x_weights_.tolist() if hasattr(attr_CCA_x_weights_, 'tolist') else attr_CCA_x_weights_`;
    })();
  }
  /**
    The right singular vectors of the cross-covariance matrices of each iteration.
   */
  get y_weights_() {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before accessing y_weights_");
    }
    return (async () => {
      await this._py.ex`attr_CCA_y_weights_ = bridgeCCA[${this.id}].y_weights_`;
      return this._py`attr_CCA_y_weights_.tolist() if hasattr(attr_CCA_y_weights_, 'tolist') else attr_CCA_y_weights_`;
    })();
  }
  /**
    The loadings of `X`.
   */
  get x_loadings_() {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before accessing x_loadings_");
    }
    return (async () => {
      await this._py.ex`attr_CCA_x_loadings_ = bridgeCCA[${this.id}].x_loadings_`;
      return this._py`attr_CCA_x_loadings_.tolist() if hasattr(attr_CCA_x_loadings_, 'tolist') else attr_CCA_x_loadings_`;
    })();
  }
  /**
    The loadings of `Y`.
   */
  get y_loadings_() {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before accessing y_loadings_");
    }
    return (async () => {
      await this._py.ex`attr_CCA_y_loadings_ = bridgeCCA[${this.id}].y_loadings_`;
      return this._py`attr_CCA_y_loadings_.tolist() if hasattr(attr_CCA_y_loadings_, 'tolist') else attr_CCA_y_loadings_`;
    })();
  }
  /**
    The projection matrix used to transform `X`.
   */
  get x_rotations_() {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before accessing x_rotations_");
    }
    return (async () => {
      await this._py.ex`attr_CCA_x_rotations_ = bridgeCCA[${this.id}].x_rotations_`;
      return this._py`attr_CCA_x_rotations_.tolist() if hasattr(attr_CCA_x_rotations_, 'tolist') else attr_CCA_x_rotations_`;
    })();
  }
  /**
    The projection matrix used to transform `Y`.
   */
  get y_rotations_() {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before accessing y_rotations_");
    }
    return (async () => {
      await this._py.ex`attr_CCA_y_rotations_ = bridgeCCA[${this.id}].y_rotations_`;
      return this._py`attr_CCA_y_rotations_.tolist() if hasattr(attr_CCA_y_rotations_, 'tolist') else attr_CCA_y_rotations_`;
    })();
  }
  /**
    The coefficients of the linear model such that `Y` is approximated as `Y \= X @ coef_.T + intercept_`.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_CCA_coef_ = bridgeCCA[${this.id}].coef_`;
      return this._py`attr_CCA_coef_.tolist() if hasattr(attr_CCA_coef_, 'tolist') else attr_CCA_coef_`;
    })();
  }
  /**
    The intercepts of the linear model such that `Y` is approximated as `Y \= X @ coef_.T + intercept_`.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before accessing intercept_");
    }
    return (async () => {
      await this._py.ex`attr_CCA_intercept_ = bridgeCCA[${this.id}].intercept_`;
      return this._py`attr_CCA_intercept_.tolist() if hasattr(attr_CCA_intercept_, 'tolist') else attr_CCA_intercept_`;
    })();
  }
  /**
    Number of iterations of the power method, for each component.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_CCA_n_iter_ = bridgeCCA[${this.id}].n_iter_`;
      return this._py`attr_CCA_n_iter_.tolist() if hasattr(attr_CCA_n_iter_, 'tolist') else attr_CCA_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_CCA_n_features_in_ = bridgeCCA[${this.id}].n_features_in_`;
      return this._py`attr_CCA_n_features_in_.tolist() if hasattr(attr_CCA_n_features_in_, 'tolist') else attr_CCA_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This CCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("CCA must call init() before accessing feature_names_in_");
    }
    return (async () => {
      await this._py.ex`attr_CCA_feature_names_in_ = bridgeCCA[${this.id}].feature_names_in_`;
      return this._py`attr_CCA_feature_names_in_.tolist() if hasattr(attr_CCA_feature_names_in_, 'tolist') else attr_CCA_feature_names_in_`;
    })();
  }
};

// src/generated/cross_decomposition/PLSCanonical.ts
import crypto28 from "node:crypto";
var PLSCanonical = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `PLSCanonical${crypto28.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("PLSCanonical.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cross_decomposition import PLSCanonical
try: bridgePLSCanonical
except NameError: bridgePLSCanonical = {}
`;
    await this._py.ex`ctor_PLSCanonical = {'n_components': ${this.opts["n_components"] ?? void 0}, 'scale': ${this.opts["scale"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}}

ctor_PLSCanonical = {k: v for k, v in ctor_PLSCanonical.items() if v is not None}`;
    await this._py.ex`bridgePLSCanonical[${this.id}] = PLSCanonical(**ctor_PLSCanonical)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePLSCanonical[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit model to data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSCanonical must call init() before fit()");
    }
    await this._py.ex`pms_PLSCanonical_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None}

pms_PLSCanonical_fit = {k: v for k, v in pms_PLSCanonical_fit.items() if v is not None}`;
    await this._py.ex`res_PLSCanonical_fit = bridgePLSCanonical[${this.id}].fit(**pms_PLSCanonical_fit)`;
    return this._py`res_PLSCanonical_fit.tolist() if hasattr(res_PLSCanonical_fit, 'tolist') else res_PLSCanonical_fit`;
  }
  /**
    Learn and apply the dimension reduction on the train data.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSCanonical must call init() before fit_transform()");
    }
    await this._py.ex`pms_PLSCanonical_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_PLSCanonical_fit_transform = {k: v for k, v in pms_PLSCanonical_fit_transform.items() if v is not None}`;
    await this._py.ex`res_PLSCanonical_fit_transform = bridgePLSCanonical[${this.id}].fit_transform(**pms_PLSCanonical_fit_transform)`;
    return this._py`res_PLSCanonical_fit_transform.tolist() if hasattr(res_PLSCanonical_fit_transform, 'tolist') else res_PLSCanonical_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class_name0", "class_name1", "class_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_PLSCanonical_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_PLSCanonical_get_feature_names_out = {k: v for k, v in pms_PLSCanonical_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_PLSCanonical_get_feature_names_out = bridgePLSCanonical[${this.id}].get_feature_names_out(**pms_PLSCanonical_get_feature_names_out)`;
    return this._py`res_PLSCanonical_get_feature_names_out.tolist() if hasattr(res_PLSCanonical_get_feature_names_out, 'tolist') else res_PLSCanonical_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_PLSCanonical_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_PLSCanonical_get_metadata_routing = {k: v for k, v in pms_PLSCanonical_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_PLSCanonical_get_metadata_routing = bridgePLSCanonical[${this.id}].get_metadata_routing(**pms_PLSCanonical_get_metadata_routing)`;
    return this._py`res_PLSCanonical_get_metadata_routing.tolist() if hasattr(res_PLSCanonical_get_metadata_routing, 'tolist') else res_PLSCanonical_get_metadata_routing`;
  }
  /**
    Transform data back to its original space.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_PLSCanonical_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None}

pms_PLSCanonical_inverse_transform = {k: v for k, v in pms_PLSCanonical_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_PLSCanonical_inverse_transform = bridgePLSCanonical[${this.id}].inverse_transform(**pms_PLSCanonical_inverse_transform)`;
    return this._py`res_PLSCanonical_inverse_transform.tolist() if hasattr(res_PLSCanonical_inverse_transform, 'tolist') else res_PLSCanonical_inverse_transform`;
  }
  /**
    Predict targets of given samples.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSCanonical must call init() before predict()");
    }
    await this._py.ex`pms_PLSCanonical_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_PLSCanonical_predict = {k: v for k, v in pms_PLSCanonical_predict.items() if v is not None}`;
    await this._py.ex`res_PLSCanonical_predict = bridgePLSCanonical[${this.id}].predict(**pms_PLSCanonical_predict)`;
    return this._py`res_PLSCanonical_predict.tolist() if hasattr(res_PLSCanonical_predict, 'tolist') else res_PLSCanonical_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y_true \- y_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y_true \- y_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSCanonical must call init() before score()");
    }
    await this._py.ex`pms_PLSCanonical_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_PLSCanonical_score = {k: v for k, v in pms_PLSCanonical_score.items() if v is not None}`;
    await this._py.ex`res_PLSCanonical_score = bridgePLSCanonical[${this.id}].score(**pms_PLSCanonical_score)`;
    return this._py`res_PLSCanonical_score.tolist() if hasattr(res_PLSCanonical_score, 'tolist') else res_PLSCanonical_score`;
  }
  /**
      Set output container.
  
      See [Introducing the set_output API](https://scikit-learn.org/stable/modules/generated/../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSCanonical must call init() before set_output()");
    }
    await this._py.ex`pms_PLSCanonical_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_PLSCanonical_set_output = {k: v for k, v in pms_PLSCanonical_set_output.items() if v is not None}`;
    await this._py.ex`res_PLSCanonical_set_output = bridgePLSCanonical[${this.id}].set_output(**pms_PLSCanonical_set_output)`;
    return this._py`res_PLSCanonical_set_output.tolist() if hasattr(res_PLSCanonical_set_output, 'tolist') else res_PLSCanonical_set_output`;
  }
  /**
      Request metadata passed to the `predict` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_predict_request(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before set_predict_request()"
      );
    }
    await this._py.ex`pms_PLSCanonical_set_predict_request = {'copy': ${opts["copy"] ?? void 0}}

pms_PLSCanonical_set_predict_request = {k: v for k, v in pms_PLSCanonical_set_predict_request.items() if v is not None}`;
    await this._py.ex`res_PLSCanonical_set_predict_request = bridgePLSCanonical[${this.id}].set_predict_request(**pms_PLSCanonical_set_predict_request)`;
    return this._py`res_PLSCanonical_set_predict_request.tolist() if hasattr(res_PLSCanonical_set_predict_request, 'tolist') else res_PLSCanonical_set_predict_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_PLSCanonical_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_PLSCanonical_set_score_request = {k: v for k, v in pms_PLSCanonical_set_score_request.items() if v is not None}`;
    await this._py.ex`res_PLSCanonical_set_score_request = bridgePLSCanonical[${this.id}].set_score_request(**pms_PLSCanonical_set_score_request)`;
    return this._py`res_PLSCanonical_set_score_request.tolist() if hasattr(res_PLSCanonical_set_score_request, 'tolist') else res_PLSCanonical_set_score_request`;
  }
  /**
      Request metadata passed to the `transform` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before set_transform_request()"
      );
    }
    await this._py.ex`pms_PLSCanonical_set_transform_request = {'copy': ${opts["copy"] ?? void 0}}

pms_PLSCanonical_set_transform_request = {k: v for k, v in pms_PLSCanonical_set_transform_request.items() if v is not None}`;
    await this._py.ex`res_PLSCanonical_set_transform_request = bridgePLSCanonical[${this.id}].set_transform_request(**pms_PLSCanonical_set_transform_request)`;
    return this._py`res_PLSCanonical_set_transform_request.tolist() if hasattr(res_PLSCanonical_set_transform_request, 'tolist') else res_PLSCanonical_set_transform_request`;
  }
  /**
    Apply the dimension reduction.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSCanonical must call init() before transform()");
    }
    await this._py.ex`pms_PLSCanonical_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_PLSCanonical_transform = {k: v for k, v in pms_PLSCanonical_transform.items() if v is not None}`;
    await this._py.ex`res_PLSCanonical_transform = bridgePLSCanonical[${this.id}].transform(**pms_PLSCanonical_transform)`;
    return this._py`res_PLSCanonical_transform.tolist() if hasattr(res_PLSCanonical_transform, 'tolist') else res_PLSCanonical_transform`;
  }
  /**
    The left singular vectors of the cross-covariance matrices of each iteration.
   */
  get x_weights_() {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before accessing x_weights_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSCanonical_x_weights_ = bridgePLSCanonical[${this.id}].x_weights_`;
      return this._py`attr_PLSCanonical_x_weights_.tolist() if hasattr(attr_PLSCanonical_x_weights_, 'tolist') else attr_PLSCanonical_x_weights_`;
    })();
  }
  /**
    The right singular vectors of the cross-covariance matrices of each iteration.
   */
  get y_weights_() {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before accessing y_weights_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSCanonical_y_weights_ = bridgePLSCanonical[${this.id}].y_weights_`;
      return this._py`attr_PLSCanonical_y_weights_.tolist() if hasattr(attr_PLSCanonical_y_weights_, 'tolist') else attr_PLSCanonical_y_weights_`;
    })();
  }
  /**
    The loadings of `X`.
   */
  get x_loadings_() {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before accessing x_loadings_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSCanonical_x_loadings_ = bridgePLSCanonical[${this.id}].x_loadings_`;
      return this._py`attr_PLSCanonical_x_loadings_.tolist() if hasattr(attr_PLSCanonical_x_loadings_, 'tolist') else attr_PLSCanonical_x_loadings_`;
    })();
  }
  /**
    The loadings of `Y`.
   */
  get y_loadings_() {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before accessing y_loadings_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSCanonical_y_loadings_ = bridgePLSCanonical[${this.id}].y_loadings_`;
      return this._py`attr_PLSCanonical_y_loadings_.tolist() if hasattr(attr_PLSCanonical_y_loadings_, 'tolist') else attr_PLSCanonical_y_loadings_`;
    })();
  }
  /**
    The projection matrix used to transform `X`.
   */
  get x_rotations_() {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before accessing x_rotations_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSCanonical_x_rotations_ = bridgePLSCanonical[${this.id}].x_rotations_`;
      return this._py`attr_PLSCanonical_x_rotations_.tolist() if hasattr(attr_PLSCanonical_x_rotations_, 'tolist') else attr_PLSCanonical_x_rotations_`;
    })();
  }
  /**
    The projection matrix used to transform `Y`.
   */
  get y_rotations_() {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before accessing y_rotations_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSCanonical_y_rotations_ = bridgePLSCanonical[${this.id}].y_rotations_`;
      return this._py`attr_PLSCanonical_y_rotations_.tolist() if hasattr(attr_PLSCanonical_y_rotations_, 'tolist') else attr_PLSCanonical_y_rotations_`;
    })();
  }
  /**
    The coefficients of the linear model such that `Y` is approximated as `Y \= X @ coef_.T + intercept_`.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSCanonical must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_PLSCanonical_coef_ = bridgePLSCanonical[${this.id}].coef_`;
      return this._py`attr_PLSCanonical_coef_.tolist() if hasattr(attr_PLSCanonical_coef_, 'tolist') else attr_PLSCanonical_coef_`;
    })();
  }
  /**
    The intercepts of the linear model such that `Y` is approximated as `Y \= X @ coef_.T + intercept_`.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSCanonical_intercept_ = bridgePLSCanonical[${this.id}].intercept_`;
      return this._py`attr_PLSCanonical_intercept_.tolist() if hasattr(attr_PLSCanonical_intercept_, 'tolist') else attr_PLSCanonical_intercept_`;
    })();
  }
  /**
    Number of iterations of the power method, for each component. Empty if `algorithm='svd'`.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSCanonical must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_PLSCanonical_n_iter_ = bridgePLSCanonical[${this.id}].n_iter_`;
      return this._py`attr_PLSCanonical_n_iter_.tolist() if hasattr(attr_PLSCanonical_n_iter_, 'tolist') else attr_PLSCanonical_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSCanonical_n_features_in_ = bridgePLSCanonical[${this.id}].n_features_in_`;
      return this._py`attr_PLSCanonical_n_features_in_.tolist() if hasattr(attr_PLSCanonical_n_features_in_, 'tolist') else attr_PLSCanonical_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This PLSCanonical instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSCanonical must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSCanonical_feature_names_in_ = bridgePLSCanonical[${this.id}].feature_names_in_`;
      return this._py`attr_PLSCanonical_feature_names_in_.tolist() if hasattr(attr_PLSCanonical_feature_names_in_, 'tolist') else attr_PLSCanonical_feature_names_in_`;
    })();
  }
};

// src/generated/cross_decomposition/PLSRegression.ts
import crypto29 from "node:crypto";
var PLSRegression = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `PLSRegression${crypto29.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("PLSRegression.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cross_decomposition import PLSRegression
try: bridgePLSRegression
except NameError: bridgePLSRegression = {}
`;
    await this._py.ex`ctor_PLSRegression = {'n_components': ${this.opts["n_components"] ?? void 0}, 'scale': ${this.opts["scale"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}}

ctor_PLSRegression = {k: v for k, v in ctor_PLSRegression.items() if v is not None}`;
    await this._py.ex`bridgePLSRegression[${this.id}] = PLSRegression(**ctor_PLSRegression)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePLSRegression[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit model to data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSRegression must call init() before fit()");
    }
    await this._py.ex`pms_PLSRegression_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None}

pms_PLSRegression_fit = {k: v for k, v in pms_PLSRegression_fit.items() if v is not None}`;
    await this._py.ex`res_PLSRegression_fit = bridgePLSRegression[${this.id}].fit(**pms_PLSRegression_fit)`;
    return this._py`res_PLSRegression_fit.tolist() if hasattr(res_PLSRegression_fit, 'tolist') else res_PLSRegression_fit`;
  }
  /**
    Learn and apply the dimension reduction on the train data.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSRegression must call init() before fit_transform()");
    }
    await this._py.ex`pms_PLSRegression_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_PLSRegression_fit_transform = {k: v for k, v in pms_PLSRegression_fit_transform.items() if v is not None}`;
    await this._py.ex`res_PLSRegression_fit_transform = bridgePLSRegression[${this.id}].fit_transform(**pms_PLSRegression_fit_transform)`;
    return this._py`res_PLSRegression_fit_transform.tolist() if hasattr(res_PLSRegression_fit_transform, 'tolist') else res_PLSRegression_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class_name0", "class_name1", "class_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_PLSRegression_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_PLSRegression_get_feature_names_out = {k: v for k, v in pms_PLSRegression_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_PLSRegression_get_feature_names_out = bridgePLSRegression[${this.id}].get_feature_names_out(**pms_PLSRegression_get_feature_names_out)`;
    return this._py`res_PLSRegression_get_feature_names_out.tolist() if hasattr(res_PLSRegression_get_feature_names_out, 'tolist') else res_PLSRegression_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_PLSRegression_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_PLSRegression_get_metadata_routing = {k: v for k, v in pms_PLSRegression_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_PLSRegression_get_metadata_routing = bridgePLSRegression[${this.id}].get_metadata_routing(**pms_PLSRegression_get_metadata_routing)`;
    return this._py`res_PLSRegression_get_metadata_routing.tolist() if hasattr(res_PLSRegression_get_metadata_routing, 'tolist') else res_PLSRegression_get_metadata_routing`;
  }
  /**
    Transform data back to its original space.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_PLSRegression_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None}

pms_PLSRegression_inverse_transform = {k: v for k, v in pms_PLSRegression_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_PLSRegression_inverse_transform = bridgePLSRegression[${this.id}].inverse_transform(**pms_PLSRegression_inverse_transform)`;
    return this._py`res_PLSRegression_inverse_transform.tolist() if hasattr(res_PLSRegression_inverse_transform, 'tolist') else res_PLSRegression_inverse_transform`;
  }
  /**
    Predict targets of given samples.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSRegression must call init() before predict()");
    }
    await this._py.ex`pms_PLSRegression_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_PLSRegression_predict = {k: v for k, v in pms_PLSRegression_predict.items() if v is not None}`;
    await this._py.ex`res_PLSRegression_predict = bridgePLSRegression[${this.id}].predict(**pms_PLSRegression_predict)`;
    return this._py`res_PLSRegression_predict.tolist() if hasattr(res_PLSRegression_predict, 'tolist') else res_PLSRegression_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y_true \- y_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y_true \- y_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSRegression must call init() before score()");
    }
    await this._py.ex`pms_PLSRegression_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_PLSRegression_score = {k: v for k, v in pms_PLSRegression_score.items() if v is not None}`;
    await this._py.ex`res_PLSRegression_score = bridgePLSRegression[${this.id}].score(**pms_PLSRegression_score)`;
    return this._py`res_PLSRegression_score.tolist() if hasattr(res_PLSRegression_score, 'tolist') else res_PLSRegression_score`;
  }
  /**
      Set output container.
  
      See [Introducing the set_output API](https://scikit-learn.org/stable/modules/generated/../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSRegression must call init() before set_output()");
    }
    await this._py.ex`pms_PLSRegression_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_PLSRegression_set_output = {k: v for k, v in pms_PLSRegression_set_output.items() if v is not None}`;
    await this._py.ex`res_PLSRegression_set_output = bridgePLSRegression[${this.id}].set_output(**pms_PLSRegression_set_output)`;
    return this._py`res_PLSRegression_set_output.tolist() if hasattr(res_PLSRegression_set_output, 'tolist') else res_PLSRegression_set_output`;
  }
  /**
      Request metadata passed to the `predict` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_predict_request(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before set_predict_request()"
      );
    }
    await this._py.ex`pms_PLSRegression_set_predict_request = {'copy': ${opts["copy"] ?? void 0}}

pms_PLSRegression_set_predict_request = {k: v for k, v in pms_PLSRegression_set_predict_request.items() if v is not None}`;
    await this._py.ex`res_PLSRegression_set_predict_request = bridgePLSRegression[${this.id}].set_predict_request(**pms_PLSRegression_set_predict_request)`;
    return this._py`res_PLSRegression_set_predict_request.tolist() if hasattr(res_PLSRegression_set_predict_request, 'tolist') else res_PLSRegression_set_predict_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_PLSRegression_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_PLSRegression_set_score_request = {k: v for k, v in pms_PLSRegression_set_score_request.items() if v is not None}`;
    await this._py.ex`res_PLSRegression_set_score_request = bridgePLSRegression[${this.id}].set_score_request(**pms_PLSRegression_set_score_request)`;
    return this._py`res_PLSRegression_set_score_request.tolist() if hasattr(res_PLSRegression_set_score_request, 'tolist') else res_PLSRegression_set_score_request`;
  }
  /**
      Request metadata passed to the `transform` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before set_transform_request()"
      );
    }
    await this._py.ex`pms_PLSRegression_set_transform_request = {'copy': ${opts["copy"] ?? void 0}}

pms_PLSRegression_set_transform_request = {k: v for k, v in pms_PLSRegression_set_transform_request.items() if v is not None}`;
    await this._py.ex`res_PLSRegression_set_transform_request = bridgePLSRegression[${this.id}].set_transform_request(**pms_PLSRegression_set_transform_request)`;
    return this._py`res_PLSRegression_set_transform_request.tolist() if hasattr(res_PLSRegression_set_transform_request, 'tolist') else res_PLSRegression_set_transform_request`;
  }
  /**
    Apply the dimension reduction.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSRegression must call init() before transform()");
    }
    await this._py.ex`pms_PLSRegression_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_PLSRegression_transform = {k: v for k, v in pms_PLSRegression_transform.items() if v is not None}`;
    await this._py.ex`res_PLSRegression_transform = bridgePLSRegression[${this.id}].transform(**pms_PLSRegression_transform)`;
    return this._py`res_PLSRegression_transform.tolist() if hasattr(res_PLSRegression_transform, 'tolist') else res_PLSRegression_transform`;
  }
  /**
    The left singular vectors of the cross-covariance matrices of each iteration.
   */
  get x_weights_() {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before accessing x_weights_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSRegression_x_weights_ = bridgePLSRegression[${this.id}].x_weights_`;
      return this._py`attr_PLSRegression_x_weights_.tolist() if hasattr(attr_PLSRegression_x_weights_, 'tolist') else attr_PLSRegression_x_weights_`;
    })();
  }
  /**
    The right singular vectors of the cross-covariance matrices of each iteration.
   */
  get y_weights_() {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before accessing y_weights_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSRegression_y_weights_ = bridgePLSRegression[${this.id}].y_weights_`;
      return this._py`attr_PLSRegression_y_weights_.tolist() if hasattr(attr_PLSRegression_y_weights_, 'tolist') else attr_PLSRegression_y_weights_`;
    })();
  }
  /**
    The loadings of `X`.
   */
  get x_loadings_() {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before accessing x_loadings_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSRegression_x_loadings_ = bridgePLSRegression[${this.id}].x_loadings_`;
      return this._py`attr_PLSRegression_x_loadings_.tolist() if hasattr(attr_PLSRegression_x_loadings_, 'tolist') else attr_PLSRegression_x_loadings_`;
    })();
  }
  /**
    The loadings of `Y`.
   */
  get y_loadings_() {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before accessing y_loadings_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSRegression_y_loadings_ = bridgePLSRegression[${this.id}].y_loadings_`;
      return this._py`attr_PLSRegression_y_loadings_.tolist() if hasattr(attr_PLSRegression_y_loadings_, 'tolist') else attr_PLSRegression_y_loadings_`;
    })();
  }
  /**
    The transformed training samples.
   */
  get x_scores_() {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before accessing x_scores_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSRegression_x_scores_ = bridgePLSRegression[${this.id}].x_scores_`;
      return this._py`attr_PLSRegression_x_scores_.tolist() if hasattr(attr_PLSRegression_x_scores_, 'tolist') else attr_PLSRegression_x_scores_`;
    })();
  }
  /**
    The transformed training targets.
   */
  get y_scores_() {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before accessing y_scores_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSRegression_y_scores_ = bridgePLSRegression[${this.id}].y_scores_`;
      return this._py`attr_PLSRegression_y_scores_.tolist() if hasattr(attr_PLSRegression_y_scores_, 'tolist') else attr_PLSRegression_y_scores_`;
    })();
  }
  /**
    The projection matrix used to transform `X`.
   */
  get x_rotations_() {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before accessing x_rotations_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSRegression_x_rotations_ = bridgePLSRegression[${this.id}].x_rotations_`;
      return this._py`attr_PLSRegression_x_rotations_.tolist() if hasattr(attr_PLSRegression_x_rotations_, 'tolist') else attr_PLSRegression_x_rotations_`;
    })();
  }
  /**
    The projection matrix used to transform `Y`.
   */
  get y_rotations_() {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before accessing y_rotations_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSRegression_y_rotations_ = bridgePLSRegression[${this.id}].y_rotations_`;
      return this._py`attr_PLSRegression_y_rotations_.tolist() if hasattr(attr_PLSRegression_y_rotations_, 'tolist') else attr_PLSRegression_y_rotations_`;
    })();
  }
  /**
    The coefficients of the linear model such that `Y` is approximated as `Y \= X @ coef_.T + intercept_`.
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSRegression must call init() before accessing coef_");
    }
    return (async () => {
      await this._py.ex`attr_PLSRegression_coef_ = bridgePLSRegression[${this.id}].coef_`;
      return this._py`attr_PLSRegression_coef_.tolist() if hasattr(attr_PLSRegression_coef_, 'tolist') else attr_PLSRegression_coef_`;
    })();
  }
  /**
    The intercepts of the linear model such that `Y` is approximated as `Y \= X @ coef_.T + intercept_`.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSRegression_intercept_ = bridgePLSRegression[${this.id}].intercept_`;
      return this._py`attr_PLSRegression_intercept_.tolist() if hasattr(attr_PLSRegression_intercept_, 'tolist') else attr_PLSRegression_intercept_`;
    })();
  }
  /**
    Number of iterations of the power method, for each component.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSRegression must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_PLSRegression_n_iter_ = bridgePLSRegression[${this.id}].n_iter_`;
      return this._py`attr_PLSRegression_n_iter_.tolist() if hasattr(attr_PLSRegression_n_iter_, 'tolist') else attr_PLSRegression_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSRegression_n_features_in_ = bridgePLSRegression[${this.id}].n_features_in_`;
      return this._py`attr_PLSRegression_n_features_in_.tolist() if hasattr(attr_PLSRegression_n_features_in_, 'tolist') else attr_PLSRegression_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This PLSRegression instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSRegression must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSRegression_feature_names_in_ = bridgePLSRegression[${this.id}].feature_names_in_`;
      return this._py`attr_PLSRegression_feature_names_in_.tolist() if hasattr(attr_PLSRegression_feature_names_in_, 'tolist') else attr_PLSRegression_feature_names_in_`;
    })();
  }
};

// src/generated/cross_decomposition/PLSSVD.ts
import crypto30 from "node:crypto";
var PLSSVD = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `PLSSVD${crypto30.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This PLSSVD instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("PLSSVD.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cross_decomposition import PLSSVD
try: bridgePLSSVD
except NameError: bridgePLSSVD = {}
`;
    await this._py.ex`ctor_PLSSVD = {'n_components': ${this.opts["n_components"] ?? void 0}, 'scale': ${this.opts["scale"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}}

ctor_PLSSVD = {k: v for k, v in ctor_PLSSVD.items() if v is not None}`;
    await this._py.ex`bridgePLSSVD[${this.id}] = PLSSVD(**ctor_PLSSVD)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePLSSVD[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit model to data.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSSVD must call init() before fit()");
    }
    await this._py.ex`pms_PLSSVD_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None}

pms_PLSSVD_fit = {k: v for k, v in pms_PLSSVD_fit.items() if v is not None}`;
    await this._py.ex`res_PLSSVD_fit = bridgePLSSVD[${this.id}].fit(**pms_PLSSVD_fit)`;
    return this._py`res_PLSSVD_fit.tolist() if hasattr(res_PLSSVD_fit, 'tolist') else res_PLSSVD_fit`;
  }
  /**
    Learn and apply the dimensionality reduction.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSSVD must call init() before fit_transform()");
    }
    await this._py.ex`pms_PLSSVD_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_PLSSVD_fit_transform = {k: v for k, v in pms_PLSSVD_fit_transform.items() if v is not None}`;
    await this._py.ex`res_PLSSVD_fit_transform = bridgePLSSVD[${this.id}].fit_transform(**pms_PLSSVD_fit_transform)`;
    return this._py`res_PLSSVD_fit_transform.tolist() if hasattr(res_PLSSVD_fit_transform, 'tolist') else res_PLSSVD_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class_name0", "class_name1", "class_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSSVD must call init() before get_feature_names_out()");
    }
    await this._py.ex`pms_PLSSVD_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_PLSSVD_get_feature_names_out = {k: v for k, v in pms_PLSSVD_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_PLSSVD_get_feature_names_out = bridgePLSSVD[${this.id}].get_feature_names_out(**pms_PLSSVD_get_feature_names_out)`;
    return this._py`res_PLSSVD_get_feature_names_out.tolist() if hasattr(res_PLSSVD_get_feature_names_out, 'tolist') else res_PLSSVD_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSSVD must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_PLSSVD_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_PLSSVD_get_metadata_routing = {k: v for k, v in pms_PLSSVD_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_PLSSVD_get_metadata_routing = bridgePLSSVD[${this.id}].get_metadata_routing(**pms_PLSSVD_get_metadata_routing)`;
    return this._py`res_PLSSVD_get_metadata_routing.tolist() if hasattr(res_PLSSVD_get_metadata_routing, 'tolist') else res_PLSSVD_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set_output API](https://scikit-learn.org/stable/modules/generated/../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSSVD must call init() before set_output()");
    }
    await this._py.ex`pms_PLSSVD_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_PLSSVD_set_output = {k: v for k, v in pms_PLSSVD_set_output.items() if v is not None}`;
    await this._py.ex`res_PLSSVD_set_output = bridgePLSSVD[${this.id}].set_output(**pms_PLSSVD_set_output)`;
    return this._py`res_PLSSVD_set_output.tolist() if hasattr(res_PLSSVD_set_output, 'tolist') else res_PLSSVD_set_output`;
  }
  /**
    Apply the dimensionality reduction.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This PLSSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSSVD must call init() before transform()");
    }
    await this._py.ex`pms_PLSSVD_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'Y': np.array(${opts["Y"] ?? void 0}) if ${opts["Y"] !== void 0} else None}

pms_PLSSVD_transform = {k: v for k, v in pms_PLSSVD_transform.items() if v is not None}`;
    await this._py.ex`res_PLSSVD_transform = bridgePLSSVD[${this.id}].transform(**pms_PLSSVD_transform)`;
    return this._py`res_PLSSVD_transform.tolist() if hasattr(res_PLSSVD_transform, 'tolist') else res_PLSSVD_transform`;
  }
  /**
    The left singular vectors of the SVD of the cross-covariance matrix. Used to project `X` in [`transform`](https://scikit-learn.org/stable/modules/generated/#sklearn.cross_decomposition.PLSSVD.transform "sklearn.cross_decomposition.PLSSVD.transform").
   */
  get x_weights_() {
    if (this._isDisposed) {
      throw new Error("This PLSSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSSVD must call init() before accessing x_weights_");
    }
    return (async () => {
      await this._py.ex`attr_PLSSVD_x_weights_ = bridgePLSSVD[${this.id}].x_weights_`;
      return this._py`attr_PLSSVD_x_weights_.tolist() if hasattr(attr_PLSSVD_x_weights_, 'tolist') else attr_PLSSVD_x_weights_`;
    })();
  }
  /**
    The right singular vectors of the SVD of the cross-covariance matrix. Used to project `X` in [`transform`](https://scikit-learn.org/stable/modules/generated/#sklearn.cross_decomposition.PLSSVD.transform "sklearn.cross_decomposition.PLSSVD.transform").
   */
  get y_weights_() {
    if (this._isDisposed) {
      throw new Error("This PLSSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSSVD must call init() before accessing y_weights_");
    }
    return (async () => {
      await this._py.ex`attr_PLSSVD_y_weights_ = bridgePLSSVD[${this.id}].y_weights_`;
      return this._py`attr_PLSSVD_y_weights_.tolist() if hasattr(attr_PLSSVD_y_weights_, 'tolist') else attr_PLSSVD_y_weights_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This PLSSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PLSSVD must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_PLSSVD_n_features_in_ = bridgePLSSVD[${this.id}].n_features_in_`;
      return this._py`attr_PLSSVD_n_features_in_.tolist() if hasattr(attr_PLSSVD_n_features_in_, 'tolist') else attr_PLSSVD_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This PLSSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PLSSVD must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PLSSVD_feature_names_in_ = bridgePLSSVD[${this.id}].feature_names_in_`;
      return this._py`attr_PLSSVD_feature_names_in_.tolist() if hasattr(attr_PLSSVD_feature_names_in_, 'tolist') else attr_PLSSVD_feature_names_in_`;
    })();
  }
};

// src/generated/decomposition/DictionaryLearning.ts
import crypto31 from "node:crypto";
var DictionaryLearning = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `DictionaryLearning${crypto31.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "DictionaryLearning.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import DictionaryLearning
try: bridgeDictionaryLearning
except NameError: bridgeDictionaryLearning = {}
`;
    await this._py.ex`ctor_DictionaryLearning = {'n_components': ${this.opts["n_components"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'fit_algorithm': ${this.opts["fit_algorithm"] ?? void 0}, 'transform_algorithm': ${this.opts["transform_algorithm"] ?? void 0}, 'transform_n_nonzero_coefs': ${this.opts["transform_n_nonzero_coefs"] ?? void 0}, 'transform_alpha': ${this.opts["transform_alpha"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'code_init': np.array(${this.opts["code_init"] ?? void 0}) if ${this.opts["code_init"] !== void 0} else None, 'dict_init': np.array(${this.opts["dict_init"] ?? void 0}) if ${this.opts["dict_init"] !== void 0} else None, 'callback': ${this.opts["callback"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'split_sign': ${this.opts["split_sign"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'positive_code': ${this.opts["positive_code"] ?? void 0}, 'positive_dict': ${this.opts["positive_dict"] ?? void 0}, 'transform_max_iter': ${this.opts["transform_max_iter"] ?? void 0}}

ctor_DictionaryLearning = {k: v for k, v in ctor_DictionaryLearning.items() if v is not None}`;
    await this._py.ex`bridgeDictionaryLearning[${this.id}] = DictionaryLearning(**ctor_DictionaryLearning)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeDictionaryLearning[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model from data in X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("DictionaryLearning must call init() before fit()");
    }
    await this._py.ex`pms_DictionaryLearning_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_DictionaryLearning_fit = {k: v for k, v in pms_DictionaryLearning_fit.items() if v is not None}`;
    await this._py.ex`res_DictionaryLearning_fit = bridgeDictionaryLearning[${this.id}].fit(**pms_DictionaryLearning_fit)`;
    return this._py`res_DictionaryLearning_fit.tolist() if hasattr(res_DictionaryLearning_fit, 'tolist') else res_DictionaryLearning_fit`;
  }
  /**
    Fit the model from data in X and return the transformed data.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictionaryLearning must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_DictionaryLearning_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_DictionaryLearning_fit_transform = {k: v for k, v in pms_DictionaryLearning_fit_transform.items() if v is not None}`;
    await this._py.ex`res_DictionaryLearning_fit_transform = bridgeDictionaryLearning[${this.id}].fit_transform(**pms_DictionaryLearning_fit_transform)`;
    return this._py`res_DictionaryLearning_fit_transform.tolist() if hasattr(res_DictionaryLearning_fit_transform, 'tolist') else res_DictionaryLearning_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class_name0", "class_name1", "class_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictionaryLearning must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_DictionaryLearning_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_DictionaryLearning_get_feature_names_out = {k: v for k, v in pms_DictionaryLearning_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_DictionaryLearning_get_feature_names_out = bridgeDictionaryLearning[${this.id}].get_feature_names_out(**pms_DictionaryLearning_get_feature_names_out)`;
    return this._py`res_DictionaryLearning_get_feature_names_out.tolist() if hasattr(res_DictionaryLearning_get_feature_names_out, 'tolist') else res_DictionaryLearning_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictionaryLearning must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_DictionaryLearning_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_DictionaryLearning_get_metadata_routing = {k: v for k, v in pms_DictionaryLearning_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_DictionaryLearning_get_metadata_routing = bridgeDictionaryLearning[${this.id}].get_metadata_routing(**pms_DictionaryLearning_get_metadata_routing)`;
    return this._py`res_DictionaryLearning_get_metadata_routing.tolist() if hasattr(res_DictionaryLearning_get_metadata_routing, 'tolist') else res_DictionaryLearning_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set_output API](https://scikit-learn.org/stable/modules/generated/../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("DictionaryLearning must call init() before set_output()");
    }
    await this._py.ex`pms_DictionaryLearning_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_DictionaryLearning_set_output = {k: v for k, v in pms_DictionaryLearning_set_output.items() if v is not None}`;
    await this._py.ex`res_DictionaryLearning_set_output = bridgeDictionaryLearning[${this.id}].set_output(**pms_DictionaryLearning_set_output)`;
    return this._py`res_DictionaryLearning_set_output.tolist() if hasattr(res_DictionaryLearning_set_output, 'tolist') else res_DictionaryLearning_set_output`;
  }
  /**
      Encode the data as a sparse combination of the dictionary atoms.
  
      Coding method is determined by the object parameter `transform_algorithm`.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("DictionaryLearning must call init() before transform()");
    }
    await this._py.ex`pms_DictionaryLearning_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_DictionaryLearning_transform = {k: v for k, v in pms_DictionaryLearning_transform.items() if v is not None}`;
    await this._py.ex`res_DictionaryLearning_transform = bridgeDictionaryLearning[${this.id}].transform(**pms_DictionaryLearning_transform)`;
    return this._py`res_DictionaryLearning_transform.tolist() if hasattr(res_DictionaryLearning_transform, 'tolist') else res_DictionaryLearning_transform`;
  }
  /**
    dictionary atoms extracted from the data
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictionaryLearning must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DictionaryLearning_components_ = bridgeDictionaryLearning[${this.id}].components_`;
      return this._py`attr_DictionaryLearning_components_.tolist() if hasattr(attr_DictionaryLearning_components_, 'tolist') else attr_DictionaryLearning_components_`;
    })();
  }
  /**
    vector of errors at each iteration
   */
  get error_() {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictionaryLearning must call init() before accessing error_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DictionaryLearning_error_ = bridgeDictionaryLearning[${this.id}].error_`;
      return this._py`attr_DictionaryLearning_error_.tolist() if hasattr(attr_DictionaryLearning_error_, 'tolist') else attr_DictionaryLearning_error_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictionaryLearning must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DictionaryLearning_n_features_in_ = bridgeDictionaryLearning[${this.id}].n_features_in_`;
      return this._py`attr_DictionaryLearning_n_features_in_.tolist() if hasattr(attr_DictionaryLearning_n_features_in_, 'tolist') else attr_DictionaryLearning_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictionaryLearning must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DictionaryLearning_feature_names_in_ = bridgeDictionaryLearning[${this.id}].feature_names_in_`;
      return this._py`attr_DictionaryLearning_feature_names_in_.tolist() if hasattr(attr_DictionaryLearning_feature_names_in_, 'tolist') else attr_DictionaryLearning_feature_names_in_`;
    })();
  }
  /**
    Number of iterations run.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This DictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "DictionaryLearning must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DictionaryLearning_n_iter_ = bridgeDictionaryLearning[${this.id}].n_iter_`;
      return this._py`attr_DictionaryLearning_n_iter_.tolist() if hasattr(attr_DictionaryLearning_n_iter_, 'tolist') else attr_DictionaryLearning_n_iter_`;
    })();
  }
};

// src/generated/decomposition/FactorAnalysis.ts
import crypto32 from "node:crypto";
var FactorAnalysis = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `FactorAnalysis${crypto32.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("FactorAnalysis.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import FactorAnalysis
try: bridgeFactorAnalysis
except NameError: bridgeFactorAnalysis = {}
`;
    await this._py.ex`ctor_FactorAnalysis = {'n_components': ${this.opts["n_components"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'noise_variance_init': np.array(${this.opts["noise_variance_init"] ?? void 0}) if ${this.opts["noise_variance_init"] !== void 0} else None, 'svd_method': ${this.opts["svd_method"] ?? void 0}, 'iterated_power': ${this.opts["iterated_power"] ?? void 0}, 'rotation': ${this.opts["rotation"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_FactorAnalysis = {k: v for k, v in ctor_FactorAnalysis.items() if v is not None}`;
    await this._py.ex`bridgeFactorAnalysis[${this.id}] = FactorAnalysis(**ctor_FactorAnalysis)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeFactorAnalysis[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the FactorAnalysis model to X using SVD based approach.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FactorAnalysis must call init() before fit()");
    }
    await this._py.ex`pms_FactorAnalysis_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_FactorAnalysis_fit = {k: v for k, v in pms_FactorAnalysis_fit.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_fit = bridgeFactorAnalysis[${this.id}].fit(**pms_FactorAnalysis_fit)`;
    return this._py`res_FactorAnalysis_fit.tolist() if hasattr(res_FactorAnalysis_fit, 'tolist') else res_FactorAnalysis_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FactorAnalysis must call init() before fit_transform()");
    }
    await this._py.ex`pms_FactorAnalysis_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_FactorAnalysis_fit_transform = {k: v for k, v in pms_FactorAnalysis_fit_transform.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_fit_transform = bridgeFactorAnalysis[${this.id}].fit_transform(**pms_FactorAnalysis_fit_transform)`;
    return this._py`res_FactorAnalysis_fit_transform.tolist() if hasattr(res_FactorAnalysis_fit_transform, 'tolist') else res_FactorAnalysis_fit_transform`;
  }
  /**
      Compute data covariance with the FactorAnalysis model.
  
      `cov \= components_.T \* components_ + diag(noise_variance)`
     */
  async get_covariance(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FactorAnalysis must call init() before get_covariance()");
    }
    await this._py.ex`pms_FactorAnalysis_get_covariance = {'cov': np.array(${opts["cov"] ?? void 0}) if ${opts["cov"] !== void 0} else None}

pms_FactorAnalysis_get_covariance = {k: v for k, v in pms_FactorAnalysis_get_covariance.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_get_covariance = bridgeFactorAnalysis[${this.id}].get_covariance(**pms_FactorAnalysis_get_covariance)`;
    return this._py`res_FactorAnalysis_get_covariance.tolist() if hasattr(res_FactorAnalysis_get_covariance, 'tolist') else res_FactorAnalysis_get_covariance`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class_name0", "class_name1", "class_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FactorAnalysis must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_FactorAnalysis_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_FactorAnalysis_get_feature_names_out = {k: v for k, v in pms_FactorAnalysis_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_get_feature_names_out = bridgeFactorAnalysis[${this.id}].get_feature_names_out(**pms_FactorAnalysis_get_feature_names_out)`;
    return this._py`res_FactorAnalysis_get_feature_names_out.tolist() if hasattr(res_FactorAnalysis_get_feature_names_out, 'tolist') else res_FactorAnalysis_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FactorAnalysis must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_FactorAnalysis_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_FactorAnalysis_get_metadata_routing = {k: v for k, v in pms_FactorAnalysis_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_get_metadata_routing = bridgeFactorAnalysis[${this.id}].get_metadata_routing(**pms_FactorAnalysis_get_metadata_routing)`;
    return this._py`res_FactorAnalysis_get_metadata_routing.tolist() if hasattr(res_FactorAnalysis_get_metadata_routing, 'tolist') else res_FactorAnalysis_get_metadata_routing`;
  }
  /**
    Compute data precision matrix with the FactorAnalysis model.
   */
  async get_precision(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FactorAnalysis must call init() before get_precision()");
    }
    await this._py.ex`pms_FactorAnalysis_get_precision = {'precision': np.array(${opts["precision"] ?? void 0}) if ${opts["precision"] !== void 0} else None}

pms_FactorAnalysis_get_precision = {k: v for k, v in pms_FactorAnalysis_get_precision.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_get_precision = bridgeFactorAnalysis[${this.id}].get_precision(**pms_FactorAnalysis_get_precision)`;
    return this._py`res_FactorAnalysis_get_precision.tolist() if hasattr(res_FactorAnalysis_get_precision, 'tolist') else res_FactorAnalysis_get_precision`;
  }
  /**
    Compute the average log-likelihood of the samples.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FactorAnalysis must call init() before score()");
    }
    await this._py.ex`pms_FactorAnalysis_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_FactorAnalysis_score = {k: v for k, v in pms_FactorAnalysis_score.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_score = bridgeFactorAnalysis[${this.id}].score(**pms_FactorAnalysis_score)`;
    return this._py`res_FactorAnalysis_score.tolist() if hasattr(res_FactorAnalysis_score, 'tolist') else res_FactorAnalysis_score`;
  }
  /**
    Compute the log-likelihood of each sample.
   */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FactorAnalysis must call init() before score_samples()");
    }
    await this._py.ex`pms_FactorAnalysis_score_samples = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_FactorAnalysis_score_samples = {k: v for k, v in pms_FactorAnalysis_score_samples.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_score_samples = bridgeFactorAnalysis[${this.id}].score_samples(**pms_FactorAnalysis_score_samples)`;
    return this._py`res_FactorAnalysis_score_samples.tolist() if hasattr(res_FactorAnalysis_score_samples, 'tolist') else res_FactorAnalysis_score_samples`;
  }
  /**
      Set output container.
  
      See [Introducing the set_output API](https://scikit-learn.org/stable/modules/generated/../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FactorAnalysis must call init() before set_output()");
    }
    await this._py.ex`pms_FactorAnalysis_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_FactorAnalysis_set_output = {k: v for k, v in pms_FactorAnalysis_set_output.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_set_output = bridgeFactorAnalysis[${this.id}].set_output(**pms_FactorAnalysis_set_output)`;
    return this._py`res_FactorAnalysis_set_output.tolist() if hasattr(res_FactorAnalysis_set_output, 'tolist') else res_FactorAnalysis_set_output`;
  }
  /**
      Apply dimensionality reduction to X using the model.
  
      Compute the expected mean of the latent variables. See Barber, 21.2.33 (or Bishop, 12.66).
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FactorAnalysis must call init() before transform()");
    }
    await this._py.ex`pms_FactorAnalysis_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_FactorAnalysis_transform = {k: v for k, v in pms_FactorAnalysis_transform.items() if v is not None}`;
    await this._py.ex`res_FactorAnalysis_transform = bridgeFactorAnalysis[${this.id}].transform(**pms_FactorAnalysis_transform)`;
    return this._py`res_FactorAnalysis_transform.tolist() if hasattr(res_FactorAnalysis_transform, 'tolist') else res_FactorAnalysis_transform`;
  }
  /**
    Components with maximum variance.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FactorAnalysis must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FactorAnalysis_components_ = bridgeFactorAnalysis[${this.id}].components_`;
      return this._py`attr_FactorAnalysis_components_.tolist() if hasattr(attr_FactorAnalysis_components_, 'tolist') else attr_FactorAnalysis_components_`;
    })();
  }
  /**
    The log likelihood at each iteration.
   */
  get loglike_() {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FactorAnalysis must call init() before accessing loglike_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FactorAnalysis_loglike_ = bridgeFactorAnalysis[${this.id}].loglike_`;
      return this._py`attr_FactorAnalysis_loglike_.tolist() if hasattr(attr_FactorAnalysis_loglike_, 'tolist') else attr_FactorAnalysis_loglike_`;
    })();
  }
  /**
    The estimated noise variance for each feature.
   */
  get noise_variance_() {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FactorAnalysis must call init() before accessing noise_variance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FactorAnalysis_noise_variance_ = bridgeFactorAnalysis[${this.id}].noise_variance_`;
      return this._py`attr_FactorAnalysis_noise_variance_.tolist() if hasattr(attr_FactorAnalysis_noise_variance_, 'tolist') else attr_FactorAnalysis_noise_variance_`;
    })();
  }
  /**
    Number of iterations run.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FactorAnalysis must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FactorAnalysis_n_iter_ = bridgeFactorAnalysis[${this.id}].n_iter_`;
      return this._py`attr_FactorAnalysis_n_iter_.tolist() if hasattr(attr_FactorAnalysis_n_iter_, 'tolist') else attr_FactorAnalysis_n_iter_`;
    })();
  }
  /**
    Per-feature empirical mean, estimated from the training set.
   */
  get mean_() {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FactorAnalysis must call init() before accessing mean_");
    }
    return (async () => {
      await this._py.ex`attr_FactorAnalysis_mean_ = bridgeFactorAnalysis[${this.id}].mean_`;
      return this._py`attr_FactorAnalysis_mean_.tolist() if hasattr(attr_FactorAnalysis_mean_, 'tolist') else attr_FactorAnalysis_mean_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FactorAnalysis must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FactorAnalysis_n_features_in_ = bridgeFactorAnalysis[${this.id}].n_features_in_`;
      return this._py`attr_FactorAnalysis_n_features_in_.tolist() if hasattr(attr_FactorAnalysis_n_features_in_, 'tolist') else attr_FactorAnalysis_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This FactorAnalysis instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FactorAnalysis must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FactorAnalysis_feature_names_in_ = bridgeFactorAnalysis[${this.id}].feature_names_in_`;
      return this._py`attr_FactorAnalysis_feature_names_in_.tolist() if hasattr(attr_FactorAnalysis_feature_names_in_, 'tolist') else attr_FactorAnalysis_feature_names_in_`;
    })();
  }
};

// src/generated/decomposition/FastICA.ts
import crypto33 from "node:crypto";
var FastICA = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `FastICA${crypto33.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("FastICA.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import FastICA
try: bridgeFastICA
except NameError: bridgeFastICA = {}
`;
    await this._py.ex`ctor_FastICA = {'n_components': ${this.opts["n_components"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'whiten': ${this.opts["whiten"] ?? void 0}, 'fun': ${this.opts["fun"] ?? void 0}, 'fun_args': ${this.opts["fun_args"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'w_init': np.array(${this.opts["w_init"] ?? void 0}) if ${this.opts["w_init"] !== void 0} else None, 'whiten_solver': ${this.opts["whiten_solver"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_FastICA = {k: v for k, v in ctor_FastICA.items() if v is not None}`;
    await this._py.ex`bridgeFastICA[${this.id}] = FastICA(**ctor_FastICA)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeFastICA[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model to X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before fit()");
    }
    await this._py.ex`pms_FastICA_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_FastICA_fit = {k: v for k, v in pms_FastICA_fit.items() if v is not None}`;
    await this._py.ex`res_FastICA_fit = bridgeFastICA[${this.id}].fit(**pms_FastICA_fit)`;
    return this._py`res_FastICA_fit.tolist() if hasattr(res_FastICA_fit, 'tolist') else res_FastICA_fit`;
  }
  /**
    Fit the model and recover the sources from X.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before fit_transform()");
    }
    await this._py.ex`pms_FastICA_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_FastICA_fit_transform = {k: v for k, v in pms_FastICA_fit_transform.items() if v is not None}`;
    await this._py.ex`res_FastICA_fit_transform = bridgeFastICA[${this.id}].fit_transform(**pms_FastICA_fit_transform)`;
    return this._py`res_FastICA_fit_transform.tolist() if hasattr(res_FastICA_fit_transform, 'tolist') else res_FastICA_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class_name0", "class_name1", "class_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before get_feature_names_out()");
    }
    await this._py.ex`pms_FastICA_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_FastICA_get_feature_names_out = {k: v for k, v in pms_FastICA_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_FastICA_get_feature_names_out = bridgeFastICA[${this.id}].get_feature_names_out(**pms_FastICA_get_feature_names_out)`;
    return this._py`res_FastICA_get_feature_names_out.tolist() if hasattr(res_FastICA_get_feature_names_out, 'tolist') else res_FastICA_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_FastICA_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_FastICA_get_metadata_routing = {k: v for k, v in pms_FastICA_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_FastICA_get_metadata_routing = bridgeFastICA[${this.id}].get_metadata_routing(**pms_FastICA_get_metadata_routing)`;
    return this._py`res_FastICA_get_metadata_routing.tolist() if hasattr(res_FastICA_get_metadata_routing, 'tolist') else res_FastICA_get_metadata_routing`;
  }
  /**
    Transform the sources back to the mixed data (apply mixing matrix).
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before inverse_transform()");
    }
    await this._py.ex`pms_FastICA_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_FastICA_inverse_transform = {k: v for k, v in pms_FastICA_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_FastICA_inverse_transform = bridgeFastICA[${this.id}].inverse_transform(**pms_FastICA_inverse_transform)`;
    return this._py`res_FastICA_inverse_transform.tolist() if hasattr(res_FastICA_inverse_transform, 'tolist') else res_FastICA_inverse_transform`;
  }
  /**
      Request metadata passed to the `inverse_transform` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_inverse_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FastICA must call init() before set_inverse_transform_request()"
      );
    }
    await this._py.ex`pms_FastICA_set_inverse_transform_request = {'copy': ${opts["copy"] ?? void 0}}

pms_FastICA_set_inverse_transform_request = {k: v for k, v in pms_FastICA_set_inverse_transform_request.items() if v is not None}`;
    await this._py.ex`res_FastICA_set_inverse_transform_request = bridgeFastICA[${this.id}].set_inverse_transform_request(**pms_FastICA_set_inverse_transform_request)`;
    return this._py`res_FastICA_set_inverse_transform_request.tolist() if hasattr(res_FastICA_set_inverse_transform_request, 'tolist') else res_FastICA_set_inverse_transform_request`;
  }
  /**
      Set output container.
  
      See [Introducing the set_output API](https://scikit-learn.org/stable/modules/generated/../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before set_output()");
    }
    await this._py.ex`pms_FastICA_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_FastICA_set_output = {k: v for k, v in pms_FastICA_set_output.items() if v is not None}`;
    await this._py.ex`res_FastICA_set_output = bridgeFastICA[${this.id}].set_output(**pms_FastICA_set_output)`;
    return this._py`res_FastICA_set_output.tolist() if hasattr(res_FastICA_set_output, 'tolist') else res_FastICA_set_output`;
  }
  /**
      Request metadata passed to the `transform` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_transform_request(opts) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before set_transform_request()");
    }
    await this._py.ex`pms_FastICA_set_transform_request = {'copy': ${opts["copy"] ?? void 0}}

pms_FastICA_set_transform_request = {k: v for k, v in pms_FastICA_set_transform_request.items() if v is not None}`;
    await this._py.ex`res_FastICA_set_transform_request = bridgeFastICA[${this.id}].set_transform_request(**pms_FastICA_set_transform_request)`;
    return this._py`res_FastICA_set_transform_request.tolist() if hasattr(res_FastICA_set_transform_request, 'tolist') else res_FastICA_set_transform_request`;
  }
  /**
    Recover the sources from X (apply the unmixing matrix).
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before transform()");
    }
    await this._py.ex`pms_FastICA_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'copy': ${opts["copy"] ?? void 0}}

pms_FastICA_transform = {k: v for k, v in pms_FastICA_transform.items() if v is not None}`;
    await this._py.ex`res_FastICA_transform = bridgeFastICA[${this.id}].transform(**pms_FastICA_transform)`;
    return this._py`res_FastICA_transform.tolist() if hasattr(res_FastICA_transform, 'tolist') else res_FastICA_transform`;
  }
  /**
    The linear operator to apply to the data to get the independent sources. This is equal to the unmixing matrix when `whiten` is `false`, and equal to `np.dot(unmixing_matrix, self.whitening_)` when `whiten` is `true`.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before accessing components_");
    }
    return (async () => {
      await this._py.ex`attr_FastICA_components_ = bridgeFastICA[${this.id}].components_`;
      return this._py`attr_FastICA_components_.tolist() if hasattr(attr_FastICA_components_, 'tolist') else attr_FastICA_components_`;
    })();
  }
  /**
    The pseudo-inverse of `components_`. It is the linear operator that maps independent sources to the data.
   */
  get mixing_() {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before accessing mixing_");
    }
    return (async () => {
      await this._py.ex`attr_FastICA_mixing_ = bridgeFastICA[${this.id}].mixing_`;
      return this._py`attr_FastICA_mixing_.tolist() if hasattr(attr_FastICA_mixing_, 'tolist') else attr_FastICA_mixing_`;
    })();
  }
  /**
    The mean over features. Only set if `self.whiten` is `true`.
   */
  get mean_() {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before accessing mean_");
    }
    return (async () => {
      await this._py.ex`attr_FastICA_mean_ = bridgeFastICA[${this.id}].mean_`;
      return this._py`attr_FastICA_mean_.tolist() if hasattr(attr_FastICA_mean_, 'tolist') else attr_FastICA_mean_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FastICA must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FastICA_n_features_in_ = bridgeFastICA[${this.id}].n_features_in_`;
      return this._py`attr_FastICA_n_features_in_.tolist() if hasattr(attr_FastICA_n_features_in_, 'tolist') else attr_FastICA_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "FastICA must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_FastICA_feature_names_in_ = bridgeFastICA[${this.id}].feature_names_in_`;
      return this._py`attr_FastICA_feature_names_in_.tolist() if hasattr(attr_FastICA_feature_names_in_, 'tolist') else attr_FastICA_feature_names_in_`;
    })();
  }
  /**
    If the algorithm is “deflation”, n_iter is the maximum number of iterations run across all components. Else they are just the number of iterations taken to converge.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_FastICA_n_iter_ = bridgeFastICA[${this.id}].n_iter_`;
      return this._py`attr_FastICA_n_iter_.tolist() if hasattr(attr_FastICA_n_iter_, 'tolist') else attr_FastICA_n_iter_`;
    })();
  }
  /**
    Only set if whiten is ‘`true`’. This is the pre-whitening matrix that projects data onto the first `n_components` principal components.
   */
  get whitening_() {
    if (this._isDisposed) {
      throw new Error("This FastICA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("FastICA must call init() before accessing whitening_");
    }
    return (async () => {
      await this._py.ex`attr_FastICA_whitening_ = bridgeFastICA[${this.id}].whitening_`;
      return this._py`attr_FastICA_whitening_.tolist() if hasattr(attr_FastICA_whitening_, 'tolist') else attr_FastICA_whitening_`;
    })();
  }
};

// src/generated/decomposition/IncrementalPCA.ts
import crypto34 from "node:crypto";
var IncrementalPCA = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `IncrementalPCA${crypto34.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("IncrementalPCA.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import IncrementalPCA
try: bridgeIncrementalPCA
except NameError: bridgeIncrementalPCA = {}
`;
    await this._py.ex`ctor_IncrementalPCA = {'n_components': ${this.opts["n_components"] ?? void 0}, 'whiten': ${this.opts["whiten"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}, 'batch_size': ${this.opts["batch_size"] ?? void 0}}

ctor_IncrementalPCA = {k: v for k, v in ctor_IncrementalPCA.items() if v is not None}`;
    await this._py.ex`bridgeIncrementalPCA[${this.id}] = IncrementalPCA(**ctor_IncrementalPCA)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeIncrementalPCA[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model with X, using minibatches of size batch_size.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IncrementalPCA must call init() before fit()");
    }
    await this._py.ex`pms_IncrementalPCA_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_IncrementalPCA_fit = {k: v for k, v in pms_IncrementalPCA_fit.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_fit = bridgeIncrementalPCA[${this.id}].fit(**pms_IncrementalPCA_fit)`;
    return this._py`res_IncrementalPCA_fit.tolist() if hasattr(res_IncrementalPCA_fit, 'tolist') else res_IncrementalPCA_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IncrementalPCA must call init() before fit_transform()");
    }
    await this._py.ex`pms_IncrementalPCA_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_IncrementalPCA_fit_transform = {k: v for k, v in pms_IncrementalPCA_fit_transform.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_fit_transform = bridgeIncrementalPCA[${this.id}].fit_transform(**pms_IncrementalPCA_fit_transform)`;
    return this._py`res_IncrementalPCA_fit_transform.tolist() if hasattr(res_IncrementalPCA_fit_transform, 'tolist') else res_IncrementalPCA_fit_transform`;
  }
  /**
      Compute data covariance with the generative model.
  
      `cov \= components_.T \* S\*\*2 \* components_ + sigma2 \* eye(n_features)` where S\*\*2 contains the explained variances, and sigma2 contains the noise variances.
     */
  async get_covariance(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IncrementalPCA must call init() before get_covariance()");
    }
    await this._py.ex`pms_IncrementalPCA_get_covariance = {'cov': np.array(${opts["cov"] ?? void 0}) if ${opts["cov"] !== void 0} else None}

pms_IncrementalPCA_get_covariance = {k: v for k, v in pms_IncrementalPCA_get_covariance.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_get_covariance = bridgeIncrementalPCA[${this.id}].get_covariance(**pms_IncrementalPCA_get_covariance)`;
    return this._py`res_IncrementalPCA_get_covariance.tolist() if hasattr(res_IncrementalPCA_get_covariance, 'tolist') else res_IncrementalPCA_get_covariance`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class_name0", "class_name1", "class_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_IncrementalPCA_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_IncrementalPCA_get_feature_names_out = {k: v for k, v in pms_IncrementalPCA_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_get_feature_names_out = bridgeIncrementalPCA[${this.id}].get_feature_names_out(**pms_IncrementalPCA_get_feature_names_out)`;
    return this._py`res_IncrementalPCA_get_feature_names_out.tolist() if hasattr(res_IncrementalPCA_get_feature_names_out, 'tolist') else res_IncrementalPCA_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_IncrementalPCA_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_IncrementalPCA_get_metadata_routing = {k: v for k, v in pms_IncrementalPCA_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_get_metadata_routing = bridgeIncrementalPCA[${this.id}].get_metadata_routing(**pms_IncrementalPCA_get_metadata_routing)`;
    return this._py`res_IncrementalPCA_get_metadata_routing.tolist() if hasattr(res_IncrementalPCA_get_metadata_routing, 'tolist') else res_IncrementalPCA_get_metadata_routing`;
  }
  /**
      Compute data precision matrix with the generative model.
  
      Equals the inverse of the covariance but computed with the matrix inversion lemma for efficiency.
     */
  async get_precision(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IncrementalPCA must call init() before get_precision()");
    }
    await this._py.ex`pms_IncrementalPCA_get_precision = {'precision': ${opts["precision"] ?? void 0}}

pms_IncrementalPCA_get_precision = {k: v for k, v in pms_IncrementalPCA_get_precision.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_get_precision = bridgeIncrementalPCA[${this.id}].get_precision(**pms_IncrementalPCA_get_precision)`;
    return this._py`res_IncrementalPCA_get_precision.tolist() if hasattr(res_IncrementalPCA_get_precision, 'tolist') else res_IncrementalPCA_get_precision`;
  }
  /**
      Transform data back to its original space.
  
      In other words, return an input `X_original` whose transform would be X.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_IncrementalPCA_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_IncrementalPCA_inverse_transform = {k: v for k, v in pms_IncrementalPCA_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_inverse_transform = bridgeIncrementalPCA[${this.id}].inverse_transform(**pms_IncrementalPCA_inverse_transform)`;
    return this._py`res_IncrementalPCA_inverse_transform.tolist() if hasattr(res_IncrementalPCA_inverse_transform, 'tolist') else res_IncrementalPCA_inverse_transform`;
  }
  /**
    Incremental fit with X. All of X is processed as a single batch.
   */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IncrementalPCA must call init() before partial_fit()");
    }
    await this._py.ex`pms_IncrementalPCA_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'check_input': ${opts["check_input"] ?? void 0}}

pms_IncrementalPCA_partial_fit = {k: v for k, v in pms_IncrementalPCA_partial_fit.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_partial_fit = bridgeIncrementalPCA[${this.id}].partial_fit(**pms_IncrementalPCA_partial_fit)`;
    return this._py`res_IncrementalPCA_partial_fit.tolist() if hasattr(res_IncrementalPCA_partial_fit, 'tolist') else res_IncrementalPCA_partial_fit`;
  }
  /**
      Set output container.
  
      See [Introducing the set_output API](https://scikit-learn.org/stable/modules/generated/../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IncrementalPCA must call init() before set_output()");
    }
    await this._py.ex`pms_IncrementalPCA_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_IncrementalPCA_set_output = {k: v for k, v in pms_IncrementalPCA_set_output.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_set_output = bridgeIncrementalPCA[${this.id}].set_output(**pms_IncrementalPCA_set_output)`;
    return this._py`res_IncrementalPCA_set_output.tolist() if hasattr(res_IncrementalPCA_set_output, 'tolist') else res_IncrementalPCA_set_output`;
  }
  /**
      Request metadata passed to the `partial_fit` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_partial_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before set_partial_fit_request()"
      );
    }
    await this._py.ex`pms_IncrementalPCA_set_partial_fit_request = {'check_input': ${opts["check_input"] ?? void 0}}

pms_IncrementalPCA_set_partial_fit_request = {k: v for k, v in pms_IncrementalPCA_set_partial_fit_request.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_set_partial_fit_request = bridgeIncrementalPCA[${this.id}].set_partial_fit_request(**pms_IncrementalPCA_set_partial_fit_request)`;
    return this._py`res_IncrementalPCA_set_partial_fit_request.tolist() if hasattr(res_IncrementalPCA_set_partial_fit_request, 'tolist') else res_IncrementalPCA_set_partial_fit_request`;
  }
  /**
      Apply dimensionality reduction to X.
  
      X is projected on the first principal components previously extracted from a training set, using minibatches of size batch_size if X is sparse.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IncrementalPCA must call init() before transform()");
    }
    await this._py.ex`pms_IncrementalPCA_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_IncrementalPCA_transform = {k: v for k, v in pms_IncrementalPCA_transform.items() if v is not None}`;
    await this._py.ex`res_IncrementalPCA_transform = bridgeIncrementalPCA[${this.id}].transform(**pms_IncrementalPCA_transform)`;
    return this._py`res_IncrementalPCA_transform.tolist() if hasattr(res_IncrementalPCA_transform, 'tolist') else res_IncrementalPCA_transform`;
  }
  /**
    Principal axes in feature space, representing the directions of maximum variance in the data. Equivalently, the right singular vectors of the centered input data, parallel to its eigenvectors. The components are sorted by decreasing `explained_variance_`.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_components_ = bridgeIncrementalPCA[${this.id}].components_`;
      return this._py`attr_IncrementalPCA_components_.tolist() if hasattr(attr_IncrementalPCA_components_, 'tolist') else attr_IncrementalPCA_components_`;
    })();
  }
  /**
    Variance explained by each of the selected components.
   */
  get explained_variance_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing explained_variance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_explained_variance_ = bridgeIncrementalPCA[${this.id}].explained_variance_`;
      return this._py`attr_IncrementalPCA_explained_variance_.tolist() if hasattr(attr_IncrementalPCA_explained_variance_, 'tolist') else attr_IncrementalPCA_explained_variance_`;
    })();
  }
  /**
    Percentage of variance explained by each of the selected components. If all components are stored, the sum of explained variances is equal to 1.0.
   */
  get explained_variance_ratio_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing explained_variance_ratio_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_explained_variance_ratio_ = bridgeIncrementalPCA[${this.id}].explained_variance_ratio_`;
      return this._py`attr_IncrementalPCA_explained_variance_ratio_.tolist() if hasattr(attr_IncrementalPCA_explained_variance_ratio_, 'tolist') else attr_IncrementalPCA_explained_variance_ratio_`;
    })();
  }
  /**
    The singular values corresponding to each of the selected components. The singular values are equal to the 2-norms of the `n_components` variables in the lower-dimensional space.
   */
  get singular_values_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing singular_values_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_singular_values_ = bridgeIncrementalPCA[${this.id}].singular_values_`;
      return this._py`attr_IncrementalPCA_singular_values_.tolist() if hasattr(attr_IncrementalPCA_singular_values_, 'tolist') else attr_IncrementalPCA_singular_values_`;
    })();
  }
  /**
    Per-feature empirical mean, aggregate over calls to `partial_fit`.
   */
  get mean_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IncrementalPCA must call init() before accessing mean_");
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_mean_ = bridgeIncrementalPCA[${this.id}].mean_`;
      return this._py`attr_IncrementalPCA_mean_.tolist() if hasattr(attr_IncrementalPCA_mean_, 'tolist') else attr_IncrementalPCA_mean_`;
    })();
  }
  /**
    Per-feature empirical variance, aggregate over calls to `partial_fit`.
   */
  get var_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IncrementalPCA must call init() before accessing var_");
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_var_ = bridgeIncrementalPCA[${this.id}].var_`;
      return this._py`attr_IncrementalPCA_var_.tolist() if hasattr(attr_IncrementalPCA_var_, 'tolist') else attr_IncrementalPCA_var_`;
    })();
  }
  /**
    The estimated noise covariance following the Probabilistic PCA model from Tipping and Bishop 1999. See “Pattern Recognition and Machine Learning” by C. Bishop, 12.2.1 p. 574 or [http://www.miketipping.com/papers/met-mppca.pdf](http://www.miketipping.com/papers/met-mppca.pdf).
   */
  get noise_variance_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing noise_variance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_noise_variance_ = bridgeIncrementalPCA[${this.id}].noise_variance_`;
      return this._py`attr_IncrementalPCA_noise_variance_.tolist() if hasattr(attr_IncrementalPCA_noise_variance_, 'tolist') else attr_IncrementalPCA_noise_variance_`;
    })();
  }
  /**
    The estimated number of components. Relevant when `n_components=None`.
   */
  get n_components_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing n_components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_n_components_ = bridgeIncrementalPCA[${this.id}].n_components_`;
      return this._py`attr_IncrementalPCA_n_components_.tolist() if hasattr(attr_IncrementalPCA_n_components_, 'tolist') else attr_IncrementalPCA_n_components_`;
    })();
  }
  /**
    The number of samples processed by the estimator. Will be reset on new calls to fit, but increments across `partial_fit` calls.
   */
  get n_samples_seen_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing n_samples_seen_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_n_samples_seen_ = bridgeIncrementalPCA[${this.id}].n_samples_seen_`;
      return this._py`attr_IncrementalPCA_n_samples_seen_.tolist() if hasattr(attr_IncrementalPCA_n_samples_seen_, 'tolist') else attr_IncrementalPCA_n_samples_seen_`;
    })();
  }
  /**
    Inferred batch size from `batch_size`.
   */
  get batch_size_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing batch_size_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_batch_size_ = bridgeIncrementalPCA[${this.id}].batch_size_`;
      return this._py`attr_IncrementalPCA_batch_size_.tolist() if hasattr(attr_IncrementalPCA_batch_size_, 'tolist') else attr_IncrementalPCA_batch_size_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_n_features_in_ = bridgeIncrementalPCA[${this.id}].n_features_in_`;
      return this._py`attr_IncrementalPCA_n_features_in_.tolist() if hasattr(attr_IncrementalPCA_n_features_in_, 'tolist') else attr_IncrementalPCA_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This IncrementalPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IncrementalPCA must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IncrementalPCA_feature_names_in_ = bridgeIncrementalPCA[${this.id}].feature_names_in_`;
      return this._py`attr_IncrementalPCA_feature_names_in_.tolist() if hasattr(attr_IncrementalPCA_feature_names_in_, 'tolist') else attr_IncrementalPCA_feature_names_in_`;
    })();
  }
};

// src/generated/decomposition/KernelPCA.ts
import crypto35 from "node:crypto";
var KernelPCA = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `KernelPCA${crypto35.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("KernelPCA.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import KernelPCA
try: bridgeKernelPCA
except NameError: bridgeKernelPCA = {}
`;
    await this._py.ex`ctor_KernelPCA = {'n_components': ${this.opts["n_components"] ?? void 0}, 'kernel': ${this.opts["kernel"] ?? void 0}, 'gamma': ${this.opts["gamma"] ?? void 0}, 'degree': ${this.opts["degree"] ?? void 0}, 'coef0': ${this.opts["coef0"] ?? void 0}, 'kernel_params': ${this.opts["kernel_params"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'fit_inverse_transform': ${this.opts["fit_inverse_transform"] ?? void 0}, 'eigen_solver': ${this.opts["eigen_solver"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'iterated_power': ${this.opts["iterated_power"] ?? void 0}, 'remove_zero_eig': ${this.opts["remove_zero_eig"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'copy_X': ${this.opts["copy_X"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}}

ctor_KernelPCA = {k: v for k, v in ctor_KernelPCA.items() if v is not None}`;
    await this._py.ex`bridgeKernelPCA[${this.id}] = KernelPCA(**ctor_KernelPCA)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeKernelPCA[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model from data in X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelPCA must call init() before fit()");
    }
    await this._py.ex`pms_KernelPCA_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_KernelPCA_fit = {k: v for k, v in pms_KernelPCA_fit.items() if v is not None}`;
    await this._py.ex`res_KernelPCA_fit = bridgeKernelPCA[${this.id}].fit(**pms_KernelPCA_fit)`;
    return this._py`res_KernelPCA_fit.tolist() if hasattr(res_KernelPCA_fit, 'tolist') else res_KernelPCA_fit`;
  }
  /**
    Fit the model from data in X and transform X.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelPCA must call init() before fit_transform()");
    }
    await this._py.ex`pms_KernelPCA_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'params': ${opts["params"] ?? void 0}}

pms_KernelPCA_fit_transform = {k: v for k, v in pms_KernelPCA_fit_transform.items() if v is not None}`;
    await this._py.ex`res_KernelPCA_fit_transform = bridgeKernelPCA[${this.id}].fit_transform(**pms_KernelPCA_fit_transform)`;
    return this._py`res_KernelPCA_fit_transform.tolist() if hasattr(res_KernelPCA_fit_transform, 'tolist') else res_KernelPCA_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class_name0", "class_name1", "class_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelPCA must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_KernelPCA_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_KernelPCA_get_feature_names_out = {k: v for k, v in pms_KernelPCA_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_KernelPCA_get_feature_names_out = bridgeKernelPCA[${this.id}].get_feature_names_out(**pms_KernelPCA_get_feature_names_out)`;
    return this._py`res_KernelPCA_get_feature_names_out.tolist() if hasattr(res_KernelPCA_get_feature_names_out, 'tolist') else res_KernelPCA_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelPCA must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_KernelPCA_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_KernelPCA_get_metadata_routing = {k: v for k, v in pms_KernelPCA_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_KernelPCA_get_metadata_routing = bridgeKernelPCA[${this.id}].get_metadata_routing(**pms_KernelPCA_get_metadata_routing)`;
    return this._py`res_KernelPCA_get_metadata_routing.tolist() if hasattr(res_KernelPCA_get_metadata_routing, 'tolist') else res_KernelPCA_get_metadata_routing`;
  }
  /**
      Transform X back to original space.
  
      `inverse_transform` approximates the inverse transformation using a learned pre-image. The pre-image is learned by kernel ridge regression of the original data on their low-dimensional representation vectors.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelPCA must call init() before inverse_transform()");
    }
    await this._py.ex`pms_KernelPCA_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_KernelPCA_inverse_transform = {k: v for k, v in pms_KernelPCA_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_KernelPCA_inverse_transform = bridgeKernelPCA[${this.id}].inverse_transform(**pms_KernelPCA_inverse_transform)`;
    return this._py`res_KernelPCA_inverse_transform.tolist() if hasattr(res_KernelPCA_inverse_transform, 'tolist') else res_KernelPCA_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set_output API](https://scikit-learn.org/stable/modules/generated/../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelPCA must call init() before set_output()");
    }
    await this._py.ex`pms_KernelPCA_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_KernelPCA_set_output = {k: v for k, v in pms_KernelPCA_set_output.items() if v is not None}`;
    await this._py.ex`res_KernelPCA_set_output = bridgeKernelPCA[${this.id}].set_output(**pms_KernelPCA_set_output)`;
    return this._py`res_KernelPCA_set_output.tolist() if hasattr(res_KernelPCA_set_output, 'tolist') else res_KernelPCA_set_output`;
  }
  /**
    Transform X.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelPCA must call init() before transform()");
    }
    await this._py.ex`pms_KernelPCA_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_KernelPCA_transform = {k: v for k, v in pms_KernelPCA_transform.items() if v is not None}`;
    await this._py.ex`res_KernelPCA_transform = bridgeKernelPCA[${this.id}].transform(**pms_KernelPCA_transform)`;
    return this._py`res_KernelPCA_transform.tolist() if hasattr(res_KernelPCA_transform, 'tolist') else res_KernelPCA_transform`;
  }
  /**
    Eigenvalues of the centered kernel matrix in decreasing order. If `n_components` and `remove_zero_eig` are not set, then all values are stored.
   */
  get eigenvalues_() {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelPCA must call init() before accessing eigenvalues_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KernelPCA_eigenvalues_ = bridgeKernelPCA[${this.id}].eigenvalues_`;
      return this._py`attr_KernelPCA_eigenvalues_.tolist() if hasattr(attr_KernelPCA_eigenvalues_, 'tolist') else attr_KernelPCA_eigenvalues_`;
    })();
  }
  /**
    Eigenvectors of the centered kernel matrix. If `n_components` and `remove_zero_eig` are not set, then all components are stored.
   */
  get eigenvectors_() {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelPCA must call init() before accessing eigenvectors_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KernelPCA_eigenvectors_ = bridgeKernelPCA[${this.id}].eigenvectors_`;
      return this._py`attr_KernelPCA_eigenvectors_.tolist() if hasattr(attr_KernelPCA_eigenvectors_, 'tolist') else attr_KernelPCA_eigenvectors_`;
    })();
  }
  /**
    Inverse transform matrix. Only available when `fit_inverse_transform` is `true`.
   */
  get dual_coef_() {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelPCA must call init() before accessing dual_coef_");
    }
    return (async () => {
      await this._py.ex`attr_KernelPCA_dual_coef_ = bridgeKernelPCA[${this.id}].dual_coef_`;
      return this._py`attr_KernelPCA_dual_coef_.tolist() if hasattr(attr_KernelPCA_dual_coef_, 'tolist') else attr_KernelPCA_dual_coef_`;
    })();
  }
  /**
    Projection of the fitted data on the kernel principal components. Only available when `fit_inverse_transform` is `true`.
   */
  get X_transformed_fit_() {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelPCA must call init() before accessing X_transformed_fit_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KernelPCA_X_transformed_fit_ = bridgeKernelPCA[${this.id}].X_transformed_fit_`;
      return this._py`attr_KernelPCA_X_transformed_fit_.tolist() if hasattr(attr_KernelPCA_X_transformed_fit_, 'tolist') else attr_KernelPCA_X_transformed_fit_`;
    })();
  }
  /**
    The data used to fit the model. If `copy_X=False`, then `X_fit_` is a reference. This attribute is used for the calls to transform.
   */
  get X_fit_() {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelPCA must call init() before accessing X_fit_");
    }
    return (async () => {
      await this._py.ex`attr_KernelPCA_X_fit_ = bridgeKernelPCA[${this.id}].X_fit_`;
      return this._py`attr_KernelPCA_X_fit_.tolist() if hasattr(attr_KernelPCA_X_fit_, 'tolist') else attr_KernelPCA_X_fit_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelPCA must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KernelPCA_n_features_in_ = bridgeKernelPCA[${this.id}].n_features_in_`;
      return this._py`attr_KernelPCA_n_features_in_.tolist() if hasattr(attr_KernelPCA_n_features_in_, 'tolist') else attr_KernelPCA_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "KernelPCA must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_KernelPCA_feature_names_in_ = bridgeKernelPCA[${this.id}].feature_names_in_`;
      return this._py`attr_KernelPCA_feature_names_in_.tolist() if hasattr(attr_KernelPCA_feature_names_in_, 'tolist') else attr_KernelPCA_feature_names_in_`;
    })();
  }
  /**
    Kernel coefficient for rbf, poly and sigmoid kernels. When `gamma` is explicitly provided, this is just the same as `gamma`. When `gamma` is `undefined`, this is the actual value of kernel coefficient.
   */
  get gamma_() {
    if (this._isDisposed) {
      throw new Error("This KernelPCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("KernelPCA must call init() before accessing gamma_");
    }
    return (async () => {
      await this._py.ex`attr_KernelPCA_gamma_ = bridgeKernelPCA[${this.id}].gamma_`;
      return this._py`attr_KernelPCA_gamma_.tolist() if hasattr(attr_KernelPCA_gamma_, 'tolist') else attr_KernelPCA_gamma_`;
    })();
  }
};

// src/generated/decomposition/LatentDirichletAllocation.ts
import crypto36 from "node:crypto";
var LatentDirichletAllocation = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `LatentDirichletAllocation${crypto36.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "LatentDirichletAllocation.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import LatentDirichletAllocation
try: bridgeLatentDirichletAllocation
except NameError: bridgeLatentDirichletAllocation = {}
`;
    await this._py.ex`ctor_LatentDirichletAllocation = {'n_components': ${this.opts["n_components"] ?? void 0}, 'doc_topic_prior': ${this.opts["doc_topic_prior"] ?? void 0}, 'topic_word_prior': ${this.opts["topic_word_prior"] ?? void 0}, 'learning_method': ${this.opts["learning_method"] ?? void 0}, 'learning_decay': ${this.opts["learning_decay"] ?? void 0}, 'learning_offset': ${this.opts["learning_offset"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'batch_size': ${this.opts["batch_size"] ?? void 0}, 'evaluate_every': ${this.opts["evaluate_every"] ?? void 0}, 'total_samples': ${this.opts["total_samples"] ?? void 0}, 'perp_tol': ${this.opts["perp_tol"] ?? void 0}, 'mean_change_tol': ${this.opts["mean_change_tol"] ?? void 0}, 'max_doc_update_iter': ${this.opts["max_doc_update_iter"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_LatentDirichletAllocation = {k: v for k, v in ctor_LatentDirichletAllocation.items() if v is not None}`;
    await this._py.ex`bridgeLatentDirichletAllocation[${this.id}] = LatentDirichletAllocation(**ctor_LatentDirichletAllocation)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLatentDirichletAllocation[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Learn model for the data X with variational Bayes method.
  
      When `learning_method` is ‘online’, use mini-batch update. Otherwise, use batch update.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("LatentDirichletAllocation must call init() before fit()");
    }
    await this._py.ex`pms_LatentDirichletAllocation_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_LatentDirichletAllocation_fit = {k: v for k, v in pms_LatentDirichletAllocation_fit.items() if v is not None}`;
    await this._py.ex`res_LatentDirichletAllocation_fit = bridgeLatentDirichletAllocation[${this.id}].fit(**pms_LatentDirichletAllocation_fit)`;
    return this._py`res_LatentDirichletAllocation_fit.tolist() if hasattr(res_LatentDirichletAllocation_fit, 'tolist') else res_LatentDirichletAllocation_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_LatentDirichletAllocation_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_LatentDirichletAllocation_fit_transform = {k: v for k, v in pms_LatentDirichletAllocation_fit_transform.items() if v is not None}`;
    await this._py.ex`res_LatentDirichletAllocation_fit_transform = bridgeLatentDirichletAllocation[${this.id}].fit_transform(**pms_LatentDirichletAllocation_fit_transform)`;
    return this._py`res_LatentDirichletAllocation_fit_transform.tolist() if hasattr(res_LatentDirichletAllocation_fit_transform, 'tolist') else res_LatentDirichletAllocation_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class_name0", "class_name1", "class_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_LatentDirichletAllocation_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_LatentDirichletAllocation_get_feature_names_out = {k: v for k, v in pms_LatentDirichletAllocation_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_LatentDirichletAllocation_get_feature_names_out = bridgeLatentDirichletAllocation[${this.id}].get_feature_names_out(**pms_LatentDirichletAllocation_get_feature_names_out)`;
    return this._py`res_LatentDirichletAllocation_get_feature_names_out.tolist() if hasattr(res_LatentDirichletAllocation_get_feature_names_out, 'tolist') else res_LatentDirichletAllocation_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LatentDirichletAllocation_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LatentDirichletAllocation_get_metadata_routing = {k: v for k, v in pms_LatentDirichletAllocation_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LatentDirichletAllocation_get_metadata_routing = bridgeLatentDirichletAllocation[${this.id}].get_metadata_routing(**pms_LatentDirichletAllocation_get_metadata_routing)`;
    return this._py`res_LatentDirichletAllocation_get_metadata_routing.tolist() if hasattr(res_LatentDirichletAllocation_get_metadata_routing, 'tolist') else res_LatentDirichletAllocation_get_metadata_routing`;
  }
  /**
    Online VB with Mini-Batch update.
   */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before partial_fit()"
      );
    }
    await this._py.ex`pms_LatentDirichletAllocation_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_LatentDirichletAllocation_partial_fit = {k: v for k, v in pms_LatentDirichletAllocation_partial_fit.items() if v is not None}`;
    await this._py.ex`res_LatentDirichletAllocation_partial_fit = bridgeLatentDirichletAllocation[${this.id}].partial_fit(**pms_LatentDirichletAllocation_partial_fit)`;
    return this._py`res_LatentDirichletAllocation_partial_fit.tolist() if hasattr(res_LatentDirichletAllocation_partial_fit, 'tolist') else res_LatentDirichletAllocation_partial_fit`;
  }
  /**
      Calculate approximate perplexity for data X.
  
      Perplexity is defined as exp(-1. \* log-likelihood per word)
     */
  async perplexity(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before perplexity()"
      );
    }
    await this._py.ex`pms_LatentDirichletAllocation_perplexity = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'sub_sampling': ${opts["sub_sampling"] ?? void 0}}

pms_LatentDirichletAllocation_perplexity = {k: v for k, v in pms_LatentDirichletAllocation_perplexity.items() if v is not None}`;
    await this._py.ex`res_LatentDirichletAllocation_perplexity = bridgeLatentDirichletAllocation[${this.id}].perplexity(**pms_LatentDirichletAllocation_perplexity)`;
    return this._py`res_LatentDirichletAllocation_perplexity.tolist() if hasattr(res_LatentDirichletAllocation_perplexity, 'tolist') else res_LatentDirichletAllocation_perplexity`;
  }
  /**
    Calculate approximate log-likelihood as score.
   */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before score()"
      );
    }
    await this._py.ex`pms_LatentDirichletAllocation_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_LatentDirichletAllocation_score = {k: v for k, v in pms_LatentDirichletAllocation_score.items() if v is not None}`;
    await this._py.ex`res_LatentDirichletAllocation_score = bridgeLatentDirichletAllocation[${this.id}].score(**pms_LatentDirichletAllocation_score)`;
    return this._py`res_LatentDirichletAllocation_score.tolist() if hasattr(res_LatentDirichletAllocation_score, 'tolist') else res_LatentDirichletAllocation_score`;
  }
  /**
      Set output container.
  
      See [Introducing the set_output API](https://scikit-learn.org/stable/modules/generated/../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before set_output()"
      );
    }
    await this._py.ex`pms_LatentDirichletAllocation_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_LatentDirichletAllocation_set_output = {k: v for k, v in pms_LatentDirichletAllocation_set_output.items() if v is not None}`;
    await this._py.ex`res_LatentDirichletAllocation_set_output = bridgeLatentDirichletAllocation[${this.id}].set_output(**pms_LatentDirichletAllocation_set_output)`;
    return this._py`res_LatentDirichletAllocation_set_output.tolist() if hasattr(res_LatentDirichletAllocation_set_output, 'tolist') else res_LatentDirichletAllocation_set_output`;
  }
  /**
    Transform data X according to the fitted model.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before transform()"
      );
    }
    await this._py.ex`pms_LatentDirichletAllocation_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LatentDirichletAllocation_transform = {k: v for k, v in pms_LatentDirichletAllocation_transform.items() if v is not None}`;
    await this._py.ex`res_LatentDirichletAllocation_transform = bridgeLatentDirichletAllocation[${this.id}].transform(**pms_LatentDirichletAllocation_transform)`;
    return this._py`res_LatentDirichletAllocation_transform.tolist() if hasattr(res_LatentDirichletAllocation_transform, 'tolist') else res_LatentDirichletAllocation_transform`;
  }
  /**
    Variational parameters for topic word distribution. Since the complete conditional for topic word distribution is a Dirichlet, `components_\[i, j\]` can be viewed as pseudocount that represents the number of times word `j` was assigned to topic `i`. It can also be viewed as distribution over the words for each topic after normalization: `model.components_ / model.components_.sum(axis=1)\[:, np.newaxis\]`.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_components_ = bridgeLatentDirichletAllocation[${this.id}].components_`;
      return this._py`attr_LatentDirichletAllocation_components_.tolist() if hasattr(attr_LatentDirichletAllocation_components_, 'tolist') else attr_LatentDirichletAllocation_components_`;
    })();
  }
  /**
    Exponential value of expectation of log topic word distribution. In the literature, this is `exp(E\[log(beta)\])`.
   */
  get exp_dirichlet_component_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing exp_dirichlet_component_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_exp_dirichlet_component_ = bridgeLatentDirichletAllocation[${this.id}].exp_dirichlet_component_`;
      return this._py`attr_LatentDirichletAllocation_exp_dirichlet_component_.tolist() if hasattr(attr_LatentDirichletAllocation_exp_dirichlet_component_, 'tolist') else attr_LatentDirichletAllocation_exp_dirichlet_component_`;
    })();
  }
  /**
    Number of iterations of the EM step.
   */
  get n_batch_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing n_batch_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_n_batch_iter_ = bridgeLatentDirichletAllocation[${this.id}].n_batch_iter_`;
      return this._py`attr_LatentDirichletAllocation_n_batch_iter_.tolist() if hasattr(attr_LatentDirichletAllocation_n_batch_iter_, 'tolist') else attr_LatentDirichletAllocation_n_batch_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_n_features_in_ = bridgeLatentDirichletAllocation[${this.id}].n_features_in_`;
      return this._py`attr_LatentDirichletAllocation_n_features_in_.tolist() if hasattr(attr_LatentDirichletAllocation_n_features_in_, 'tolist') else attr_LatentDirichletAllocation_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_feature_names_in_ = bridgeLatentDirichletAllocation[${this.id}].feature_names_in_`;
      return this._py`attr_LatentDirichletAllocation_feature_names_in_.tolist() if hasattr(attr_LatentDirichletAllocation_feature_names_in_, 'tolist') else attr_LatentDirichletAllocation_feature_names_in_`;
    })();
  }
  /**
    Number of passes over the dataset.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_n_iter_ = bridgeLatentDirichletAllocation[${this.id}].n_iter_`;
      return this._py`attr_LatentDirichletAllocation_n_iter_.tolist() if hasattr(attr_LatentDirichletAllocation_n_iter_, 'tolist') else attr_LatentDirichletAllocation_n_iter_`;
    })();
  }
  /**
    Final perplexity score on training set.
   */
  get bound_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing bound_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_bound_ = bridgeLatentDirichletAllocation[${this.id}].bound_`;
      return this._py`attr_LatentDirichletAllocation_bound_.tolist() if hasattr(attr_LatentDirichletAllocation_bound_, 'tolist') else attr_LatentDirichletAllocation_bound_`;
    })();
  }
  /**
    Prior of document topic distribution `theta`. If the value is `undefined`, it is `1 / n_components`.
   */
  get doc_topic_prior_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing doc_topic_prior_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_doc_topic_prior_ = bridgeLatentDirichletAllocation[${this.id}].doc_topic_prior_`;
      return this._py`attr_LatentDirichletAllocation_doc_topic_prior_.tolist() if hasattr(attr_LatentDirichletAllocation_doc_topic_prior_, 'tolist') else attr_LatentDirichletAllocation_doc_topic_prior_`;
    })();
  }
  /**
    RandomState instance that is generated either from a seed, the random number generator or by `np.random`.
   */
  get random_state_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing random_state_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_random_state_ = bridgeLatentDirichletAllocation[${this.id}].random_state_`;
      return this._py`attr_LatentDirichletAllocation_random_state_.tolist() if hasattr(attr_LatentDirichletAllocation_random_state_, 'tolist') else attr_LatentDirichletAllocation_random_state_`;
    })();
  }
  /**
    Prior of topic word distribution `beta`. If the value is `undefined`, it is `1 / n_components`.
   */
  get topic_word_prior_() {
    if (this._isDisposed) {
      throw new Error(
        "This LatentDirichletAllocation instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LatentDirichletAllocation must call init() before accessing topic_word_prior_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LatentDirichletAllocation_topic_word_prior_ = bridgeLatentDirichletAllocation[${this.id}].topic_word_prior_`;
      return this._py`attr_LatentDirichletAllocation_topic_word_prior_.tolist() if hasattr(attr_LatentDirichletAllocation_topic_word_prior_, 'tolist') else attr_LatentDirichletAllocation_topic_word_prior_`;
    })();
  }
};

// src/generated/decomposition/MiniBatchDictionaryLearning.ts
import crypto37 from "node:crypto";
var MiniBatchDictionaryLearning = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `MiniBatchDictionaryLearning${crypto37.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "MiniBatchDictionaryLearning.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import MiniBatchDictionaryLearning
try: bridgeMiniBatchDictionaryLearning
except NameError: bridgeMiniBatchDictionaryLearning = {}
`;
    await this._py.ex`ctor_MiniBatchDictionaryLearning = {'n_components': ${this.opts["n_components"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'fit_algorithm': ${this.opts["fit_algorithm"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'batch_size': ${this.opts["batch_size"] ?? void 0}, 'shuffle': ${this.opts["shuffle"] ?? void 0}, 'dict_init': np.array(${this.opts["dict_init"] ?? void 0}) if ${this.opts["dict_init"] !== void 0} else None, 'transform_algorithm': ${this.opts["transform_algorithm"] ?? void 0}, 'transform_n_nonzero_coefs': ${this.opts["transform_n_nonzero_coefs"] ?? void 0}, 'transform_alpha': ${this.opts["transform_alpha"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'split_sign': ${this.opts["split_sign"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'positive_code': ${this.opts["positive_code"] ?? void 0}, 'positive_dict': ${this.opts["positive_dict"] ?? void 0}, 'transform_max_iter': ${this.opts["transform_max_iter"] ?? void 0}, 'callback': ${this.opts["callback"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'max_no_improvement': ${this.opts["max_no_improvement"] ?? void 0}}

ctor_MiniBatchDictionaryLearning = {k: v for k, v in ctor_MiniBatchDictionaryLearning.items() if v is not None}`;
    await this._py.ex`bridgeMiniBatchDictionaryLearning[${this.id}] = MiniBatchDictionaryLearning(**ctor_MiniBatchDictionaryLearning)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMiniBatchDictionaryLearning[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model from data in X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before fit()"
      );
    }
    await this._py.ex`pms_MiniBatchDictionaryLearning_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MiniBatchDictionaryLearning_fit = {k: v for k, v in pms_MiniBatchDictionaryLearning_fit.items() if v is not None}`;
    await this._py.ex`res_MiniBatchDictionaryLearning_fit = bridgeMiniBatchDictionaryLearning[${this.id}].fit(**pms_MiniBatchDictionaryLearning_fit)`;
    return this._py`res_MiniBatchDictionaryLearning_fit.tolist() if hasattr(res_MiniBatchDictionaryLearning_fit, 'tolist') else res_MiniBatchDictionaryLearning_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_MiniBatchDictionaryLearning_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_MiniBatchDictionaryLearning_fit_transform = {k: v for k, v in pms_MiniBatchDictionaryLearning_fit_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchDictionaryLearning_fit_transform = bridgeMiniBatchDictionaryLearning[${this.id}].fit_transform(**pms_MiniBatchDictionaryLearning_fit_transform)`;
    return this._py`res_MiniBatchDictionaryLearning_fit_transform.tolist() if hasattr(res_MiniBatchDictionaryLearning_fit_transform, 'tolist') else res_MiniBatchDictionaryLearning_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class_name0", "class_name1", "class_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_MiniBatchDictionaryLearning_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_MiniBatchDictionaryLearning_get_feature_names_out = {k: v for k, v in pms_MiniBatchDictionaryLearning_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_MiniBatchDictionaryLearning_get_feature_names_out = bridgeMiniBatchDictionaryLearning[${this.id}].get_feature_names_out(**pms_MiniBatchDictionaryLearning_get_feature_names_out)`;
    return this._py`res_MiniBatchDictionaryLearning_get_feature_names_out.tolist() if hasattr(res_MiniBatchDictionaryLearning_get_feature_names_out, 'tolist') else res_MiniBatchDictionaryLearning_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MiniBatchDictionaryLearning_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MiniBatchDictionaryLearning_get_metadata_routing = {k: v for k, v in pms_MiniBatchDictionaryLearning_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MiniBatchDictionaryLearning_get_metadata_routing = bridgeMiniBatchDictionaryLearning[${this.id}].get_metadata_routing(**pms_MiniBatchDictionaryLearning_get_metadata_routing)`;
    return this._py`res_MiniBatchDictionaryLearning_get_metadata_routing.tolist() if hasattr(res_MiniBatchDictionaryLearning_get_metadata_routing, 'tolist') else res_MiniBatchDictionaryLearning_get_metadata_routing`;
  }
  /**
    Update the model using the data in X as a mini-batch.
   */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before partial_fit()"
      );
    }
    await this._py.ex`pms_MiniBatchDictionaryLearning_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MiniBatchDictionaryLearning_partial_fit = {k: v for k, v in pms_MiniBatchDictionaryLearning_partial_fit.items() if v is not None}`;
    await this._py.ex`res_MiniBatchDictionaryLearning_partial_fit = bridgeMiniBatchDictionaryLearning[${this.id}].partial_fit(**pms_MiniBatchDictionaryLearning_partial_fit)`;
    return this._py`res_MiniBatchDictionaryLearning_partial_fit.tolist() if hasattr(res_MiniBatchDictionaryLearning_partial_fit, 'tolist') else res_MiniBatchDictionaryLearning_partial_fit`;
  }
  /**
      Set output container.
  
      See [Introducing the set_output API](https://scikit-learn.org/stable/modules/generated/../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before set_output()"
      );
    }
    await this._py.ex`pms_MiniBatchDictionaryLearning_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_MiniBatchDictionaryLearning_set_output = {k: v for k, v in pms_MiniBatchDictionaryLearning_set_output.items() if v is not None}`;
    await this._py.ex`res_MiniBatchDictionaryLearning_set_output = bridgeMiniBatchDictionaryLearning[${this.id}].set_output(**pms_MiniBatchDictionaryLearning_set_output)`;
    return this._py`res_MiniBatchDictionaryLearning_set_output.tolist() if hasattr(res_MiniBatchDictionaryLearning_set_output, 'tolist') else res_MiniBatchDictionaryLearning_set_output`;
  }
  /**
      Encode the data as a sparse combination of the dictionary atoms.
  
      Coding method is determined by the object parameter `transform_algorithm`.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before transform()"
      );
    }
    await this._py.ex`pms_MiniBatchDictionaryLearning_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MiniBatchDictionaryLearning_transform = {k: v for k, v in pms_MiniBatchDictionaryLearning_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchDictionaryLearning_transform = bridgeMiniBatchDictionaryLearning[${this.id}].transform(**pms_MiniBatchDictionaryLearning_transform)`;
    return this._py`res_MiniBatchDictionaryLearning_transform.tolist() if hasattr(res_MiniBatchDictionaryLearning_transform, 'tolist') else res_MiniBatchDictionaryLearning_transform`;
  }
  /**
    Components extracted from the data.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchDictionaryLearning_components_ = bridgeMiniBatchDictionaryLearning[${this.id}].components_`;
      return this._py`attr_MiniBatchDictionaryLearning_components_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_components_, 'tolist') else attr_MiniBatchDictionaryLearning_components_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchDictionaryLearning_n_features_in_ = bridgeMiniBatchDictionaryLearning[${this.id}].n_features_in_`;
      return this._py`attr_MiniBatchDictionaryLearning_n_features_in_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_n_features_in_, 'tolist') else attr_MiniBatchDictionaryLearning_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchDictionaryLearning_feature_names_in_ = bridgeMiniBatchDictionaryLearning[${this.id}].feature_names_in_`;
      return this._py`attr_MiniBatchDictionaryLearning_feature_names_in_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_feature_names_in_, 'tolist') else attr_MiniBatchDictionaryLearning_feature_names_in_`;
    })();
  }
  /**
    Number of iterations over the full dataset.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchDictionaryLearning_n_iter_ = bridgeMiniBatchDictionaryLearning[${this.id}].n_iter_`;
      return this._py`attr_MiniBatchDictionaryLearning_n_iter_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_n_iter_, 'tolist') else attr_MiniBatchDictionaryLearning_n_iter_`;
    })();
  }
  /**
    Number of mini-batches processed.
   */
  get n_steps_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchDictionaryLearning instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchDictionaryLearning must call init() before accessing n_steps_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchDictionaryLearning_n_steps_ = bridgeMiniBatchDictionaryLearning[${this.id}].n_steps_`;
      return this._py`attr_MiniBatchDictionaryLearning_n_steps_.tolist() if hasattr(attr_MiniBatchDictionaryLearning_n_steps_, 'tolist') else attr_MiniBatchDictionaryLearning_n_steps_`;
    })();
  }
};

// src/generated/decomposition/MiniBatchNMF.ts
import crypto38 from "node:crypto";
var MiniBatchNMF = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `MiniBatchNMF${crypto38.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("MiniBatchNMF.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import MiniBatchNMF
try: bridgeMiniBatchNMF
except NameError: bridgeMiniBatchNMF = {}
`;
    await this._py.ex`ctor_MiniBatchNMF = {'n_components': ${this.opts["n_components"] ?? void 0}, 'init': ${this.opts["init"] ?? void 0}, 'batch_size': ${this.opts["batch_size"] ?? void 0}, 'beta_loss': ${this.opts["beta_loss"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'max_no_improvement': ${this.opts["max_no_improvement"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'alpha_W': ${this.opts["alpha_W"] ?? void 0}, 'alpha_H': ${this.opts["alpha_H"] ?? void 0}, 'l1_ratio': ${this.opts["l1_ratio"] ?? void 0}, 'forget_factor': ${this.opts["forget_factor"] ?? void 0}, 'fresh_restarts': ${this.opts["fresh_restarts"] ?? void 0}, 'fresh_restarts_max_iter': ${this.opts["fresh_restarts_max_iter"] ?? void 0}, 'transform_max_iter': ${this.opts["transform_max_iter"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_MiniBatchNMF = {k: v for k, v in ctor_MiniBatchNMF.items() if v is not None}`;
    await this._py.ex`bridgeMiniBatchNMF[${this.id}] = MiniBatchNMF(**ctor_MiniBatchNMF)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMiniBatchNMF[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Learn a NMF model for the data X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchNMF must call init() before fit()");
    }
    await this._py.ex`pms_MiniBatchNMF_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'params': ${opts["params"] ?? void 0}}

pms_MiniBatchNMF_fit = {k: v for k, v in pms_MiniBatchNMF_fit.items() if v is not None}`;
    await this._py.ex`res_MiniBatchNMF_fit = bridgeMiniBatchNMF[${this.id}].fit(**pms_MiniBatchNMF_fit)`;
    return this._py`res_MiniBatchNMF_fit.tolist() if hasattr(res_MiniBatchNMF_fit, 'tolist') else res_MiniBatchNMF_fit`;
  }
  /**
      Learn a NMF model for the data X and returns the transformed data.
  
      This is more efficient than calling fit followed by transform.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchNMF must call init() before fit_transform()");
    }
    await this._py.ex`pms_MiniBatchNMF_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'W': np.array(${opts["W"] ?? void 0}) if ${opts["W"] !== void 0} else None, 'H': np.array(${opts["H"] ?? void 0}) if ${opts["H"] !== void 0} else None}

pms_MiniBatchNMF_fit_transform = {k: v for k, v in pms_MiniBatchNMF_fit_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchNMF_fit_transform = bridgeMiniBatchNMF[${this.id}].fit_transform(**pms_MiniBatchNMF_fit_transform)`;
    return this._py`res_MiniBatchNMF_fit_transform.tolist() if hasattr(res_MiniBatchNMF_fit_transform, 'tolist') else res_MiniBatchNMF_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class_name0", "class_name1", "class_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchNMF must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_MiniBatchNMF_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_MiniBatchNMF_get_feature_names_out = {k: v for k, v in pms_MiniBatchNMF_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_MiniBatchNMF_get_feature_names_out = bridgeMiniBatchNMF[${this.id}].get_feature_names_out(**pms_MiniBatchNMF_get_feature_names_out)`;
    return this._py`res_MiniBatchNMF_get_feature_names_out.tolist() if hasattr(res_MiniBatchNMF_get_feature_names_out, 'tolist') else res_MiniBatchNMF_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchNMF must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MiniBatchNMF_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MiniBatchNMF_get_metadata_routing = {k: v for k, v in pms_MiniBatchNMF_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MiniBatchNMF_get_metadata_routing = bridgeMiniBatchNMF[${this.id}].get_metadata_routing(**pms_MiniBatchNMF_get_metadata_routing)`;
    return this._py`res_MiniBatchNMF_get_metadata_routing.tolist() if hasattr(res_MiniBatchNMF_get_metadata_routing, 'tolist') else res_MiniBatchNMF_get_metadata_routing`;
  }
  /**
    Transform data back to its original space.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchNMF must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_MiniBatchNMF_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Xt': np.array(${opts["Xt"] ?? void 0}) if ${opts["Xt"] !== void 0} else None}

pms_MiniBatchNMF_inverse_transform = {k: v for k, v in pms_MiniBatchNMF_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchNMF_inverse_transform = bridgeMiniBatchNMF[${this.id}].inverse_transform(**pms_MiniBatchNMF_inverse_transform)`;
    return this._py`res_MiniBatchNMF_inverse_transform.tolist() if hasattr(res_MiniBatchNMF_inverse_transform, 'tolist') else res_MiniBatchNMF_inverse_transform`;
  }
  /**
      Update the model using the data in `X` as a mini-batch.
  
      This method is expected to be called several times consecutively on different chunks of a dataset so as to implement out-of-core or online learning.
  
      This is especially useful when the whole dataset is too big to fit in memory at once (see [Strategies to scale computationally: bigger data](https://scikit-learn.org/stable/modules/generated/../../computing/scaling_strategies.html#scaling-strategies)).
     */
  async partial_fit(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchNMF must call init() before partial_fit()");
    }
    await this._py.ex`pms_MiniBatchNMF_partial_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'W': np.array(${opts["W"] ?? void 0}) if ${opts["W"] !== void 0} else None, 'H': np.array(${opts["H"] ?? void 0}) if ${opts["H"] !== void 0} else None}

pms_MiniBatchNMF_partial_fit = {k: v for k, v in pms_MiniBatchNMF_partial_fit.items() if v is not None}`;
    await this._py.ex`res_MiniBatchNMF_partial_fit = bridgeMiniBatchNMF[${this.id}].partial_fit(**pms_MiniBatchNMF_partial_fit)`;
    return this._py`res_MiniBatchNMF_partial_fit.tolist() if hasattr(res_MiniBatchNMF_partial_fit, 'tolist') else res_MiniBatchNMF_partial_fit`;
  }
  /**
      Set output container.
  
      See [Introducing the set_output API](https://scikit-learn.org/stable/modules/generated/../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchNMF must call init() before set_output()");
    }
    await this._py.ex`pms_MiniBatchNMF_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_MiniBatchNMF_set_output = {k: v for k, v in pms_MiniBatchNMF_set_output.items() if v is not None}`;
    await this._py.ex`res_MiniBatchNMF_set_output = bridgeMiniBatchNMF[${this.id}].set_output(**pms_MiniBatchNMF_set_output)`;
    return this._py`res_MiniBatchNMF_set_output.tolist() if hasattr(res_MiniBatchNMF_set_output, 'tolist') else res_MiniBatchNMF_set_output`;
  }
  /**
    Transform the data X according to the fitted MiniBatchNMF model.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchNMF must call init() before transform()");
    }
    await this._py.ex`pms_MiniBatchNMF_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MiniBatchNMF_transform = {k: v for k, v in pms_MiniBatchNMF_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchNMF_transform = bridgeMiniBatchNMF[${this.id}].transform(**pms_MiniBatchNMF_transform)`;
    return this._py`res_MiniBatchNMF_transform.tolist() if hasattr(res_MiniBatchNMF_transform, 'tolist') else res_MiniBatchNMF_transform`;
  }
  /**
    Factorization matrix, sometimes called ‘dictionary’.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchNMF must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchNMF_components_ = bridgeMiniBatchNMF[${this.id}].components_`;
      return this._py`attr_MiniBatchNMF_components_.tolist() if hasattr(attr_MiniBatchNMF_components_, 'tolist') else attr_MiniBatchNMF_components_`;
    })();
  }
  /**
    The number of components. It is same as the `n_components` parameter if it was given. Otherwise, it will be same as the number of features.
   */
  get n_components_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchNMF must call init() before accessing n_components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchNMF_n_components_ = bridgeMiniBatchNMF[${this.id}].n_components_`;
      return this._py`attr_MiniBatchNMF_n_components_.tolist() if hasattr(attr_MiniBatchNMF_n_components_, 'tolist') else attr_MiniBatchNMF_n_components_`;
    })();
  }
  /**
    Frobenius norm of the matrix difference, or beta-divergence, between the training data `X` and the reconstructed data `WH` from the fitted model.
   */
  get reconstruction_err_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchNMF must call init() before accessing reconstruction_err_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchNMF_reconstruction_err_ = bridgeMiniBatchNMF[${this.id}].reconstruction_err_`;
      return this._py`attr_MiniBatchNMF_reconstruction_err_.tolist() if hasattr(attr_MiniBatchNMF_reconstruction_err_, 'tolist') else attr_MiniBatchNMF_reconstruction_err_`;
    })();
  }
  /**
    Actual number of started iterations over the whole dataset.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchNMF must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchNMF_n_iter_ = bridgeMiniBatchNMF[${this.id}].n_iter_`;
      return this._py`attr_MiniBatchNMF_n_iter_.tolist() if hasattr(attr_MiniBatchNMF_n_iter_, 'tolist') else attr_MiniBatchNMF_n_iter_`;
    })();
  }
  /**
    Number of mini-batches processed.
   */
  get n_steps_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchNMF must call init() before accessing n_steps_");
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchNMF_n_steps_ = bridgeMiniBatchNMF[${this.id}].n_steps_`;
      return this._py`attr_MiniBatchNMF_n_steps_.tolist() if hasattr(attr_MiniBatchNMF_n_steps_, 'tolist') else attr_MiniBatchNMF_n_steps_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchNMF must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchNMF_n_features_in_ = bridgeMiniBatchNMF[${this.id}].n_features_in_`;
      return this._py`attr_MiniBatchNMF_n_features_in_.tolist() if hasattr(attr_MiniBatchNMF_n_features_in_, 'tolist') else attr_MiniBatchNMF_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This MiniBatchNMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchNMF must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchNMF_feature_names_in_ = bridgeMiniBatchNMF[${this.id}].feature_names_in_`;
      return this._py`attr_MiniBatchNMF_feature_names_in_.tolist() if hasattr(attr_MiniBatchNMF_feature_names_in_, 'tolist') else attr_MiniBatchNMF_feature_names_in_`;
    })();
  }
};

// src/generated/decomposition/MiniBatchSparsePCA.ts
import crypto39 from "node:crypto";
var MiniBatchSparsePCA = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `MiniBatchSparsePCA${crypto39.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "MiniBatchSparsePCA.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import MiniBatchSparsePCA
try: bridgeMiniBatchSparsePCA
except NameError: bridgeMiniBatchSparsePCA = {}
`;
    await this._py.ex`ctor_MiniBatchSparsePCA = {'n_components': ${this.opts["n_components"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'ridge_alpha': ${this.opts["ridge_alpha"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'callback': ${this.opts["callback"] ?? void 0}, 'batch_size': ${this.opts["batch_size"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'shuffle': ${this.opts["shuffle"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'method': ${this.opts["method"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'max_no_improvement': ${this.opts["max_no_improvement"] ?? void 0}}

ctor_MiniBatchSparsePCA = {k: v for k, v in ctor_MiniBatchSparsePCA.items() if v is not None}`;
    await this._py.ex`bridgeMiniBatchSparsePCA[${this.id}] = MiniBatchSparsePCA(**ctor_MiniBatchSparsePCA)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeMiniBatchSparsePCA[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model from data in X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchSparsePCA must call init() before fit()");
    }
    await this._py.ex`pms_MiniBatchSparsePCA_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_MiniBatchSparsePCA_fit = {k: v for k, v in pms_MiniBatchSparsePCA_fit.items() if v is not None}`;
    await this._py.ex`res_MiniBatchSparsePCA_fit = bridgeMiniBatchSparsePCA[${this.id}].fit(**pms_MiniBatchSparsePCA_fit)`;
    return this._py`res_MiniBatchSparsePCA_fit.tolist() if hasattr(res_MiniBatchSparsePCA_fit, 'tolist') else res_MiniBatchSparsePCA_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_MiniBatchSparsePCA_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_MiniBatchSparsePCA_fit_transform = {k: v for k, v in pms_MiniBatchSparsePCA_fit_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchSparsePCA_fit_transform = bridgeMiniBatchSparsePCA[${this.id}].fit_transform(**pms_MiniBatchSparsePCA_fit_transform)`;
    return this._py`res_MiniBatchSparsePCA_fit_transform.tolist() if hasattr(res_MiniBatchSparsePCA_fit_transform, 'tolist') else res_MiniBatchSparsePCA_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class_name0", "class_name1", "class_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_MiniBatchSparsePCA_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_MiniBatchSparsePCA_get_feature_names_out = {k: v for k, v in pms_MiniBatchSparsePCA_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_MiniBatchSparsePCA_get_feature_names_out = bridgeMiniBatchSparsePCA[${this.id}].get_feature_names_out(**pms_MiniBatchSparsePCA_get_feature_names_out)`;
    return this._py`res_MiniBatchSparsePCA_get_feature_names_out.tolist() if hasattr(res_MiniBatchSparsePCA_get_feature_names_out, 'tolist') else res_MiniBatchSparsePCA_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_MiniBatchSparsePCA_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_MiniBatchSparsePCA_get_metadata_routing = {k: v for k, v in pms_MiniBatchSparsePCA_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_MiniBatchSparsePCA_get_metadata_routing = bridgeMiniBatchSparsePCA[${this.id}].get_metadata_routing(**pms_MiniBatchSparsePCA_get_metadata_routing)`;
    return this._py`res_MiniBatchSparsePCA_get_metadata_routing.tolist() if hasattr(res_MiniBatchSparsePCA_get_metadata_routing, 'tolist') else res_MiniBatchSparsePCA_get_metadata_routing`;
  }
  /**
      Transform data from the latent space to the original space.
  
      This inversion is an approximation due to the loss of information induced by the forward decomposition.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_MiniBatchSparsePCA_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MiniBatchSparsePCA_inverse_transform = {k: v for k, v in pms_MiniBatchSparsePCA_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchSparsePCA_inverse_transform = bridgeMiniBatchSparsePCA[${this.id}].inverse_transform(**pms_MiniBatchSparsePCA_inverse_transform)`;
    return this._py`res_MiniBatchSparsePCA_inverse_transform.tolist() if hasattr(res_MiniBatchSparsePCA_inverse_transform, 'tolist') else res_MiniBatchSparsePCA_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set_output API](https://scikit-learn.org/stable/modules/generated/../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchSparsePCA must call init() before set_output()");
    }
    await this._py.ex`pms_MiniBatchSparsePCA_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_MiniBatchSparsePCA_set_output = {k: v for k, v in pms_MiniBatchSparsePCA_set_output.items() if v is not None}`;
    await this._py.ex`res_MiniBatchSparsePCA_set_output = bridgeMiniBatchSparsePCA[${this.id}].set_output(**pms_MiniBatchSparsePCA_set_output)`;
    return this._py`res_MiniBatchSparsePCA_set_output.tolist() if hasattr(res_MiniBatchSparsePCA_set_output, 'tolist') else res_MiniBatchSparsePCA_set_output`;
  }
  /**
      Least Squares projection of the data onto the sparse components.
  
      To avoid instability issues in case the system is under-determined, regularization can be applied (Ridge regression) via the `ridge_alpha` parameter.
  
      Note that Sparse PCA components orthogonality is not enforced as in PCA hence one cannot use a simple linear projection.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("MiniBatchSparsePCA must call init() before transform()");
    }
    await this._py.ex`pms_MiniBatchSparsePCA_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_MiniBatchSparsePCA_transform = {k: v for k, v in pms_MiniBatchSparsePCA_transform.items() if v is not None}`;
    await this._py.ex`res_MiniBatchSparsePCA_transform = bridgeMiniBatchSparsePCA[${this.id}].transform(**pms_MiniBatchSparsePCA_transform)`;
    return this._py`res_MiniBatchSparsePCA_transform.tolist() if hasattr(res_MiniBatchSparsePCA_transform, 'tolist') else res_MiniBatchSparsePCA_transform`;
  }
  /**
    Sparse components extracted from the data.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchSparsePCA_components_ = bridgeMiniBatchSparsePCA[${this.id}].components_`;
      return this._py`attr_MiniBatchSparsePCA_components_.tolist() if hasattr(attr_MiniBatchSparsePCA_components_, 'tolist') else attr_MiniBatchSparsePCA_components_`;
    })();
  }
  /**
    Estimated number of components.
   */
  get n_components_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before accessing n_components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchSparsePCA_n_components_ = bridgeMiniBatchSparsePCA[${this.id}].n_components_`;
      return this._py`attr_MiniBatchSparsePCA_n_components_.tolist() if hasattr(attr_MiniBatchSparsePCA_n_components_, 'tolist') else attr_MiniBatchSparsePCA_n_components_`;
    })();
  }
  /**
    Number of iterations run.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before accessing n_iter_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchSparsePCA_n_iter_ = bridgeMiniBatchSparsePCA[${this.id}].n_iter_`;
      return this._py`attr_MiniBatchSparsePCA_n_iter_.tolist() if hasattr(attr_MiniBatchSparsePCA_n_iter_, 'tolist') else attr_MiniBatchSparsePCA_n_iter_`;
    })();
  }
  /**
    Per-feature empirical mean, estimated from the training set. Equal to `X.mean(axis=0)`.
   */
  get mean_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before accessing mean_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchSparsePCA_mean_ = bridgeMiniBatchSparsePCA[${this.id}].mean_`;
      return this._py`attr_MiniBatchSparsePCA_mean_.tolist() if hasattr(attr_MiniBatchSparsePCA_mean_, 'tolist') else attr_MiniBatchSparsePCA_mean_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchSparsePCA_n_features_in_ = bridgeMiniBatchSparsePCA[${this.id}].n_features_in_`;
      return this._py`attr_MiniBatchSparsePCA_n_features_in_.tolist() if hasattr(attr_MiniBatchSparsePCA_n_features_in_, 'tolist') else attr_MiniBatchSparsePCA_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This MiniBatchSparsePCA instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "MiniBatchSparsePCA must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_MiniBatchSparsePCA_feature_names_in_ = bridgeMiniBatchSparsePCA[${this.id}].feature_names_in_`;
      return this._py`attr_MiniBatchSparsePCA_feature_names_in_.tolist() if hasattr(attr_MiniBatchSparsePCA_feature_names_in_, 'tolist') else attr_MiniBatchSparsePCA_feature_names_in_`;
    })();
  }
};

// src/generated/decomposition/NMF.ts
import crypto40 from "node:crypto";
var NMF = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `NMF${crypto40.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("NMF.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import NMF
try: bridgeNMF
except NameError: bridgeNMF = {}
`;
    await this._py.ex`ctor_NMF = {'n_components': ${this.opts["n_components"] ?? void 0}, 'init': ${this.opts["init"] ?? void 0}, 'solver': ${this.opts["solver"] ?? void 0}, 'beta_loss': ${this.opts["beta_loss"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'alpha_W': ${this.opts["alpha_W"] ?? void 0}, 'alpha_H': ${this.opts["alpha_H"] ?? void 0}, 'l1_ratio': ${this.opts["l1_ratio"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'shuffle': ${this.opts["shuffle"] ?? void 0}}

ctor_NMF = {k: v for k, v in ctor_NMF.items() if v is not None}`;
    await this._py.ex`bridgeNMF[${this.id}] = NMF(**ctor_NMF)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeNMF[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Learn a NMF model for the data X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before fit()");
    }
    await this._py.ex`pms_NMF_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'params': ${opts["params"] ?? void 0}}

pms_NMF_fit = {k: v for k, v in pms_NMF_fit.items() if v is not None}`;
    await this._py.ex`res_NMF_fit = bridgeNMF[${this.id}].fit(**pms_NMF_fit)`;
    return this._py`res_NMF_fit.tolist() if hasattr(res_NMF_fit, 'tolist') else res_NMF_fit`;
  }
  /**
      Learn a NMF model for the data X and returns the transformed data.
  
      This is more efficient than calling fit followed by transform.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before fit_transform()");
    }
    await this._py.ex`pms_NMF_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'W': np.array(${opts["W"] ?? void 0}) if ${opts["W"] !== void 0} else None, 'H': np.array(${opts["H"] ?? void 0}) if ${opts["H"] !== void 0} else None}

pms_NMF_fit_transform = {k: v for k, v in pms_NMF_fit_transform.items() if v is not None}`;
    await this._py.ex`res_NMF_fit_transform = bridgeNMF[${this.id}].fit_transform(**pms_NMF_fit_transform)`;
    return this._py`res_NMF_fit_transform.tolist() if hasattr(res_NMF_fit_transform, 'tolist') else res_NMF_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class_name0", "class_name1", "class_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before get_feature_names_out()");
    }
    await this._py.ex`pms_NMF_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_NMF_get_feature_names_out = {k: v for k, v in pms_NMF_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_NMF_get_feature_names_out = bridgeNMF[${this.id}].get_feature_names_out(**pms_NMF_get_feature_names_out)`;
    return this._py`res_NMF_get_feature_names_out.tolist() if hasattr(res_NMF_get_feature_names_out, 'tolist') else res_NMF_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_NMF_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_NMF_get_metadata_routing = {k: v for k, v in pms_NMF_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_NMF_get_metadata_routing = bridgeNMF[${this.id}].get_metadata_routing(**pms_NMF_get_metadata_routing)`;
    return this._py`res_NMF_get_metadata_routing.tolist() if hasattr(res_NMF_get_metadata_routing, 'tolist') else res_NMF_get_metadata_routing`;
  }
  /**
    Transform data back to its original space.
   */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before inverse_transform()");
    }
    await this._py.ex`pms_NMF_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'Xt': np.array(${opts["Xt"] ?? void 0}) if ${opts["Xt"] !== void 0} else None}

pms_NMF_inverse_transform = {k: v for k, v in pms_NMF_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_NMF_inverse_transform = bridgeNMF[${this.id}].inverse_transform(**pms_NMF_inverse_transform)`;
    return this._py`res_NMF_inverse_transform.tolist() if hasattr(res_NMF_inverse_transform, 'tolist') else res_NMF_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set_output API](https://scikit-learn.org/stable/modules/generated/../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before set_output()");
    }
    await this._py.ex`pms_NMF_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_NMF_set_output = {k: v for k, v in pms_NMF_set_output.items() if v is not None}`;
    await this._py.ex`res_NMF_set_output = bridgeNMF[${this.id}].set_output(**pms_NMF_set_output)`;
    return this._py`res_NMF_set_output.tolist() if hasattr(res_NMF_set_output, 'tolist') else res_NMF_set_output`;
  }
  /**
    Transform the data X according to the fitted NMF model.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before transform()");
    }
    await this._py.ex`pms_NMF_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_NMF_transform = {k: v for k, v in pms_NMF_transform.items() if v is not None}`;
    await this._py.ex`res_NMF_transform = bridgeNMF[${this.id}].transform(**pms_NMF_transform)`;
    return this._py`res_NMF_transform.tolist() if hasattr(res_NMF_transform, 'tolist') else res_NMF_transform`;
  }
  /**
    Factorization matrix, sometimes called ‘dictionary’.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before accessing components_");
    }
    return (async () => {
      await this._py.ex`attr_NMF_components_ = bridgeNMF[${this.id}].components_`;
      return this._py`attr_NMF_components_.tolist() if hasattr(attr_NMF_components_, 'tolist') else attr_NMF_components_`;
    })();
  }
  /**
    The number of components. It is same as the `n_components` parameter if it was given. Otherwise, it will be same as the number of features.
   */
  get n_components_() {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before accessing n_components_");
    }
    return (async () => {
      await this._py.ex`attr_NMF_n_components_ = bridgeNMF[${this.id}].n_components_`;
      return this._py`attr_NMF_n_components_.tolist() if hasattr(attr_NMF_n_components_, 'tolist') else attr_NMF_n_components_`;
    })();
  }
  /**
    Frobenius norm of the matrix difference, or beta-divergence, between the training data `X` and the reconstructed data `WH` from the fitted model.
   */
  get reconstruction_err_() {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "NMF must call init() before accessing reconstruction_err_"
      );
    }
    return (async () => {
      await this._py.ex`attr_NMF_reconstruction_err_ = bridgeNMF[${this.id}].reconstruction_err_`;
      return this._py`attr_NMF_reconstruction_err_.tolist() if hasattr(attr_NMF_reconstruction_err_, 'tolist') else attr_NMF_reconstruction_err_`;
    })();
  }
  /**
    Actual number of iterations.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_NMF_n_iter_ = bridgeNMF[${this.id}].n_iter_`;
      return this._py`attr_NMF_n_iter_.tolist() if hasattr(attr_NMF_n_iter_, 'tolist') else attr_NMF_n_iter_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_NMF_n_features_in_ = bridgeNMF[${this.id}].n_features_in_`;
      return this._py`attr_NMF_n_features_in_.tolist() if hasattr(attr_NMF_n_features_in_, 'tolist') else attr_NMF_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This NMF instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("NMF must call init() before accessing feature_names_in_");
    }
    return (async () => {
      await this._py.ex`attr_NMF_feature_names_in_ = bridgeNMF[${this.id}].feature_names_in_`;
      return this._py`attr_NMF_feature_names_in_.tolist() if hasattr(attr_NMF_feature_names_in_, 'tolist') else attr_NMF_feature_names_in_`;
    })();
  }
};

// src/generated/decomposition/PCA.ts
import crypto41 from "node:crypto";
var PCA = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `PCA${crypto41.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("PCA.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import PCA
try: bridgePCA
except NameError: bridgePCA = {}
`;
    await this._py.ex`ctor_PCA = {'n_components': ${this.opts["n_components"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}, 'whiten': ${this.opts["whiten"] ?? void 0}, 'svd_solver': ${this.opts["svd_solver"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'iterated_power': ${this.opts["iterated_power"] ?? void 0}, 'n_oversamples': ${this.opts["n_oversamples"] ?? void 0}, 'power_iteration_normalizer': ${this.opts["power_iteration_normalizer"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_PCA = {k: v for k, v in ctor_PCA.items() if v is not None}`;
    await this._py.ex`bridgePCA[${this.id}] = PCA(**ctor_PCA)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgePCA[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model with X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before fit()");
    }
    await this._py.ex`pms_PCA_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_PCA_fit = {k: v for k, v in pms_PCA_fit.items() if v is not None}`;
    await this._py.ex`res_PCA_fit = bridgePCA[${this.id}].fit(**pms_PCA_fit)`;
    return this._py`res_PCA_fit.tolist() if hasattr(res_PCA_fit, 'tolist') else res_PCA_fit`;
  }
  /**
    Fit the model with X and apply the dimensionality reduction on X.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before fit_transform()");
    }
    await this._py.ex`pms_PCA_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_PCA_fit_transform = {k: v for k, v in pms_PCA_fit_transform.items() if v is not None}`;
    await this._py.ex`res_PCA_fit_transform = bridgePCA[${this.id}].fit_transform(**pms_PCA_fit_transform)`;
    return this._py`res_PCA_fit_transform.tolist() if hasattr(res_PCA_fit_transform, 'tolist') else res_PCA_fit_transform`;
  }
  /**
      Compute data covariance with the generative model.
  
      `cov \= components_.T \* S\*\*2 \* components_ + sigma2 \* eye(n_features)` where S\*\*2 contains the explained variances, and sigma2 contains the noise variances.
     */
  async get_covariance(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before get_covariance()");
    }
    await this._py.ex`pms_PCA_get_covariance = {'cov': np.array(${opts["cov"] ?? void 0}) if ${opts["cov"] !== void 0} else None}

pms_PCA_get_covariance = {k: v for k, v in pms_PCA_get_covariance.items() if v is not None}`;
    await this._py.ex`res_PCA_get_covariance = bridgePCA[${this.id}].get_covariance(**pms_PCA_get_covariance)`;
    return this._py`res_PCA_get_covariance.tolist() if hasattr(res_PCA_get_covariance, 'tolist') else res_PCA_get_covariance`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class_name0", "class_name1", "class_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before get_feature_names_out()");
    }
    await this._py.ex`pms_PCA_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_PCA_get_feature_names_out = {k: v for k, v in pms_PCA_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_PCA_get_feature_names_out = bridgePCA[${this.id}].get_feature_names_out(**pms_PCA_get_feature_names_out)`;
    return this._py`res_PCA_get_feature_names_out.tolist() if hasattr(res_PCA_get_feature_names_out, 'tolist') else res_PCA_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_PCA_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_PCA_get_metadata_routing = {k: v for k, v in pms_PCA_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_PCA_get_metadata_routing = bridgePCA[${this.id}].get_metadata_routing(**pms_PCA_get_metadata_routing)`;
    return this._py`res_PCA_get_metadata_routing.tolist() if hasattr(res_PCA_get_metadata_routing, 'tolist') else res_PCA_get_metadata_routing`;
  }
  /**
      Compute data precision matrix with the generative model.
  
      Equals the inverse of the covariance but computed with the matrix inversion lemma for efficiency.
     */
  async get_precision(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before get_precision()");
    }
    await this._py.ex`pms_PCA_get_precision = {'precision': ${opts["precision"] ?? void 0}}

pms_PCA_get_precision = {k: v for k, v in pms_PCA_get_precision.items() if v is not None}`;
    await this._py.ex`res_PCA_get_precision = bridgePCA[${this.id}].get_precision(**pms_PCA_get_precision)`;
    return this._py`res_PCA_get_precision.tolist() if hasattr(res_PCA_get_precision, 'tolist') else res_PCA_get_precision`;
  }
  /**
      Transform data back to its original space.
  
      In other words, return an input `X_original` whose transform would be X.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before inverse_transform()");
    }
    await this._py.ex`pms_PCA_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_PCA_inverse_transform = {k: v for k, v in pms_PCA_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_PCA_inverse_transform = bridgePCA[${this.id}].inverse_transform(**pms_PCA_inverse_transform)`;
    return this._py`res_PCA_inverse_transform.tolist() if hasattr(res_PCA_inverse_transform, 'tolist') else res_PCA_inverse_transform`;
  }
  /**
      Return the average log-likelihood of all samples.
  
      See. “Pattern Recognition and Machine Learning” by C. Bishop, 12.2.1 p. 574 or [http://www.miketipping.com/papers/met-mppca.pdf](http://www.miketipping.com/papers/met-mppca.pdf)
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before score()");
    }
    await this._py.ex`pms_PCA_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_PCA_score = {k: v for k, v in pms_PCA_score.items() if v is not None}`;
    await this._py.ex`res_PCA_score = bridgePCA[${this.id}].score(**pms_PCA_score)`;
    return this._py`res_PCA_score.tolist() if hasattr(res_PCA_score, 'tolist') else res_PCA_score`;
  }
  /**
      Return the log-likelihood of each sample.
  
      See. “Pattern Recognition and Machine Learning” by C. Bishop, 12.2.1 p. 574 or [http://www.miketipping.com/papers/met-mppca.pdf](http://www.miketipping.com/papers/met-mppca.pdf)
     */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before score_samples()");
    }
    await this._py.ex`pms_PCA_score_samples = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_PCA_score_samples = {k: v for k, v in pms_PCA_score_samples.items() if v is not None}`;
    await this._py.ex`res_PCA_score_samples = bridgePCA[${this.id}].score_samples(**pms_PCA_score_samples)`;
    return this._py`res_PCA_score_samples.tolist() if hasattr(res_PCA_score_samples, 'tolist') else res_PCA_score_samples`;
  }
  /**
      Set output container.
  
      See [Introducing the set_output API](https://scikit-learn.org/stable/modules/generated/../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before set_output()");
    }
    await this._py.ex`pms_PCA_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_PCA_set_output = {k: v for k, v in pms_PCA_set_output.items() if v is not None}`;
    await this._py.ex`res_PCA_set_output = bridgePCA[${this.id}].set_output(**pms_PCA_set_output)`;
    return this._py`res_PCA_set_output.tolist() if hasattr(res_PCA_set_output, 'tolist') else res_PCA_set_output`;
  }
  /**
      Apply dimensionality reduction to X.
  
      X is projected on the first principal components previously extracted from a training set.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before transform()");
    }
    await this._py.ex`pms_PCA_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_PCA_transform = {k: v for k, v in pms_PCA_transform.items() if v is not None}`;
    await this._py.ex`res_PCA_transform = bridgePCA[${this.id}].transform(**pms_PCA_transform)`;
    return this._py`res_PCA_transform.tolist() if hasattr(res_PCA_transform, 'tolist') else res_PCA_transform`;
  }
  /**
    Principal axes in feature space, representing the directions of maximum variance in the data. Equivalently, the right singular vectors of the centered input data, parallel to its eigenvectors. The components are sorted by decreasing `explained_variance_`.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before accessing components_");
    }
    return (async () => {
      await this._py.ex`attr_PCA_components_ = bridgePCA[${this.id}].components_`;
      return this._py`attr_PCA_components_.tolist() if hasattr(attr_PCA_components_, 'tolist') else attr_PCA_components_`;
    })();
  }
  /**
      The amount of variance explained by each of the selected components. The variance estimation uses `n_samples \- 1` degrees of freedom.
  
      Equal to n_components largest eigenvalues of the covariance matrix of X.
     */
  get explained_variance_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PCA must call init() before accessing explained_variance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PCA_explained_variance_ = bridgePCA[${this.id}].explained_variance_`;
      return this._py`attr_PCA_explained_variance_.tolist() if hasattr(attr_PCA_explained_variance_, 'tolist') else attr_PCA_explained_variance_`;
    })();
  }
  /**
      Percentage of variance explained by each of the selected components.
  
      If `n_components` is not set then all components are stored and the sum of the ratios is equal to 1.0.
     */
  get explained_variance_ratio_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "PCA must call init() before accessing explained_variance_ratio_"
      );
    }
    return (async () => {
      await this._py.ex`attr_PCA_explained_variance_ratio_ = bridgePCA[${this.id}].explained_variance_ratio_`;
      return this._py`attr_PCA_explained_variance_ratio_.tolist() if hasattr(attr_PCA_explained_variance_ratio_, 'tolist') else attr_PCA_explained_variance_ratio_`;
    })();
  }
  /**
    The singular values corresponding to each of the selected components. The singular values are equal to the 2-norms of the `n_components` variables in the lower-dimensional space.
   */
  get singular_values_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before accessing singular_values_");
    }
    return (async () => {
      await this._py.ex`attr_PCA_singular_values_ = bridgePCA[${this.id}].singular_values_`;
      return this._py`attr_PCA_singular_values_.tolist() if hasattr(attr_PCA_singular_values_, 'tolist') else attr_PCA_singular_values_`;
    })();
  }
  /**
      Per-feature empirical mean, estimated from the training set.
  
      Equal to `X.mean(axis=0)`.
     */
  get mean_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before accessing mean_");
    }
    return (async () => {
      await this._py.ex`attr_PCA_mean_ = bridgePCA[${this.id}].mean_`;
      return this._py`attr_PCA_mean_.tolist() if hasattr(attr_PCA_mean_, 'tolist') else attr_PCA_mean_`;
    })();
  }
  /**
    The estimated number of components. When n_components is set to ‘mle’ or a number between 0 and 1 (with svd_solver == ‘full’) this number is estimated from input data. Otherwise it equals the parameter n_components, or the lesser value of n_features and n_samples if n_components is `undefined`.
   */
  get n_components_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before accessing n_components_");
    }
    return (async () => {
      await this._py.ex`attr_PCA_n_components_ = bridgePCA[${this.id}].n_components_`;
      return this._py`attr_PCA_n_components_.tolist() if hasattr(attr_PCA_n_components_, 'tolist') else attr_PCA_n_components_`;
    })();
  }
  /**
    Number of samples in the training data.
   */
  get n_samples_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before accessing n_samples_");
    }
    return (async () => {
      await this._py.ex`attr_PCA_n_samples_ = bridgePCA[${this.id}].n_samples_`;
      return this._py`attr_PCA_n_samples_.tolist() if hasattr(attr_PCA_n_samples_, 'tolist') else attr_PCA_n_samples_`;
    })();
  }
  /**
      The estimated noise covariance following the Probabilistic PCA model from Tipping and Bishop 1999. See “Pattern Recognition and Machine Learning” by C. Bishop, 12.2.1 p. 574 or [http://www.miketipping.com/papers/met-mppca.pdf](http://www.miketipping.com/papers/met-mppca.pdf). It is required to compute the estimated data covariance and score samples.
  
      Equal to the average of (min(n_features, n_samples) - n_components) smallest eigenvalues of the covariance matrix of X.
     */
  get noise_variance_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before accessing noise_variance_");
    }
    return (async () => {
      await this._py.ex`attr_PCA_noise_variance_ = bridgePCA[${this.id}].noise_variance_`;
      return this._py`attr_PCA_noise_variance_.tolist() if hasattr(attr_PCA_noise_variance_, 'tolist') else attr_PCA_noise_variance_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before accessing n_features_in_");
    }
    return (async () => {
      await this._py.ex`attr_PCA_n_features_in_ = bridgePCA[${this.id}].n_features_in_`;
      return this._py`attr_PCA_n_features_in_.tolist() if hasattr(attr_PCA_n_features_in_, 'tolist') else attr_PCA_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This PCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("PCA must call init() before accessing feature_names_in_");
    }
    return (async () => {
      await this._py.ex`attr_PCA_feature_names_in_ = bridgePCA[${this.id}].feature_names_in_`;
      return this._py`attr_PCA_feature_names_in_.tolist() if hasattr(attr_PCA_feature_names_in_, 'tolist') else attr_PCA_feature_names_in_`;
    })();
  }
};

// src/generated/decomposition/SparseCoder.ts
import crypto42 from "node:crypto";
var SparseCoder = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `SparseCoder${crypto42.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SparseCoder instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SparseCoder.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import SparseCoder
try: bridgeSparseCoder
except NameError: bridgeSparseCoder = {}
`;
    await this._py.ex`ctor_SparseCoder = {'dictionary': np.array(${this.opts["dictionary"] ?? void 0}) if ${this.opts["dictionary"] !== void 0} else None, 'transform_algorithm': ${this.opts["transform_algorithm"] ?? void 0}, 'transform_n_nonzero_coefs': ${this.opts["transform_n_nonzero_coefs"] ?? void 0}, 'transform_alpha': ${this.opts["transform_alpha"] ?? void 0}, 'split_sign': ${this.opts["split_sign"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'positive_code': ${this.opts["positive_code"] ?? void 0}, 'transform_max_iter': ${this.opts["transform_max_iter"] ?? void 0}}

ctor_SparseCoder = {k: v for k, v in ctor_SparseCoder.items() if v is not None}`;
    await this._py.ex`bridgeSparseCoder[${this.id}] = SparseCoder(**ctor_SparseCoder)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSparseCoder[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Do nothing and return the estimator unchanged.
  
      This method is just there to implement the usual API and hence work in pipelines.
     */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SparseCoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparseCoder must call init() before fit()");
    }
    await this._py.ex`pms_SparseCoder_fit = {'X': ${opts["X"] ?? void 0}, 'y': ${opts["y"] ?? void 0}}

pms_SparseCoder_fit = {k: v for k, v in pms_SparseCoder_fit.items() if v is not None}`;
    await this._py.ex`res_SparseCoder_fit = bridgeSparseCoder[${this.id}].fit(**pms_SparseCoder_fit)`;
    return this._py`res_SparseCoder_fit.tolist() if hasattr(res_SparseCoder_fit, 'tolist') else res_SparseCoder_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SparseCoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparseCoder must call init() before fit_transform()");
    }
    await this._py.ex`pms_SparseCoder_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SparseCoder_fit_transform = {k: v for k, v in pms_SparseCoder_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SparseCoder_fit_transform = bridgeSparseCoder[${this.id}].fit_transform(**pms_SparseCoder_fit_transform)`;
    return this._py`res_SparseCoder_fit_transform.tolist() if hasattr(res_SparseCoder_fit_transform, 'tolist') else res_SparseCoder_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class_name0", "class_name1", "class_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This SparseCoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparseCoder must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_SparseCoder_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_SparseCoder_get_feature_names_out = {k: v for k, v in pms_SparseCoder_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_SparseCoder_get_feature_names_out = bridgeSparseCoder[${this.id}].get_feature_names_out(**pms_SparseCoder_get_feature_names_out)`;
    return this._py`res_SparseCoder_get_feature_names_out.tolist() if hasattr(res_SparseCoder_get_feature_names_out, 'tolist') else res_SparseCoder_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This SparseCoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparseCoder must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SparseCoder_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SparseCoder_get_metadata_routing = {k: v for k, v in pms_SparseCoder_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SparseCoder_get_metadata_routing = bridgeSparseCoder[${this.id}].get_metadata_routing(**pms_SparseCoder_get_metadata_routing)`;
    return this._py`res_SparseCoder_get_metadata_routing.tolist() if hasattr(res_SparseCoder_get_metadata_routing, 'tolist') else res_SparseCoder_get_metadata_routing`;
  }
  /**
      Set output container.
  
      See [Introducing the set_output API](https://scikit-learn.org/stable/modules/generated/../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This SparseCoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparseCoder must call init() before set_output()");
    }
    await this._py.ex`pms_SparseCoder_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_SparseCoder_set_output = {k: v for k, v in pms_SparseCoder_set_output.items() if v is not None}`;
    await this._py.ex`res_SparseCoder_set_output = bridgeSparseCoder[${this.id}].set_output(**pms_SparseCoder_set_output)`;
    return this._py`res_SparseCoder_set_output.tolist() if hasattr(res_SparseCoder_set_output, 'tolist') else res_SparseCoder_set_output`;
  }
  /**
      Encode the data as a sparse combination of the dictionary atoms.
  
      Coding method is determined by the object parameter `transform_algorithm`.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SparseCoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparseCoder must call init() before transform()");
    }
    await this._py.ex`pms_SparseCoder_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_SparseCoder_transform = {k: v for k, v in pms_SparseCoder_transform.items() if v is not None}`;
    await this._py.ex`res_SparseCoder_transform = bridgeSparseCoder[${this.id}].transform(**pms_SparseCoder_transform)`;
    return this._py`res_SparseCoder_transform.tolist() if hasattr(res_SparseCoder_transform, 'tolist') else res_SparseCoder_transform`;
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SparseCoder instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparseCoder must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SparseCoder_feature_names_in_ = bridgeSparseCoder[${this.id}].feature_names_in_`;
      return this._py`attr_SparseCoder_feature_names_in_.tolist() if hasattr(attr_SparseCoder_feature_names_in_, 'tolist') else attr_SparseCoder_feature_names_in_`;
    })();
  }
};

// src/generated/decomposition/SparsePCA.ts
import crypto43 from "node:crypto";
var SparsePCA = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `SparsePCA${crypto43.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("SparsePCA.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import SparsePCA
try: bridgeSparsePCA
except NameError: bridgeSparsePCA = {}
`;
    await this._py.ex`ctor_SparsePCA = {'n_components': ${this.opts["n_components"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'ridge_alpha': ${this.opts["ridge_alpha"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'method': ${this.opts["method"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'U_init': np.array(${this.opts["U_init"] ?? void 0}) if ${this.opts["U_init"] !== void 0} else None, 'V_init': np.array(${this.opts["V_init"] ?? void 0}) if ${this.opts["V_init"] !== void 0} else None, 'verbose': ${this.opts["verbose"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_SparsePCA = {k: v for k, v in ctor_SparsePCA.items() if v is not None}`;
    await this._py.ex`bridgeSparsePCA[${this.id}] = SparsePCA(**ctor_SparsePCA)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeSparsePCA[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the model from data in X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparsePCA must call init() before fit()");
    }
    await this._py.ex`pms_SparsePCA_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_SparsePCA_fit = {k: v for k, v in pms_SparsePCA_fit.items() if v is not None}`;
    await this._py.ex`res_SparsePCA_fit = bridgeSparsePCA[${this.id}].fit(**pms_SparsePCA_fit)`;
    return this._py`res_SparsePCA_fit.tolist() if hasattr(res_SparsePCA_fit, 'tolist') else res_SparsePCA_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparsePCA must call init() before fit_transform()");
    }
    await this._py.ex`pms_SparsePCA_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_SparsePCA_fit_transform = {k: v for k, v in pms_SparsePCA_fit_transform.items() if v is not None}`;
    await this._py.ex`res_SparsePCA_fit_transform = bridgeSparsePCA[${this.id}].fit_transform(**pms_SparsePCA_fit_transform)`;
    return this._py`res_SparsePCA_fit_transform.tolist() if hasattr(res_SparsePCA_fit_transform, 'tolist') else res_SparsePCA_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class_name0", "class_name1", "class_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparsePCA must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_SparsePCA_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_SparsePCA_get_feature_names_out = {k: v for k, v in pms_SparsePCA_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_SparsePCA_get_feature_names_out = bridgeSparsePCA[${this.id}].get_feature_names_out(**pms_SparsePCA_get_feature_names_out)`;
    return this._py`res_SparsePCA_get_feature_names_out.tolist() if hasattr(res_SparsePCA_get_feature_names_out, 'tolist') else res_SparsePCA_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparsePCA must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_SparsePCA_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_SparsePCA_get_metadata_routing = {k: v for k, v in pms_SparsePCA_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_SparsePCA_get_metadata_routing = bridgeSparsePCA[${this.id}].get_metadata_routing(**pms_SparsePCA_get_metadata_routing)`;
    return this._py`res_SparsePCA_get_metadata_routing.tolist() if hasattr(res_SparsePCA_get_metadata_routing, 'tolist') else res_SparsePCA_get_metadata_routing`;
  }
  /**
      Transform data from the latent space to the original space.
  
      This inversion is an approximation due to the loss of information induced by the forward decomposition.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparsePCA must call init() before inverse_transform()");
    }
    await this._py.ex`pms_SparsePCA_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SparsePCA_inverse_transform = {k: v for k, v in pms_SparsePCA_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_SparsePCA_inverse_transform = bridgeSparsePCA[${this.id}].inverse_transform(**pms_SparsePCA_inverse_transform)`;
    return this._py`res_SparsePCA_inverse_transform.tolist() if hasattr(res_SparsePCA_inverse_transform, 'tolist') else res_SparsePCA_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set_output API](https://scikit-learn.org/stable/modules/generated/../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparsePCA must call init() before set_output()");
    }
    await this._py.ex`pms_SparsePCA_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_SparsePCA_set_output = {k: v for k, v in pms_SparsePCA_set_output.items() if v is not None}`;
    await this._py.ex`res_SparsePCA_set_output = bridgeSparsePCA[${this.id}].set_output(**pms_SparsePCA_set_output)`;
    return this._py`res_SparsePCA_set_output.tolist() if hasattr(res_SparsePCA_set_output, 'tolist') else res_SparsePCA_set_output`;
  }
  /**
      Least Squares projection of the data onto the sparse components.
  
      To avoid instability issues in case the system is under-determined, regularization can be applied (Ridge regression) via the `ridge_alpha` parameter.
  
      Note that Sparse PCA components orthogonality is not enforced as in PCA hence one cannot use a simple linear projection.
     */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparsePCA must call init() before transform()");
    }
    await this._py.ex`pms_SparsePCA_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_SparsePCA_transform = {k: v for k, v in pms_SparsePCA_transform.items() if v is not None}`;
    await this._py.ex`res_SparsePCA_transform = bridgeSparsePCA[${this.id}].transform(**pms_SparsePCA_transform)`;
    return this._py`res_SparsePCA_transform.tolist() if hasattr(res_SparsePCA_transform, 'tolist') else res_SparsePCA_transform`;
  }
  /**
    Sparse components extracted from the data.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparsePCA must call init() before accessing components_");
    }
    return (async () => {
      await this._py.ex`attr_SparsePCA_components_ = bridgeSparsePCA[${this.id}].components_`;
      return this._py`attr_SparsePCA_components_.tolist() if hasattr(attr_SparsePCA_components_, 'tolist') else attr_SparsePCA_components_`;
    })();
  }
  /**
    Vector of errors at each iteration.
   */
  get error_() {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparsePCA must call init() before accessing error_");
    }
    return (async () => {
      await this._py.ex`attr_SparsePCA_error_ = bridgeSparsePCA[${this.id}].error_`;
      return this._py`attr_SparsePCA_error_.tolist() if hasattr(attr_SparsePCA_error_, 'tolist') else attr_SparsePCA_error_`;
    })();
  }
  /**
    Estimated number of components.
   */
  get n_components_() {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparsePCA must call init() before accessing n_components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SparsePCA_n_components_ = bridgeSparsePCA[${this.id}].n_components_`;
      return this._py`attr_SparsePCA_n_components_.tolist() if hasattr(attr_SparsePCA_n_components_, 'tolist') else attr_SparsePCA_n_components_`;
    })();
  }
  /**
    Number of iterations run.
   */
  get n_iter_() {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparsePCA must call init() before accessing n_iter_");
    }
    return (async () => {
      await this._py.ex`attr_SparsePCA_n_iter_ = bridgeSparsePCA[${this.id}].n_iter_`;
      return this._py`attr_SparsePCA_n_iter_.tolist() if hasattr(attr_SparsePCA_n_iter_, 'tolist') else attr_SparsePCA_n_iter_`;
    })();
  }
  /**
    Per-feature empirical mean, estimated from the training set. Equal to `X.mean(axis=0)`.
   */
  get mean_() {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("SparsePCA must call init() before accessing mean_");
    }
    return (async () => {
      await this._py.ex`attr_SparsePCA_mean_ = bridgeSparsePCA[${this.id}].mean_`;
      return this._py`attr_SparsePCA_mean_.tolist() if hasattr(attr_SparsePCA_mean_, 'tolist') else attr_SparsePCA_mean_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparsePCA must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SparsePCA_n_features_in_ = bridgeSparsePCA[${this.id}].n_features_in_`;
      return this._py`attr_SparsePCA_n_features_in_.tolist() if hasattr(attr_SparsePCA_n_features_in_, 'tolist') else attr_SparsePCA_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This SparsePCA instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "SparsePCA must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_SparsePCA_feature_names_in_ = bridgeSparsePCA[${this.id}].feature_names_in_`;
      return this._py`attr_SparsePCA_feature_names_in_.tolist() if hasattr(attr_SparsePCA_feature_names_in_, 'tolist') else attr_SparsePCA_feature_names_in_`;
    })();
  }
};

// src/generated/decomposition/TruncatedSVD.ts
import crypto44 from "node:crypto";
var TruncatedSVD = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `TruncatedSVD${crypto44.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("TruncatedSVD.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.decomposition import TruncatedSVD
try: bridgeTruncatedSVD
except NameError: bridgeTruncatedSVD = {}
`;
    await this._py.ex`ctor_TruncatedSVD = {'n_components': ${this.opts["n_components"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'n_iter': ${this.opts["n_iter"] ?? void 0}, 'n_oversamples': ${this.opts["n_oversamples"] ?? void 0}, 'power_iteration_normalizer': ${this.opts["power_iteration_normalizer"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}}

ctor_TruncatedSVD = {k: v for k, v in ctor_TruncatedSVD.items() if v is not None}`;
    await this._py.ex`bridgeTruncatedSVD[${this.id}] = TruncatedSVD(**ctor_TruncatedSVD)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeTruncatedSVD[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit model on training data X.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TruncatedSVD must call init() before fit()");
    }
    await this._py.ex`pms_TruncatedSVD_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_TruncatedSVD_fit = {k: v for k, v in pms_TruncatedSVD_fit.items() if v is not None}`;
    await this._py.ex`res_TruncatedSVD_fit = bridgeTruncatedSVD[${this.id}].fit(**pms_TruncatedSVD_fit)`;
    return this._py`res_TruncatedSVD_fit.tolist() if hasattr(res_TruncatedSVD_fit, 'tolist') else res_TruncatedSVD_fit`;
  }
  /**
    Fit model to X and perform dimensionality reduction on X.
   */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TruncatedSVD must call init() before fit_transform()");
    }
    await this._py.ex`pms_TruncatedSVD_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_TruncatedSVD_fit_transform = {k: v for k, v in pms_TruncatedSVD_fit_transform.items() if v is not None}`;
    await this._py.ex`res_TruncatedSVD_fit_transform = bridgeTruncatedSVD[${this.id}].fit_transform(**pms_TruncatedSVD_fit_transform)`;
    return this._py`res_TruncatedSVD_fit_transform.tolist() if hasattr(res_TruncatedSVD_fit_transform, 'tolist') else res_TruncatedSVD_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class_name0", "class_name1", "class_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TruncatedSVD must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_TruncatedSVD_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_TruncatedSVD_get_feature_names_out = {k: v for k, v in pms_TruncatedSVD_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_TruncatedSVD_get_feature_names_out = bridgeTruncatedSVD[${this.id}].get_feature_names_out(**pms_TruncatedSVD_get_feature_names_out)`;
    return this._py`res_TruncatedSVD_get_feature_names_out.tolist() if hasattr(res_TruncatedSVD_get_feature_names_out, 'tolist') else res_TruncatedSVD_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TruncatedSVD must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_TruncatedSVD_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_TruncatedSVD_get_metadata_routing = {k: v for k, v in pms_TruncatedSVD_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_TruncatedSVD_get_metadata_routing = bridgeTruncatedSVD[${this.id}].get_metadata_routing(**pms_TruncatedSVD_get_metadata_routing)`;
    return this._py`res_TruncatedSVD_get_metadata_routing.tolist() if hasattr(res_TruncatedSVD_get_metadata_routing, 'tolist') else res_TruncatedSVD_get_metadata_routing`;
  }
  /**
      Transform X back to its original space.
  
      Returns an array X_original whose transform would be X.
     */
  async inverse_transform(opts) {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TruncatedSVD must call init() before inverse_transform()"
      );
    }
    await this._py.ex`pms_TruncatedSVD_inverse_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_TruncatedSVD_inverse_transform = {k: v for k, v in pms_TruncatedSVD_inverse_transform.items() if v is not None}`;
    await this._py.ex`res_TruncatedSVD_inverse_transform = bridgeTruncatedSVD[${this.id}].inverse_transform(**pms_TruncatedSVD_inverse_transform)`;
    return this._py`res_TruncatedSVD_inverse_transform.tolist() if hasattr(res_TruncatedSVD_inverse_transform, 'tolist') else res_TruncatedSVD_inverse_transform`;
  }
  /**
      Set output container.
  
      See [Introducing the set_output API](https://scikit-learn.org/stable/modules/generated/../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TruncatedSVD must call init() before set_output()");
    }
    await this._py.ex`pms_TruncatedSVD_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_TruncatedSVD_set_output = {k: v for k, v in pms_TruncatedSVD_set_output.items() if v is not None}`;
    await this._py.ex`res_TruncatedSVD_set_output = bridgeTruncatedSVD[${this.id}].set_output(**pms_TruncatedSVD_set_output)`;
    return this._py`res_TruncatedSVD_set_output.tolist() if hasattr(res_TruncatedSVD_set_output, 'tolist') else res_TruncatedSVD_set_output`;
  }
  /**
    Perform dimensionality reduction on X.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("TruncatedSVD must call init() before transform()");
    }
    await this._py.ex`pms_TruncatedSVD_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_TruncatedSVD_transform = {k: v for k, v in pms_TruncatedSVD_transform.items() if v is not None}`;
    await this._py.ex`res_TruncatedSVD_transform = bridgeTruncatedSVD[${this.id}].transform(**pms_TruncatedSVD_transform)`;
    return this._py`res_TruncatedSVD_transform.tolist() if hasattr(res_TruncatedSVD_transform, 'tolist') else res_TruncatedSVD_transform`;
  }
  /**
    The right singular vectors of the input data.
   */
  get components_() {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TruncatedSVD must call init() before accessing components_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TruncatedSVD_components_ = bridgeTruncatedSVD[${this.id}].components_`;
      return this._py`attr_TruncatedSVD_components_.tolist() if hasattr(attr_TruncatedSVD_components_, 'tolist') else attr_TruncatedSVD_components_`;
    })();
  }
  /**
    The variance of the training samples transformed by a projection to each component.
   */
  get explained_variance_() {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TruncatedSVD must call init() before accessing explained_variance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TruncatedSVD_explained_variance_ = bridgeTruncatedSVD[${this.id}].explained_variance_`;
      return this._py`attr_TruncatedSVD_explained_variance_.tolist() if hasattr(attr_TruncatedSVD_explained_variance_, 'tolist') else attr_TruncatedSVD_explained_variance_`;
    })();
  }
  /**
    Percentage of variance explained by each of the selected components.
   */
  get explained_variance_ratio_() {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TruncatedSVD must call init() before accessing explained_variance_ratio_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TruncatedSVD_explained_variance_ratio_ = bridgeTruncatedSVD[${this.id}].explained_variance_ratio_`;
      return this._py`attr_TruncatedSVD_explained_variance_ratio_.tolist() if hasattr(attr_TruncatedSVD_explained_variance_ratio_, 'tolist') else attr_TruncatedSVD_explained_variance_ratio_`;
    })();
  }
  /**
    The singular values corresponding to each of the selected components. The singular values are equal to the 2-norms of the `n_components` variables in the lower-dimensional space.
   */
  get singular_values_() {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TruncatedSVD must call init() before accessing singular_values_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TruncatedSVD_singular_values_ = bridgeTruncatedSVD[${this.id}].singular_values_`;
      return this._py`attr_TruncatedSVD_singular_values_.tolist() if hasattr(attr_TruncatedSVD_singular_values_, 'tolist') else attr_TruncatedSVD_singular_values_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TruncatedSVD must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TruncatedSVD_n_features_in_ = bridgeTruncatedSVD[${this.id}].n_features_in_`;
      return this._py`attr_TruncatedSVD_n_features_in_.tolist() if hasattr(attr_TruncatedSVD_n_features_in_, 'tolist') else attr_TruncatedSVD_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This TruncatedSVD instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "TruncatedSVD must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_TruncatedSVD_feature_names_in_ = bridgeTruncatedSVD[${this.id}].feature_names_in_`;
      return this._py`attr_TruncatedSVD_feature_names_in_.tolist() if hasattr(attr_TruncatedSVD_feature_names_in_, 'tolist') else attr_TruncatedSVD_feature_names_in_`;
    })();
  }
};

// src/generated/discriminant_analysis/LinearDiscriminantAnalysis.ts
import crypto45 from "node:crypto";
var LinearDiscriminantAnalysis = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `LinearDiscriminantAnalysis${crypto45.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "LinearDiscriminantAnalysis.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
try: bridgeLinearDiscriminantAnalysis
except NameError: bridgeLinearDiscriminantAnalysis = {}
`;
    await this._py.ex`ctor_LinearDiscriminantAnalysis = {'solver': ${this.opts["solver"] ?? void 0}, 'shrinkage': ${this.opts["shrinkage"] ?? void 0}, 'priors': np.array(${this.opts["priors"] ?? void 0}) if ${this.opts["priors"] !== void 0} else None, 'n_components': ${this.opts["n_components"] ?? void 0}, 'store_covariance': ${this.opts["store_covariance"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'covariance_estimator': ${this.opts["covariance_estimator"] ?? void 0}}

ctor_LinearDiscriminantAnalysis = {k: v for k, v in ctor_LinearDiscriminantAnalysis.items() if v is not None}`;
    await this._py.ex`bridgeLinearDiscriminantAnalysis[${this.id}] = LinearDiscriminantAnalysis(**ctor_LinearDiscriminantAnalysis)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeLinearDiscriminantAnalysis[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Apply decision function to an array of samples.
  
      The decision function is equal (up to a constant factor) to the log-posterior of the model, i.e. `log p(y \= k | x)`. In a binary classification setting this instead corresponds to the difference `log p(y \= 1 | x) \- log p(y \= 0 | x)`. See [Mathematical formulation of the LDA and QDA classifiers](https://scikit-learn.org/stable/modules/generated/../lda_qda.html#lda-qda-math).
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_LinearDiscriminantAnalysis_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LinearDiscriminantAnalysis_decision_function = {k: v for k, v in pms_LinearDiscriminantAnalysis_decision_function.items() if v is not None}`;
    await this._py.ex`res_LinearDiscriminantAnalysis_decision_function = bridgeLinearDiscriminantAnalysis[${this.id}].decision_function(**pms_LinearDiscriminantAnalysis_decision_function)`;
    return this._py`res_LinearDiscriminantAnalysis_decision_function.tolist() if hasattr(res_LinearDiscriminantAnalysis_decision_function, 'tolist') else res_LinearDiscriminantAnalysis_decision_function`;
  }
  /**
    Fit the Linear Discriminant Analysis model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before fit()"
      );
    }
    await this._py.ex`pms_LinearDiscriminantAnalysis_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_LinearDiscriminantAnalysis_fit = {k: v for k, v in pms_LinearDiscriminantAnalysis_fit.items() if v is not None}`;
    await this._py.ex`res_LinearDiscriminantAnalysis_fit = bridgeLinearDiscriminantAnalysis[${this.id}].fit(**pms_LinearDiscriminantAnalysis_fit)`;
    return this._py`res_LinearDiscriminantAnalysis_fit.tolist() if hasattr(res_LinearDiscriminantAnalysis_fit, 'tolist') else res_LinearDiscriminantAnalysis_fit`;
  }
  /**
      Fit to data, then transform it.
  
      Fits transformer to `X` and `y` with optional parameters `fit_params` and returns a transformed version of `X`.
     */
  async fit_transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before fit_transform()"
      );
    }
    await this._py.ex`pms_LinearDiscriminantAnalysis_fit_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_LinearDiscriminantAnalysis_fit_transform = {k: v for k, v in pms_LinearDiscriminantAnalysis_fit_transform.items() if v is not None}`;
    await this._py.ex`res_LinearDiscriminantAnalysis_fit_transform = bridgeLinearDiscriminantAnalysis[${this.id}].fit_transform(**pms_LinearDiscriminantAnalysis_fit_transform)`;
    return this._py`res_LinearDiscriminantAnalysis_fit_transform.tolist() if hasattr(res_LinearDiscriminantAnalysis_fit_transform, 'tolist') else res_LinearDiscriminantAnalysis_fit_transform`;
  }
  /**
      Get output feature names for transformation.
  
      The feature names out will prefixed by the lowercased class name. For example, if the transformer outputs 3 features, then the feature names out are: `\["class_name0", "class_name1", "class_name2"\]`.
     */
  async get_feature_names_out(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before get_feature_names_out()"
      );
    }
    await this._py.ex`pms_LinearDiscriminantAnalysis_get_feature_names_out = {'input_features': ${opts["input_features"] ?? void 0}}

pms_LinearDiscriminantAnalysis_get_feature_names_out = {k: v for k, v in pms_LinearDiscriminantAnalysis_get_feature_names_out.items() if v is not None}`;
    await this._py.ex`res_LinearDiscriminantAnalysis_get_feature_names_out = bridgeLinearDiscriminantAnalysis[${this.id}].get_feature_names_out(**pms_LinearDiscriminantAnalysis_get_feature_names_out)`;
    return this._py`res_LinearDiscriminantAnalysis_get_feature_names_out.tolist() if hasattr(res_LinearDiscriminantAnalysis_get_feature_names_out, 'tolist') else res_LinearDiscriminantAnalysis_get_feature_names_out`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_LinearDiscriminantAnalysis_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_LinearDiscriminantAnalysis_get_metadata_routing = {k: v for k, v in pms_LinearDiscriminantAnalysis_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_LinearDiscriminantAnalysis_get_metadata_routing = bridgeLinearDiscriminantAnalysis[${this.id}].get_metadata_routing(**pms_LinearDiscriminantAnalysis_get_metadata_routing)`;
    return this._py`res_LinearDiscriminantAnalysis_get_metadata_routing.tolist() if hasattr(res_LinearDiscriminantAnalysis_get_metadata_routing, 'tolist') else res_LinearDiscriminantAnalysis_get_metadata_routing`;
  }
  /**
    Predict class labels for samples in X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before predict()"
      );
    }
    await this._py.ex`pms_LinearDiscriminantAnalysis_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LinearDiscriminantAnalysis_predict = {k: v for k, v in pms_LinearDiscriminantAnalysis_predict.items() if v is not None}`;
    await this._py.ex`res_LinearDiscriminantAnalysis_predict = bridgeLinearDiscriminantAnalysis[${this.id}].predict(**pms_LinearDiscriminantAnalysis_predict)`;
    return this._py`res_LinearDiscriminantAnalysis_predict.tolist() if hasattr(res_LinearDiscriminantAnalysis_predict, 'tolist') else res_LinearDiscriminantAnalysis_predict`;
  }
  /**
    Estimate log probability.
   */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_LinearDiscriminantAnalysis_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LinearDiscriminantAnalysis_predict_log_proba = {k: v for k, v in pms_LinearDiscriminantAnalysis_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_LinearDiscriminantAnalysis_predict_log_proba = bridgeLinearDiscriminantAnalysis[${this.id}].predict_log_proba(**pms_LinearDiscriminantAnalysis_predict_log_proba)`;
    return this._py`res_LinearDiscriminantAnalysis_predict_log_proba.tolist() if hasattr(res_LinearDiscriminantAnalysis_predict_log_proba, 'tolist') else res_LinearDiscriminantAnalysis_predict_log_proba`;
  }
  /**
    Estimate probability.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_LinearDiscriminantAnalysis_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LinearDiscriminantAnalysis_predict_proba = {k: v for k, v in pms_LinearDiscriminantAnalysis_predict_proba.items() if v is not None}`;
    await this._py.ex`res_LinearDiscriminantAnalysis_predict_proba = bridgeLinearDiscriminantAnalysis[${this.id}].predict_proba(**pms_LinearDiscriminantAnalysis_predict_proba)`;
    return this._py`res_LinearDiscriminantAnalysis_predict_proba.tolist() if hasattr(res_LinearDiscriminantAnalysis_predict_proba, 'tolist') else res_LinearDiscriminantAnalysis_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before score()"
      );
    }
    await this._py.ex`pms_LinearDiscriminantAnalysis_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_LinearDiscriminantAnalysis_score = {k: v for k, v in pms_LinearDiscriminantAnalysis_score.items() if v is not None}`;
    await this._py.ex`res_LinearDiscriminantAnalysis_score = bridgeLinearDiscriminantAnalysis[${this.id}].score(**pms_LinearDiscriminantAnalysis_score)`;
    return this._py`res_LinearDiscriminantAnalysis_score.tolist() if hasattr(res_LinearDiscriminantAnalysis_score, 'tolist') else res_LinearDiscriminantAnalysis_score`;
  }
  /**
      Set output container.
  
      See [Introducing the set_output API](https://scikit-learn.org/stable/modules/generated/../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
  async set_output(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before set_output()"
      );
    }
    await this._py.ex`pms_LinearDiscriminantAnalysis_set_output = {'transform': ${opts["transform"] ?? void 0}}

pms_LinearDiscriminantAnalysis_set_output = {k: v for k, v in pms_LinearDiscriminantAnalysis_set_output.items() if v is not None}`;
    await this._py.ex`res_LinearDiscriminantAnalysis_set_output = bridgeLinearDiscriminantAnalysis[${this.id}].set_output(**pms_LinearDiscriminantAnalysis_set_output)`;
    return this._py`res_LinearDiscriminantAnalysis_set_output.tolist() if hasattr(res_LinearDiscriminantAnalysis_set_output, 'tolist') else res_LinearDiscriminantAnalysis_set_output`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_LinearDiscriminantAnalysis_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_LinearDiscriminantAnalysis_set_score_request = {k: v for k, v in pms_LinearDiscriminantAnalysis_set_score_request.items() if v is not None}`;
    await this._py.ex`res_LinearDiscriminantAnalysis_set_score_request = bridgeLinearDiscriminantAnalysis[${this.id}].set_score_request(**pms_LinearDiscriminantAnalysis_set_score_request)`;
    return this._py`res_LinearDiscriminantAnalysis_set_score_request.tolist() if hasattr(res_LinearDiscriminantAnalysis_set_score_request, 'tolist') else res_LinearDiscriminantAnalysis_set_score_request`;
  }
  /**
    Project data to maximize class separation.
   */
  async transform(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before transform()"
      );
    }
    await this._py.ex`pms_LinearDiscriminantAnalysis_transform = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_LinearDiscriminantAnalysis_transform = {k: v for k, v in pms_LinearDiscriminantAnalysis_transform.items() if v is not None}`;
    await this._py.ex`res_LinearDiscriminantAnalysis_transform = bridgeLinearDiscriminantAnalysis[${this.id}].transform(**pms_LinearDiscriminantAnalysis_transform)`;
    return this._py`res_LinearDiscriminantAnalysis_transform.tolist() if hasattr(res_LinearDiscriminantAnalysis_transform, 'tolist') else res_LinearDiscriminantAnalysis_transform`;
  }
  /**
    Weight vector(s).
   */
  get coef_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before accessing coef_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearDiscriminantAnalysis_coef_ = bridgeLinearDiscriminantAnalysis[${this.id}].coef_`;
      return this._py`attr_LinearDiscriminantAnalysis_coef_.tolist() if hasattr(attr_LinearDiscriminantAnalysis_coef_, 'tolist') else attr_LinearDiscriminantAnalysis_coef_`;
    })();
  }
  /**
    Intercept term.
   */
  get intercept_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before accessing intercept_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearDiscriminantAnalysis_intercept_ = bridgeLinearDiscriminantAnalysis[${this.id}].intercept_`;
      return this._py`attr_LinearDiscriminantAnalysis_intercept_.tolist() if hasattr(attr_LinearDiscriminantAnalysis_intercept_, 'tolist') else attr_LinearDiscriminantAnalysis_intercept_`;
    })();
  }
  /**
    Weighted within-class covariance matrix. It corresponds to `sum_k prior_k \* C_k` where `C_k` is the covariance matrix of the samples in class `k`. The `C_k` are estimated using the (potentially shrunk) biased estimator of covariance. If solver is ‘svd’, only exists when `store_covariance` is `true`.
   */
  get covariance_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before accessing covariance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearDiscriminantAnalysis_covariance_ = bridgeLinearDiscriminantAnalysis[${this.id}].covariance_`;
      return this._py`attr_LinearDiscriminantAnalysis_covariance_.tolist() if hasattr(attr_LinearDiscriminantAnalysis_covariance_, 'tolist') else attr_LinearDiscriminantAnalysis_covariance_`;
    })();
  }
  /**
    Percentage of variance explained by each of the selected components. If `n_components` is not set then all components are stored and the sum of explained variances is equal to 1.0. Only available when eigen or svd solver is used.
   */
  get explained_variance_ratio_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before accessing explained_variance_ratio_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearDiscriminantAnalysis_explained_variance_ratio_ = bridgeLinearDiscriminantAnalysis[${this.id}].explained_variance_ratio_`;
      return this._py`attr_LinearDiscriminantAnalysis_explained_variance_ratio_.tolist() if hasattr(attr_LinearDiscriminantAnalysis_explained_variance_ratio_, 'tolist') else attr_LinearDiscriminantAnalysis_explained_variance_ratio_`;
    })();
  }
  /**
    Class-wise means.
   */
  get means_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before accessing means_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearDiscriminantAnalysis_means_ = bridgeLinearDiscriminantAnalysis[${this.id}].means_`;
      return this._py`attr_LinearDiscriminantAnalysis_means_.tolist() if hasattr(attr_LinearDiscriminantAnalysis_means_, 'tolist') else attr_LinearDiscriminantAnalysis_means_`;
    })();
  }
  /**
    Class priors (sum to 1).
   */
  get priors_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before accessing priors_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearDiscriminantAnalysis_priors_ = bridgeLinearDiscriminantAnalysis[${this.id}].priors_`;
      return this._py`attr_LinearDiscriminantAnalysis_priors_.tolist() if hasattr(attr_LinearDiscriminantAnalysis_priors_, 'tolist') else attr_LinearDiscriminantAnalysis_priors_`;
    })();
  }
  /**
    Scaling of the features in the space spanned by the class centroids. Only available for ‘svd’ and ‘eigen’ solvers.
   */
  get scalings_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before accessing scalings_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearDiscriminantAnalysis_scalings_ = bridgeLinearDiscriminantAnalysis[${this.id}].scalings_`;
      return this._py`attr_LinearDiscriminantAnalysis_scalings_.tolist() if hasattr(attr_LinearDiscriminantAnalysis_scalings_, 'tolist') else attr_LinearDiscriminantAnalysis_scalings_`;
    })();
  }
  /**
    Overall mean. Only present if solver is ‘svd’.
   */
  get xbar_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before accessing xbar_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearDiscriminantAnalysis_xbar_ = bridgeLinearDiscriminantAnalysis[${this.id}].xbar_`;
      return this._py`attr_LinearDiscriminantAnalysis_xbar_.tolist() if hasattr(attr_LinearDiscriminantAnalysis_xbar_, 'tolist') else attr_LinearDiscriminantAnalysis_xbar_`;
    })();
  }
  /**
    Unique class labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearDiscriminantAnalysis_classes_ = bridgeLinearDiscriminantAnalysis[${this.id}].classes_`;
      return this._py`attr_LinearDiscriminantAnalysis_classes_.tolist() if hasattr(attr_LinearDiscriminantAnalysis_classes_, 'tolist') else attr_LinearDiscriminantAnalysis_classes_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearDiscriminantAnalysis_n_features_in_ = bridgeLinearDiscriminantAnalysis[${this.id}].n_features_in_`;
      return this._py`attr_LinearDiscriminantAnalysis_n_features_in_.tolist() if hasattr(attr_LinearDiscriminantAnalysis_n_features_in_, 'tolist') else attr_LinearDiscriminantAnalysis_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This LinearDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "LinearDiscriminantAnalysis must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_LinearDiscriminantAnalysis_feature_names_in_ = bridgeLinearDiscriminantAnalysis[${this.id}].feature_names_in_`;
      return this._py`attr_LinearDiscriminantAnalysis_feature_names_in_.tolist() if hasattr(attr_LinearDiscriminantAnalysis_feature_names_in_, 'tolist') else attr_LinearDiscriminantAnalysis_feature_names_in_`;
    })();
  }
};

// src/generated/discriminant_analysis/QuadraticDiscriminantAnalysis.ts
import crypto46 from "node:crypto";
var QuadraticDiscriminantAnalysis = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `QuadraticDiscriminantAnalysis${crypto46.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "QuadraticDiscriminantAnalysis.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis
try: bridgeQuadraticDiscriminantAnalysis
except NameError: bridgeQuadraticDiscriminantAnalysis = {}
`;
    await this._py.ex`ctor_QuadraticDiscriminantAnalysis = {'priors': np.array(${this.opts["priors"] ?? void 0}) if ${this.opts["priors"] !== void 0} else None, 'reg_param': ${this.opts["reg_param"] ?? void 0}, 'store_covariance': ${this.opts["store_covariance"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}}

ctor_QuadraticDiscriminantAnalysis = {k: v for k, v in ctor_QuadraticDiscriminantAnalysis.items() if v is not None}`;
    await this._py.ex`bridgeQuadraticDiscriminantAnalysis[${this.id}] = QuadraticDiscriminantAnalysis(**ctor_QuadraticDiscriminantAnalysis)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeQuadraticDiscriminantAnalysis[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Apply decision function to an array of samples.
  
      The decision function is equal (up to a constant factor) to the log-posterior of the model, i.e. `log p(y \= k | x)`. In a binary classification setting this instead corresponds to the difference `log p(y \= 1 | x) \- log p(y \= 0 | x)`. See [Mathematical formulation of the LDA and QDA classifiers](https://scikit-learn.org/stable/modules/generated/../lda_qda.html#lda-qda-math).
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_QuadraticDiscriminantAnalysis_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_QuadraticDiscriminantAnalysis_decision_function = {k: v for k, v in pms_QuadraticDiscriminantAnalysis_decision_function.items() if v is not None}`;
    await this._py.ex`res_QuadraticDiscriminantAnalysis_decision_function = bridgeQuadraticDiscriminantAnalysis[${this.id}].decision_function(**pms_QuadraticDiscriminantAnalysis_decision_function)`;
    return this._py`res_QuadraticDiscriminantAnalysis_decision_function.tolist() if hasattr(res_QuadraticDiscriminantAnalysis_decision_function, 'tolist') else res_QuadraticDiscriminantAnalysis_decision_function`;
  }
  /**
    Fit the model according to the given training data and parameters.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before fit()"
      );
    }
    await this._py.ex`pms_QuadraticDiscriminantAnalysis_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None}

pms_QuadraticDiscriminantAnalysis_fit = {k: v for k, v in pms_QuadraticDiscriminantAnalysis_fit.items() if v is not None}`;
    await this._py.ex`res_QuadraticDiscriminantAnalysis_fit = bridgeQuadraticDiscriminantAnalysis[${this.id}].fit(**pms_QuadraticDiscriminantAnalysis_fit)`;
    return this._py`res_QuadraticDiscriminantAnalysis_fit.tolist() if hasattr(res_QuadraticDiscriminantAnalysis_fit, 'tolist') else res_QuadraticDiscriminantAnalysis_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_QuadraticDiscriminantAnalysis_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_QuadraticDiscriminantAnalysis_get_metadata_routing = {k: v for k, v in pms_QuadraticDiscriminantAnalysis_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_QuadraticDiscriminantAnalysis_get_metadata_routing = bridgeQuadraticDiscriminantAnalysis[${this.id}].get_metadata_routing(**pms_QuadraticDiscriminantAnalysis_get_metadata_routing)`;
    return this._py`res_QuadraticDiscriminantAnalysis_get_metadata_routing.tolist() if hasattr(res_QuadraticDiscriminantAnalysis_get_metadata_routing, 'tolist') else res_QuadraticDiscriminantAnalysis_get_metadata_routing`;
  }
  /**
      Perform classification on an array of test vectors X.
  
      The predicted class C for each sample in X is returned.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before predict()"
      );
    }
    await this._py.ex`pms_QuadraticDiscriminantAnalysis_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_QuadraticDiscriminantAnalysis_predict = {k: v for k, v in pms_QuadraticDiscriminantAnalysis_predict.items() if v is not None}`;
    await this._py.ex`res_QuadraticDiscriminantAnalysis_predict = bridgeQuadraticDiscriminantAnalysis[${this.id}].predict(**pms_QuadraticDiscriminantAnalysis_predict)`;
    return this._py`res_QuadraticDiscriminantAnalysis_predict.tolist() if hasattr(res_QuadraticDiscriminantAnalysis_predict, 'tolist') else res_QuadraticDiscriminantAnalysis_predict`;
  }
  /**
    Return log of posterior probabilities of classification.
   */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_QuadraticDiscriminantAnalysis_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_QuadraticDiscriminantAnalysis_predict_log_proba = {k: v for k, v in pms_QuadraticDiscriminantAnalysis_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_QuadraticDiscriminantAnalysis_predict_log_proba = bridgeQuadraticDiscriminantAnalysis[${this.id}].predict_log_proba(**pms_QuadraticDiscriminantAnalysis_predict_log_proba)`;
    return this._py`res_QuadraticDiscriminantAnalysis_predict_log_proba.tolist() if hasattr(res_QuadraticDiscriminantAnalysis_predict_log_proba, 'tolist') else res_QuadraticDiscriminantAnalysis_predict_log_proba`;
  }
  /**
    Return posterior probabilities of classification.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_QuadraticDiscriminantAnalysis_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_QuadraticDiscriminantAnalysis_predict_proba = {k: v for k, v in pms_QuadraticDiscriminantAnalysis_predict_proba.items() if v is not None}`;
    await this._py.ex`res_QuadraticDiscriminantAnalysis_predict_proba = bridgeQuadraticDiscriminantAnalysis[${this.id}].predict_proba(**pms_QuadraticDiscriminantAnalysis_predict_proba)`;
    return this._py`res_QuadraticDiscriminantAnalysis_predict_proba.tolist() if hasattr(res_QuadraticDiscriminantAnalysis_predict_proba, 'tolist') else res_QuadraticDiscriminantAnalysis_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before score()"
      );
    }
    await this._py.ex`pms_QuadraticDiscriminantAnalysis_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_QuadraticDiscriminantAnalysis_score = {k: v for k, v in pms_QuadraticDiscriminantAnalysis_score.items() if v is not None}`;
    await this._py.ex`res_QuadraticDiscriminantAnalysis_score = bridgeQuadraticDiscriminantAnalysis[${this.id}].score(**pms_QuadraticDiscriminantAnalysis_score)`;
    return this._py`res_QuadraticDiscriminantAnalysis_score.tolist() if hasattr(res_QuadraticDiscriminantAnalysis_score, 'tolist') else res_QuadraticDiscriminantAnalysis_score`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_QuadraticDiscriminantAnalysis_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_QuadraticDiscriminantAnalysis_set_score_request = {k: v for k, v in pms_QuadraticDiscriminantAnalysis_set_score_request.items() if v is not None}`;
    await this._py.ex`res_QuadraticDiscriminantAnalysis_set_score_request = bridgeQuadraticDiscriminantAnalysis[${this.id}].set_score_request(**pms_QuadraticDiscriminantAnalysis_set_score_request)`;
    return this._py`res_QuadraticDiscriminantAnalysis_set_score_request.tolist() if hasattr(res_QuadraticDiscriminantAnalysis_set_score_request, 'tolist') else res_QuadraticDiscriminantAnalysis_set_score_request`;
  }
  /**
    For each class, gives the covariance matrix estimated using the samples of that class. The estimations are unbiased. Only present if `store_covariance` is `true`.
   */
  get covariance_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before accessing covariance_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuadraticDiscriminantAnalysis_covariance_ = bridgeQuadraticDiscriminantAnalysis[${this.id}].covariance_`;
      return this._py`attr_QuadraticDiscriminantAnalysis_covariance_.tolist() if hasattr(attr_QuadraticDiscriminantAnalysis_covariance_, 'tolist') else attr_QuadraticDiscriminantAnalysis_covariance_`;
    })();
  }
  /**
    Class-wise means.
   */
  get means_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before accessing means_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuadraticDiscriminantAnalysis_means_ = bridgeQuadraticDiscriminantAnalysis[${this.id}].means_`;
      return this._py`attr_QuadraticDiscriminantAnalysis_means_.tolist() if hasattr(attr_QuadraticDiscriminantAnalysis_means_, 'tolist') else attr_QuadraticDiscriminantAnalysis_means_`;
    })();
  }
  /**
    Class priors (sum to 1).
   */
  get priors_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before accessing priors_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuadraticDiscriminantAnalysis_priors_ = bridgeQuadraticDiscriminantAnalysis[${this.id}].priors_`;
      return this._py`attr_QuadraticDiscriminantAnalysis_priors_.tolist() if hasattr(attr_QuadraticDiscriminantAnalysis_priors_, 'tolist') else attr_QuadraticDiscriminantAnalysis_priors_`;
    })();
  }
  /**
    For each class k an array of shape (n_features, n_k), where `n_k \= min(n_features, number of elements in class k)` It is the rotation of the Gaussian distribution, i.e. its principal axis. It corresponds to `V`, the matrix of eigenvectors coming from the SVD of `Xk \= U S Vt` where `Xk` is the centered matrix of samples from class k.
   */
  get rotations_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before accessing rotations_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuadraticDiscriminantAnalysis_rotations_ = bridgeQuadraticDiscriminantAnalysis[${this.id}].rotations_`;
      return this._py`attr_QuadraticDiscriminantAnalysis_rotations_.tolist() if hasattr(attr_QuadraticDiscriminantAnalysis_rotations_, 'tolist') else attr_QuadraticDiscriminantAnalysis_rotations_`;
    })();
  }
  /**
    For each class, contains the scaling of the Gaussian distributions along its principal axes, i.e. the variance in the rotated coordinate system. It corresponds to `S^2 / (n_samples \- 1)`, where `S` is the diagonal matrix of singular values from the SVD of `Xk`, where `Xk` is the centered matrix of samples from class k.
   */
  get scalings_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before accessing scalings_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuadraticDiscriminantAnalysis_scalings_ = bridgeQuadraticDiscriminantAnalysis[${this.id}].scalings_`;
      return this._py`attr_QuadraticDiscriminantAnalysis_scalings_.tolist() if hasattr(attr_QuadraticDiscriminantAnalysis_scalings_, 'tolist') else attr_QuadraticDiscriminantAnalysis_scalings_`;
    })();
  }
  /**
    Unique class labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuadraticDiscriminantAnalysis_classes_ = bridgeQuadraticDiscriminantAnalysis[${this.id}].classes_`;
      return this._py`attr_QuadraticDiscriminantAnalysis_classes_.tolist() if hasattr(attr_QuadraticDiscriminantAnalysis_classes_, 'tolist') else attr_QuadraticDiscriminantAnalysis_classes_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuadraticDiscriminantAnalysis_n_features_in_ = bridgeQuadraticDiscriminantAnalysis[${this.id}].n_features_in_`;
      return this._py`attr_QuadraticDiscriminantAnalysis_n_features_in_.tolist() if hasattr(attr_QuadraticDiscriminantAnalysis_n_features_in_, 'tolist') else attr_QuadraticDiscriminantAnalysis_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This QuadraticDiscriminantAnalysis instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "QuadraticDiscriminantAnalysis must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_QuadraticDiscriminantAnalysis_feature_names_in_ = bridgeQuadraticDiscriminantAnalysis[${this.id}].feature_names_in_`;
      return this._py`attr_QuadraticDiscriminantAnalysis_feature_names_in_.tolist() if hasattr(attr_QuadraticDiscriminantAnalysis_feature_names_in_, 'tolist') else attr_QuadraticDiscriminantAnalysis_feature_names_in_`;
    })();
  }
};

// src/generated/dummy/DummyClassifier.ts
import crypto47 from "node:crypto";
var DummyClassifier = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `DummyClassifier${crypto47.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("DummyClassifier.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.dummy import DummyClassifier
try: bridgeDummyClassifier
except NameError: bridgeDummyClassifier = {}
`;
    await this._py.ex`ctor_DummyClassifier = {'strategy': ${this.opts["strategy"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'constant': np.array(${this.opts["constant"] ?? void 0}) if ${this.opts["constant"] !== void 0} else None}

ctor_DummyClassifier = {k: v for k, v in ctor_DummyClassifier.items() if v is not None}`;
    await this._py.ex`bridgeDummyClassifier[${this.id}] = DummyClassifier(**ctor_DummyClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeDummyClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the baseline classifier.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DummyClassifier must call init() before fit()");
    }
    await this._py.ex`pms_DummyClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_DummyClassifier_fit = {k: v for k, v in pms_DummyClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_DummyClassifier_fit = bridgeDummyClassifier[${this.id}].fit(**pms_DummyClassifier_fit)`;
    return this._py`res_DummyClassifier_fit.tolist() if hasattr(res_DummyClassifier_fit, 'tolist') else res_DummyClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_DummyClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_DummyClassifier_get_metadata_routing = {k: v for k, v in pms_DummyClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_DummyClassifier_get_metadata_routing = bridgeDummyClassifier[${this.id}].get_metadata_routing(**pms_DummyClassifier_get_metadata_routing)`;
    return this._py`res_DummyClassifier_get_metadata_routing.tolist() if hasattr(res_DummyClassifier_get_metadata_routing, 'tolist') else res_DummyClassifier_get_metadata_routing`;
  }
  /**
    Perform classification on test vectors X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DummyClassifier must call init() before predict()");
    }
    await this._py.ex`pms_DummyClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_DummyClassifier_predict = {k: v for k, v in pms_DummyClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_DummyClassifier_predict = bridgeDummyClassifier[${this.id}].predict(**pms_DummyClassifier_predict)`;
    return this._py`res_DummyClassifier_predict.tolist() if hasattr(res_DummyClassifier_predict, 'tolist') else res_DummyClassifier_predict`;
  }
  /**
    Return log probability estimates for the test vectors X.
   */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyClassifier must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_DummyClassifier_predict_log_proba = {'X': ${opts["X"] ?? void 0}}

pms_DummyClassifier_predict_log_proba = {k: v for k, v in pms_DummyClassifier_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_DummyClassifier_predict_log_proba = bridgeDummyClassifier[${this.id}].predict_log_proba(**pms_DummyClassifier_predict_log_proba)`;
    return this._py`res_DummyClassifier_predict_log_proba.tolist() if hasattr(res_DummyClassifier_predict_log_proba, 'tolist') else res_DummyClassifier_predict_log_proba`;
  }
  /**
    Return probability estimates for the test vectors X.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DummyClassifier must call init() before predict_proba()");
    }
    await this._py.ex`pms_DummyClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_DummyClassifier_predict_proba = {k: v for k, v in pms_DummyClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_DummyClassifier_predict_proba = bridgeDummyClassifier[${this.id}].predict_proba(**pms_DummyClassifier_predict_proba)`;
    return this._py`res_DummyClassifier_predict_proba.tolist() if hasattr(res_DummyClassifier_predict_proba, 'tolist') else res_DummyClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DummyClassifier must call init() before score()");
    }
    await this._py.ex`pms_DummyClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_DummyClassifier_score = {k: v for k, v in pms_DummyClassifier_score.items() if v is not None}`;
    await this._py.ex`res_DummyClassifier_score = bridgeDummyClassifier[${this.id}].score(**pms_DummyClassifier_score)`;
    return this._py`res_DummyClassifier_score.tolist() if hasattr(res_DummyClassifier_score, 'tolist') else res_DummyClassifier_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyClassifier must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_DummyClassifier_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_DummyClassifier_set_fit_request = {k: v for k, v in pms_DummyClassifier_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_DummyClassifier_set_fit_request = bridgeDummyClassifier[${this.id}].set_fit_request(**pms_DummyClassifier_set_fit_request)`;
    return this._py`res_DummyClassifier_set_fit_request.tolist() if hasattr(res_DummyClassifier_set_fit_request, 'tolist') else res_DummyClassifier_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_DummyClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_DummyClassifier_set_score_request = {k: v for k, v in pms_DummyClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_DummyClassifier_set_score_request = bridgeDummyClassifier[${this.id}].set_score_request(**pms_DummyClassifier_set_score_request)`;
    return this._py`res_DummyClassifier_set_score_request.tolist() if hasattr(res_DummyClassifier_set_score_request, 'tolist') else res_DummyClassifier_set_score_request`;
  }
  /**
    Unique class labels observed in `y`. For multi-output classification problems, this attribute is a list of arrays as each output has an independent set of possible classes.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DummyClassifier_classes_ = bridgeDummyClassifier[${this.id}].classes_`;
      return this._py`attr_DummyClassifier_classes_.tolist() if hasattr(attr_DummyClassifier_classes_, 'tolist') else attr_DummyClassifier_classes_`;
    })();
  }
  /**
    Number of label for each output.
   */
  get n_classes_() {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyClassifier must call init() before accessing n_classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DummyClassifier_n_classes_ = bridgeDummyClassifier[${this.id}].n_classes_`;
      return this._py`attr_DummyClassifier_n_classes_.tolist() if hasattr(attr_DummyClassifier_n_classes_, 'tolist') else attr_DummyClassifier_n_classes_`;
    })();
  }
  /**
    Frequency of each class observed in `y`. For multioutput classification problems, this is computed independently for each output.
   */
  get class_prior_() {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyClassifier must call init() before accessing class_prior_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DummyClassifier_class_prior_ = bridgeDummyClassifier[${this.id}].class_prior_`;
      return this._py`attr_DummyClassifier_class_prior_.tolist() if hasattr(attr_DummyClassifier_class_prior_, 'tolist') else attr_DummyClassifier_class_prior_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DummyClassifier_n_features_in_ = bridgeDummyClassifier[${this.id}].n_features_in_`;
      return this._py`attr_DummyClassifier_n_features_in_.tolist() if hasattr(attr_DummyClassifier_n_features_in_, 'tolist') else attr_DummyClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DummyClassifier_feature_names_in_ = bridgeDummyClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_DummyClassifier_feature_names_in_.tolist() if hasattr(attr_DummyClassifier_feature_names_in_, 'tolist') else attr_DummyClassifier_feature_names_in_`;
    })();
  }
  /**
    Number of outputs.
   */
  get n_outputs_() {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyClassifier must call init() before accessing n_outputs_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DummyClassifier_n_outputs_ = bridgeDummyClassifier[${this.id}].n_outputs_`;
      return this._py`attr_DummyClassifier_n_outputs_.tolist() if hasattr(attr_DummyClassifier_n_outputs_, 'tolist') else attr_DummyClassifier_n_outputs_`;
    })();
  }
  /**
    True if the array returned from predict is to be in sparse CSC format. Is automatically set to `true` if the input `y` is passed in sparse format.
   */
  get sparse_output_() {
    if (this._isDisposed) {
      throw new Error("This DummyClassifier instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyClassifier must call init() before accessing sparse_output_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DummyClassifier_sparse_output_ = bridgeDummyClassifier[${this.id}].sparse_output_`;
      return this._py`attr_DummyClassifier_sparse_output_.tolist() if hasattr(attr_DummyClassifier_sparse_output_, 'tolist') else attr_DummyClassifier_sparse_output_`;
    })();
  }
};

// src/generated/dummy/DummyRegressor.ts
import crypto48 from "node:crypto";
var DummyRegressor = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `DummyRegressor${crypto48.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This DummyRegressor instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("DummyRegressor.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.dummy import DummyRegressor
try: bridgeDummyRegressor
except NameError: bridgeDummyRegressor = {}
`;
    await this._py.ex`ctor_DummyRegressor = {'strategy': ${this.opts["strategy"] ?? void 0}, 'constant': np.array(${this.opts["constant"] ?? void 0}) if ${this.opts["constant"] !== void 0} else None, 'quantile': ${this.opts["quantile"] ?? void 0}}

ctor_DummyRegressor = {k: v for k, v in ctor_DummyRegressor.items() if v is not None}`;
    await this._py.ex`bridgeDummyRegressor[${this.id}] = DummyRegressor(**ctor_DummyRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeDummyRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the random regressor.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DummyRegressor must call init() before fit()");
    }
    await this._py.ex`pms_DummyRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_DummyRegressor_fit = {k: v for k, v in pms_DummyRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_DummyRegressor_fit = bridgeDummyRegressor[${this.id}].fit(**pms_DummyRegressor_fit)`;
    return this._py`res_DummyRegressor_fit.tolist() if hasattr(res_DummyRegressor_fit, 'tolist') else res_DummyRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_DummyRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_DummyRegressor_get_metadata_routing = {k: v for k, v in pms_DummyRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_DummyRegressor_get_metadata_routing = bridgeDummyRegressor[${this.id}].get_metadata_routing(**pms_DummyRegressor_get_metadata_routing)`;
    return this._py`res_DummyRegressor_get_metadata_routing.tolist() if hasattr(res_DummyRegressor_get_metadata_routing, 'tolist') else res_DummyRegressor_get_metadata_routing`;
  }
  /**
    Perform classification on test vectors X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DummyRegressor must call init() before predict()");
    }
    await this._py.ex`pms_DummyRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'return_std': ${opts["return_std"] ?? void 0}}

pms_DummyRegressor_predict = {k: v for k, v in pms_DummyRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_DummyRegressor_predict = bridgeDummyRegressor[${this.id}].predict(**pms_DummyRegressor_predict)`;
    return this._py`res_DummyRegressor_predict.tolist() if hasattr(res_DummyRegressor_predict, 'tolist') else res_DummyRegressor_predict`;
  }
  /**
      Return the coefficient of determination R^2 of the prediction.
  
      The coefficient R^2 is defined as `(1 \- u/v)`, where `u` is the residual sum of squares `((y_true \- y_pred) \*\* 2).sum()` and `v` is the total sum of squares `((y_true \- y_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of y, disregarding the input features, would get a R^2 score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("DummyRegressor must call init() before score()");
    }
    await this._py.ex`pms_DummyRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_DummyRegressor_score = {k: v for k, v in pms_DummyRegressor_score.items() if v is not None}`;
    await this._py.ex`res_DummyRegressor_score = bridgeDummyRegressor[${this.id}].score(**pms_DummyRegressor_score)`;
    return this._py`res_DummyRegressor_score.tolist() if hasattr(res_DummyRegressor_score, 'tolist') else res_DummyRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_DummyRegressor_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_DummyRegressor_set_fit_request = {k: v for k, v in pms_DummyRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_DummyRegressor_set_fit_request = bridgeDummyRegressor[${this.id}].set_fit_request(**pms_DummyRegressor_set_fit_request)`;
    return this._py`res_DummyRegressor_set_fit_request.tolist() if hasattr(res_DummyRegressor_set_fit_request, 'tolist') else res_DummyRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `predict` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_predict_request(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyRegressor must call init() before set_predict_request()"
      );
    }
    await this._py.ex`pms_DummyRegressor_set_predict_request = {'return_std': ${opts["return_std"] ?? void 0}}

pms_DummyRegressor_set_predict_request = {k: v for k, v in pms_DummyRegressor_set_predict_request.items() if v is not None}`;
    await this._py.ex`res_DummyRegressor_set_predict_request = bridgeDummyRegressor[${this.id}].set_predict_request(**pms_DummyRegressor_set_predict_request)`;
    return this._py`res_DummyRegressor_set_predict_request.tolist() if hasattr(res_DummyRegressor_set_predict_request, 'tolist') else res_DummyRegressor_set_predict_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error("This DummyRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_DummyRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_DummyRegressor_set_score_request = {k: v for k, v in pms_DummyRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_DummyRegressor_set_score_request = bridgeDummyRegressor[${this.id}].set_score_request(**pms_DummyRegressor_set_score_request)`;
    return this._py`res_DummyRegressor_set_score_request.tolist() if hasattr(res_DummyRegressor_set_score_request, 'tolist') else res_DummyRegressor_set_score_request`;
  }
  /**
    Mean or median or quantile of the training targets or constant value given by the user.
   */
  get constant_() {
    if (this._isDisposed) {
      throw new Error("This DummyRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyRegressor must call init() before accessing constant_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DummyRegressor_constant_ = bridgeDummyRegressor[${this.id}].constant_`;
      return this._py`attr_DummyRegressor_constant_.tolist() if hasattr(attr_DummyRegressor_constant_, 'tolist') else attr_DummyRegressor_constant_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This DummyRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DummyRegressor_n_features_in_ = bridgeDummyRegressor[${this.id}].n_features_in_`;
      return this._py`attr_DummyRegressor_n_features_in_.tolist() if hasattr(attr_DummyRegressor_n_features_in_, 'tolist') else attr_DummyRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This DummyRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DummyRegressor_feature_names_in_ = bridgeDummyRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_DummyRegressor_feature_names_in_.tolist() if hasattr(attr_DummyRegressor_feature_names_in_, 'tolist') else attr_DummyRegressor_feature_names_in_`;
    })();
  }
  /**
    Number of outputs.
   */
  get n_outputs_() {
    if (this._isDisposed) {
      throw new Error("This DummyRegressor instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "DummyRegressor must call init() before accessing n_outputs_"
      );
    }
    return (async () => {
      await this._py.ex`attr_DummyRegressor_n_outputs_ = bridgeDummyRegressor[${this.id}].n_outputs_`;
      return this._py`attr_DummyRegressor_n_outputs_.tolist() if hasattr(attr_DummyRegressor_n_outputs_, 'tolist') else attr_DummyRegressor_n_outputs_`;
    })();
  }
};

// src/generated/ensemble/AdaBoostClassifier.ts
import crypto49 from "node:crypto";
var AdaBoostClassifier = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `AdaBoostClassifier${crypto49.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "AdaBoostClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import AdaBoostClassifier
try: bridgeAdaBoostClassifier
except NameError: bridgeAdaBoostClassifier = {}
`;
    await this._py.ex`ctor_AdaBoostClassifier = {'estimator': ${this.opts["estimator"] ?? void 0}, 'n_estimators': ${this.opts["n_estimators"] ?? void 0}, 'learning_rate': ${this.opts["learning_rate"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_AdaBoostClassifier = {k: v for k, v in ctor_AdaBoostClassifier.items() if v is not None}`;
    await this._py.ex`bridgeAdaBoostClassifier[${this.id}] = AdaBoostClassifier(**ctor_AdaBoostClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeAdaBoostClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the decision function of `X`.
   */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_AdaBoostClassifier_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AdaBoostClassifier_decision_function = {k: v for k, v in pms_AdaBoostClassifier_decision_function.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_decision_function = bridgeAdaBoostClassifier[${this.id}].decision_function(**pms_AdaBoostClassifier_decision_function)`;
    return this._py`res_AdaBoostClassifier_decision_function.tolist() if hasattr(res_AdaBoostClassifier_decision_function, 'tolist') else res_AdaBoostClassifier_decision_function`;
  }
  /**
    Build a boosted classifier/regressor from the training set (X, y).
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("AdaBoostClassifier must call init() before fit()");
    }
    await this._py.ex`pms_AdaBoostClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_AdaBoostClassifier_fit = {k: v for k, v in pms_AdaBoostClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_fit = bridgeAdaBoostClassifier[${this.id}].fit(**pms_AdaBoostClassifier_fit)`;
    return this._py`res_AdaBoostClassifier_fit.tolist() if hasattr(res_AdaBoostClassifier_fit, 'tolist') else res_AdaBoostClassifier_fit`;
  }
  /**
      Raise `NotImplementedError`.
  
      This estimator does not support metadata routing yet.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_AdaBoostClassifier_get_metadata_routing = {}

pms_AdaBoostClassifier_get_metadata_routing = {k: v for k, v in pms_AdaBoostClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_get_metadata_routing = bridgeAdaBoostClassifier[${this.id}].get_metadata_routing(**pms_AdaBoostClassifier_get_metadata_routing)`;
    return this._py`res_AdaBoostClassifier_get_metadata_routing.tolist() if hasattr(res_AdaBoostClassifier_get_metadata_routing, 'tolist') else res_AdaBoostClassifier_get_metadata_routing`;
  }
  /**
      Predict classes for X.
  
      The predicted class of an input sample is computed as the weighted mean prediction of the classifiers in the ensemble.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("AdaBoostClassifier must call init() before predict()");
    }
    await this._py.ex`pms_AdaBoostClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AdaBoostClassifier_predict = {k: v for k, v in pms_AdaBoostClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_predict = bridgeAdaBoostClassifier[${this.id}].predict(**pms_AdaBoostClassifier_predict)`;
    return this._py`res_AdaBoostClassifier_predict.tolist() if hasattr(res_AdaBoostClassifier_predict, 'tolist') else res_AdaBoostClassifier_predict`;
  }
  /**
      Predict class log-probabilities for X.
  
      The predicted class log-probabilities of an input sample is computed as the weighted mean predicted class log-probabilities of the classifiers in the ensemble.
     */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_AdaBoostClassifier_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AdaBoostClassifier_predict_log_proba = {k: v for k, v in pms_AdaBoostClassifier_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_predict_log_proba = bridgeAdaBoostClassifier[${this.id}].predict_log_proba(**pms_AdaBoostClassifier_predict_log_proba)`;
    return this._py`res_AdaBoostClassifier_predict_log_proba.tolist() if hasattr(res_AdaBoostClassifier_predict_log_proba, 'tolist') else res_AdaBoostClassifier_predict_log_proba`;
  }
  /**
      Predict class probabilities for X.
  
      The predicted class probabilities of an input sample is computed as the weighted mean predicted class probabilities of the classifiers in the ensemble.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_AdaBoostClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AdaBoostClassifier_predict_proba = {k: v for k, v in pms_AdaBoostClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_predict_proba = bridgeAdaBoostClassifier[${this.id}].predict_proba(**pms_AdaBoostClassifier_predict_proba)`;
    return this._py`res_AdaBoostClassifier_predict_proba.tolist() if hasattr(res_AdaBoostClassifier_predict_proba, 'tolist') else res_AdaBoostClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("AdaBoostClassifier must call init() before score()");
    }
    await this._py.ex`pms_AdaBoostClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_AdaBoostClassifier_score = {k: v for k, v in pms_AdaBoostClassifier_score.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_score = bridgeAdaBoostClassifier[${this.id}].score(**pms_AdaBoostClassifier_score)`;
    return this._py`res_AdaBoostClassifier_score.tolist() if hasattr(res_AdaBoostClassifier_score, 'tolist') else res_AdaBoostClassifier_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_AdaBoostClassifier_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_AdaBoostClassifier_set_fit_request = {k: v for k, v in pms_AdaBoostClassifier_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_set_fit_request = bridgeAdaBoostClassifier[${this.id}].set_fit_request(**pms_AdaBoostClassifier_set_fit_request)`;
    return this._py`res_AdaBoostClassifier_set_fit_request.tolist() if hasattr(res_AdaBoostClassifier_set_fit_request, 'tolist') else res_AdaBoostClassifier_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_AdaBoostClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_AdaBoostClassifier_set_score_request = {k: v for k, v in pms_AdaBoostClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_set_score_request = bridgeAdaBoostClassifier[${this.id}].set_score_request(**pms_AdaBoostClassifier_set_score_request)`;
    return this._py`res_AdaBoostClassifier_set_score_request.tolist() if hasattr(res_AdaBoostClassifier_set_score_request, 'tolist') else res_AdaBoostClassifier_set_score_request`;
  }
  /**
      Compute decision function of `X` for each boosting iteration.
  
      This method allows monitoring (i.e. determine error on testing set) after each boosting iteration.
     */
  async staged_decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before staged_decision_function()"
      );
    }
    await this._py.ex`pms_AdaBoostClassifier_staged_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AdaBoostClassifier_staged_decision_function = {k: v for k, v in pms_AdaBoostClassifier_staged_decision_function.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_staged_decision_function = bridgeAdaBoostClassifier[${this.id}].staged_decision_function(**pms_AdaBoostClassifier_staged_decision_function)`;
    return this._py`res_AdaBoostClassifier_staged_decision_function.tolist() if hasattr(res_AdaBoostClassifier_staged_decision_function, 'tolist') else res_AdaBoostClassifier_staged_decision_function`;
  }
  /**
      Return staged predictions for X.
  
      The predicted class of an input sample is computed as the weighted mean prediction of the classifiers in the ensemble.
  
      This generator method yields the ensemble prediction after each iteration of boosting and therefore allows monitoring, such as to determine the prediction on a test set after each boost.
     */
  async staged_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before staged_predict()"
      );
    }
    await this._py.ex`pms_AdaBoostClassifier_staged_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AdaBoostClassifier_staged_predict = {k: v for k, v in pms_AdaBoostClassifier_staged_predict.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_staged_predict = bridgeAdaBoostClassifier[${this.id}].staged_predict(**pms_AdaBoostClassifier_staged_predict)`;
    return this._py`res_AdaBoostClassifier_staged_predict.tolist() if hasattr(res_AdaBoostClassifier_staged_predict, 'tolist') else res_AdaBoostClassifier_staged_predict`;
  }
  /**
      Predict class probabilities for X.
  
      The predicted class probabilities of an input sample is computed as the weighted mean predicted class probabilities of the classifiers in the ensemble.
  
      This generator method yields the ensemble predicted class probabilities after each iteration of boosting and therefore allows monitoring, such as to determine the predicted class probabilities on a test set after each boost.
     */
  async staged_predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before staged_predict_proba()"
      );
    }
    await this._py.ex`pms_AdaBoostClassifier_staged_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AdaBoostClassifier_staged_predict_proba = {k: v for k, v in pms_AdaBoostClassifier_staged_predict_proba.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_staged_predict_proba = bridgeAdaBoostClassifier[${this.id}].staged_predict_proba(**pms_AdaBoostClassifier_staged_predict_proba)`;
    return this._py`res_AdaBoostClassifier_staged_predict_proba.tolist() if hasattr(res_AdaBoostClassifier_staged_predict_proba, 'tolist') else res_AdaBoostClassifier_staged_predict_proba`;
  }
  /**
      Return staged scores for X, y.
  
      This generator method yields the ensemble score after each iteration of boosting and therefore allows monitoring, such as to determine the score on a test set after each boost.
     */
  async staged_score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before staged_score()"
      );
    }
    await this._py.ex`pms_AdaBoostClassifier_staged_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_AdaBoostClassifier_staged_score = {k: v for k, v in pms_AdaBoostClassifier_staged_score.items() if v is not None}`;
    await this._py.ex`res_AdaBoostClassifier_staged_score = bridgeAdaBoostClassifier[${this.id}].staged_score(**pms_AdaBoostClassifier_staged_score)`;
    return this._py`res_AdaBoostClassifier_staged_score.tolist() if hasattr(res_AdaBoostClassifier_staged_score, 'tolist') else res_AdaBoostClassifier_staged_score`;
  }
  /**
    The base estimator from which the ensemble is grown.
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before accessing estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostClassifier_estimator_ = bridgeAdaBoostClassifier[${this.id}].estimator_`;
      return this._py`attr_AdaBoostClassifier_estimator_.tolist() if hasattr(attr_AdaBoostClassifier_estimator_, 'tolist') else attr_AdaBoostClassifier_estimator_`;
    })();
  }
  /**
    The collection of fitted sub-estimators.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostClassifier_estimators_ = bridgeAdaBoostClassifier[${this.id}].estimators_`;
      return this._py`attr_AdaBoostClassifier_estimators_.tolist() if hasattr(attr_AdaBoostClassifier_estimators_, 'tolist') else attr_AdaBoostClassifier_estimators_`;
    })();
  }
  /**
    The classes labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostClassifier_classes_ = bridgeAdaBoostClassifier[${this.id}].classes_`;
      return this._py`attr_AdaBoostClassifier_classes_.tolist() if hasattr(attr_AdaBoostClassifier_classes_, 'tolist') else attr_AdaBoostClassifier_classes_`;
    })();
  }
  /**
    The number of classes.
   */
  get n_classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before accessing n_classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostClassifier_n_classes_ = bridgeAdaBoostClassifier[${this.id}].n_classes_`;
      return this._py`attr_AdaBoostClassifier_n_classes_.tolist() if hasattr(attr_AdaBoostClassifier_n_classes_, 'tolist') else attr_AdaBoostClassifier_n_classes_`;
    })();
  }
  /**
    Weights for each estimator in the boosted ensemble.
   */
  get estimator_weights_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before accessing estimator_weights_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostClassifier_estimator_weights_ = bridgeAdaBoostClassifier[${this.id}].estimator_weights_`;
      return this._py`attr_AdaBoostClassifier_estimator_weights_.tolist() if hasattr(attr_AdaBoostClassifier_estimator_weights_, 'tolist') else attr_AdaBoostClassifier_estimator_weights_`;
    })();
  }
  /**
    Classification error for each estimator in the boosted ensemble.
   */
  get estimator_errors_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before accessing estimator_errors_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostClassifier_estimator_errors_ = bridgeAdaBoostClassifier[${this.id}].estimator_errors_`;
      return this._py`attr_AdaBoostClassifier_estimator_errors_.tolist() if hasattr(attr_AdaBoostClassifier_estimator_errors_, 'tolist') else attr_AdaBoostClassifier_estimator_errors_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostClassifier_n_features_in_ = bridgeAdaBoostClassifier[${this.id}].n_features_in_`;
      return this._py`attr_AdaBoostClassifier_n_features_in_.tolist() if hasattr(attr_AdaBoostClassifier_n_features_in_, 'tolist') else attr_AdaBoostClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostClassifier_feature_names_in_ = bridgeAdaBoostClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_AdaBoostClassifier_feature_names_in_.tolist() if hasattr(attr_AdaBoostClassifier_feature_names_in_, 'tolist') else attr_AdaBoostClassifier_feature_names_in_`;
    })();
  }
};

// src/generated/ensemble/AdaBoostRegressor.ts
import crypto50 from "node:crypto";
var AdaBoostRegressor = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `AdaBoostRegressor${crypto50.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("AdaBoostRegressor.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import AdaBoostRegressor
try: bridgeAdaBoostRegressor
except NameError: bridgeAdaBoostRegressor = {}
`;
    await this._py.ex`ctor_AdaBoostRegressor = {'estimator': ${this.opts["estimator"] ?? void 0}, 'n_estimators': ${this.opts["n_estimators"] ?? void 0}, 'learning_rate': ${this.opts["learning_rate"] ?? void 0}, 'loss': ${this.opts["loss"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_AdaBoostRegressor = {k: v for k, v in ctor_AdaBoostRegressor.items() if v is not None}`;
    await this._py.ex`bridgeAdaBoostRegressor[${this.id}] = AdaBoostRegressor(**ctor_AdaBoostRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeAdaBoostRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Build a boosted classifier/regressor from the training set (X, y).
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("AdaBoostRegressor must call init() before fit()");
    }
    await this._py.ex`pms_AdaBoostRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_AdaBoostRegressor_fit = {k: v for k, v in pms_AdaBoostRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_AdaBoostRegressor_fit = bridgeAdaBoostRegressor[${this.id}].fit(**pms_AdaBoostRegressor_fit)`;
    return this._py`res_AdaBoostRegressor_fit.tolist() if hasattr(res_AdaBoostRegressor_fit, 'tolist') else res_AdaBoostRegressor_fit`;
  }
  /**
      Raise `NotImplementedError`.
  
      This estimator does not support metadata routing yet.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_AdaBoostRegressor_get_metadata_routing = {}

pms_AdaBoostRegressor_get_metadata_routing = {k: v for k, v in pms_AdaBoostRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_AdaBoostRegressor_get_metadata_routing = bridgeAdaBoostRegressor[${this.id}].get_metadata_routing(**pms_AdaBoostRegressor_get_metadata_routing)`;
    return this._py`res_AdaBoostRegressor_get_metadata_routing.tolist() if hasattr(res_AdaBoostRegressor_get_metadata_routing, 'tolist') else res_AdaBoostRegressor_get_metadata_routing`;
  }
  /**
      Predict regression value for X.
  
      The predicted regression value of an input sample is computed as the weighted median prediction of the regressors in the ensemble.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("AdaBoostRegressor must call init() before predict()");
    }
    await this._py.ex`pms_AdaBoostRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AdaBoostRegressor_predict = {k: v for k, v in pms_AdaBoostRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_AdaBoostRegressor_predict = bridgeAdaBoostRegressor[${this.id}].predict(**pms_AdaBoostRegressor_predict)`;
    return this._py`res_AdaBoostRegressor_predict.tolist() if hasattr(res_AdaBoostRegressor_predict, 'tolist') else res_AdaBoostRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y_true \- y_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y_true \- y_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("AdaBoostRegressor must call init() before score()");
    }
    await this._py.ex`pms_AdaBoostRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_AdaBoostRegressor_score = {k: v for k, v in pms_AdaBoostRegressor_score.items() if v is not None}`;
    await this._py.ex`res_AdaBoostRegressor_score = bridgeAdaBoostRegressor[${this.id}].score(**pms_AdaBoostRegressor_score)`;
    return this._py`res_AdaBoostRegressor_score.tolist() if hasattr(res_AdaBoostRegressor_score, 'tolist') else res_AdaBoostRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_AdaBoostRegressor_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_AdaBoostRegressor_set_fit_request = {k: v for k, v in pms_AdaBoostRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_AdaBoostRegressor_set_fit_request = bridgeAdaBoostRegressor[${this.id}].set_fit_request(**pms_AdaBoostRegressor_set_fit_request)`;
    return this._py`res_AdaBoostRegressor_set_fit_request.tolist() if hasattr(res_AdaBoostRegressor_set_fit_request, 'tolist') else res_AdaBoostRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_AdaBoostRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_AdaBoostRegressor_set_score_request = {k: v for k, v in pms_AdaBoostRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_AdaBoostRegressor_set_score_request = bridgeAdaBoostRegressor[${this.id}].set_score_request(**pms_AdaBoostRegressor_set_score_request)`;
    return this._py`res_AdaBoostRegressor_set_score_request.tolist() if hasattr(res_AdaBoostRegressor_set_score_request, 'tolist') else res_AdaBoostRegressor_set_score_request`;
  }
  /**
      Return staged predictions for X.
  
      The predicted regression value of an input sample is computed as the weighted median prediction of the regressors in the ensemble.
  
      This generator method yields the ensemble prediction after each iteration of boosting and therefore allows monitoring, such as to determine the prediction on a test set after each boost.
     */
  async staged_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostRegressor must call init() before staged_predict()"
      );
    }
    await this._py.ex`pms_AdaBoostRegressor_staged_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_AdaBoostRegressor_staged_predict = {k: v for k, v in pms_AdaBoostRegressor_staged_predict.items() if v is not None}`;
    await this._py.ex`res_AdaBoostRegressor_staged_predict = bridgeAdaBoostRegressor[${this.id}].staged_predict(**pms_AdaBoostRegressor_staged_predict)`;
    return this._py`res_AdaBoostRegressor_staged_predict.tolist() if hasattr(res_AdaBoostRegressor_staged_predict, 'tolist') else res_AdaBoostRegressor_staged_predict`;
  }
  /**
      Return staged scores for X, y.
  
      This generator method yields the ensemble score after each iteration of boosting and therefore allows monitoring, such as to determine the score on a test set after each boost.
     */
  async staged_score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostRegressor must call init() before staged_score()"
      );
    }
    await this._py.ex`pms_AdaBoostRegressor_staged_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_AdaBoostRegressor_staged_score = {k: v for k, v in pms_AdaBoostRegressor_staged_score.items() if v is not None}`;
    await this._py.ex`res_AdaBoostRegressor_staged_score = bridgeAdaBoostRegressor[${this.id}].staged_score(**pms_AdaBoostRegressor_staged_score)`;
    return this._py`res_AdaBoostRegressor_staged_score.tolist() if hasattr(res_AdaBoostRegressor_staged_score, 'tolist') else res_AdaBoostRegressor_staged_score`;
  }
  /**
    The base estimator from which the ensemble is grown.
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostRegressor must call init() before accessing estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostRegressor_estimator_ = bridgeAdaBoostRegressor[${this.id}].estimator_`;
      return this._py`attr_AdaBoostRegressor_estimator_.tolist() if hasattr(attr_AdaBoostRegressor_estimator_, 'tolist') else attr_AdaBoostRegressor_estimator_`;
    })();
  }
  /**
    The collection of fitted sub-estimators.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostRegressor must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostRegressor_estimators_ = bridgeAdaBoostRegressor[${this.id}].estimators_`;
      return this._py`attr_AdaBoostRegressor_estimators_.tolist() if hasattr(attr_AdaBoostRegressor_estimators_, 'tolist') else attr_AdaBoostRegressor_estimators_`;
    })();
  }
  /**
    Weights for each estimator in the boosted ensemble.
   */
  get estimator_weights_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostRegressor must call init() before accessing estimator_weights_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostRegressor_estimator_weights_ = bridgeAdaBoostRegressor[${this.id}].estimator_weights_`;
      return this._py`attr_AdaBoostRegressor_estimator_weights_.tolist() if hasattr(attr_AdaBoostRegressor_estimator_weights_, 'tolist') else attr_AdaBoostRegressor_estimator_weights_`;
    })();
  }
  /**
    Regression error for each estimator in the boosted ensemble.
   */
  get estimator_errors_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostRegressor must call init() before accessing estimator_errors_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostRegressor_estimator_errors_ = bridgeAdaBoostRegressor[${this.id}].estimator_errors_`;
      return this._py`attr_AdaBoostRegressor_estimator_errors_.tolist() if hasattr(attr_AdaBoostRegressor_estimator_errors_, 'tolist') else attr_AdaBoostRegressor_estimator_errors_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostRegressor_n_features_in_ = bridgeAdaBoostRegressor[${this.id}].n_features_in_`;
      return this._py`attr_AdaBoostRegressor_n_features_in_.tolist() if hasattr(attr_AdaBoostRegressor_n_features_in_, 'tolist') else attr_AdaBoostRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This AdaBoostRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "AdaBoostRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_AdaBoostRegressor_feature_names_in_ = bridgeAdaBoostRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_AdaBoostRegressor_feature_names_in_.tolist() if hasattr(attr_AdaBoostRegressor_feature_names_in_, 'tolist') else attr_AdaBoostRegressor_feature_names_in_`;
    })();
  }
};

// src/generated/ensemble/BaggingClassifier.ts
import crypto51 from "node:crypto";
var BaggingClassifier = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `BaggingClassifier${crypto51.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("BaggingClassifier.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import BaggingClassifier
try: bridgeBaggingClassifier
except NameError: bridgeBaggingClassifier = {}
`;
    await this._py.ex`ctor_BaggingClassifier = {'estimator': ${this.opts["estimator"] ?? void 0}, 'n_estimators': ${this.opts["n_estimators"] ?? void 0}, 'max_samples': ${this.opts["max_samples"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'bootstrap': ${this.opts["bootstrap"] ?? void 0}, 'bootstrap_features': ${this.opts["bootstrap_features"] ?? void 0}, 'oob_score': ${this.opts["oob_score"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_BaggingClassifier = {k: v for k, v in ctor_BaggingClassifier.items() if v is not None}`;
    await this._py.ex`bridgeBaggingClassifier[${this.id}] = BaggingClassifier(**ctor_BaggingClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeBaggingClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Average of the decision functions of the base classifiers.
   */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_BaggingClassifier_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BaggingClassifier_decision_function = {k: v for k, v in pms_BaggingClassifier_decision_function.items() if v is not None}`;
    await this._py.ex`res_BaggingClassifier_decision_function = bridgeBaggingClassifier[${this.id}].decision_function(**pms_BaggingClassifier_decision_function)`;
    return this._py`res_BaggingClassifier_decision_function.tolist() if hasattr(res_BaggingClassifier_decision_function, 'tolist') else res_BaggingClassifier_decision_function`;
  }
  /**
    Build a Bagging ensemble of estimators from the training set (X, y).
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("BaggingClassifier must call init() before fit()");
    }
    await this._py.ex`pms_BaggingClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_BaggingClassifier_fit = {k: v for k, v in pms_BaggingClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_BaggingClassifier_fit = bridgeBaggingClassifier[${this.id}].fit(**pms_BaggingClassifier_fit)`;
    return this._py`res_BaggingClassifier_fit.tolist() if hasattr(res_BaggingClassifier_fit, 'tolist') else res_BaggingClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_BaggingClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_BaggingClassifier_get_metadata_routing = {k: v for k, v in pms_BaggingClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_BaggingClassifier_get_metadata_routing = bridgeBaggingClassifier[${this.id}].get_metadata_routing(**pms_BaggingClassifier_get_metadata_routing)`;
    return this._py`res_BaggingClassifier_get_metadata_routing.tolist() if hasattr(res_BaggingClassifier_get_metadata_routing, 'tolist') else res_BaggingClassifier_get_metadata_routing`;
  }
  /**
      Predict class for X.
  
      The predicted class of an input sample is computed as the class with the highest mean predicted probability. If base estimators do not implement a `predict_proba` method, then it resorts to voting.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("BaggingClassifier must call init() before predict()");
    }
    await this._py.ex`pms_BaggingClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BaggingClassifier_predict = {k: v for k, v in pms_BaggingClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_BaggingClassifier_predict = bridgeBaggingClassifier[${this.id}].predict(**pms_BaggingClassifier_predict)`;
    return this._py`res_BaggingClassifier_predict.tolist() if hasattr(res_BaggingClassifier_predict, 'tolist') else res_BaggingClassifier_predict`;
  }
  /**
      Predict class log-probabilities for X.
  
      The predicted class log-probabilities of an input sample is computed as the log of the mean predicted class probabilities of the base estimators in the ensemble.
     */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_BaggingClassifier_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BaggingClassifier_predict_log_proba = {k: v for k, v in pms_BaggingClassifier_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_BaggingClassifier_predict_log_proba = bridgeBaggingClassifier[${this.id}].predict_log_proba(**pms_BaggingClassifier_predict_log_proba)`;
    return this._py`res_BaggingClassifier_predict_log_proba.tolist() if hasattr(res_BaggingClassifier_predict_log_proba, 'tolist') else res_BaggingClassifier_predict_log_proba`;
  }
  /**
      Predict class probabilities for X.
  
      The predicted class probabilities of an input sample is computed as the mean predicted class probabilities of the base estimators in the ensemble. If base estimators do not implement a `predict_proba` method, then it resorts to voting and the predicted class probabilities of an input sample represents the proportion of estimators predicting each class.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_BaggingClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BaggingClassifier_predict_proba = {k: v for k, v in pms_BaggingClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_BaggingClassifier_predict_proba = bridgeBaggingClassifier[${this.id}].predict_proba(**pms_BaggingClassifier_predict_proba)`;
    return this._py`res_BaggingClassifier_predict_proba.tolist() if hasattr(res_BaggingClassifier_predict_proba, 'tolist') else res_BaggingClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("BaggingClassifier must call init() before score()");
    }
    await this._py.ex`pms_BaggingClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BaggingClassifier_score = {k: v for k, v in pms_BaggingClassifier_score.items() if v is not None}`;
    await this._py.ex`res_BaggingClassifier_score = bridgeBaggingClassifier[${this.id}].score(**pms_BaggingClassifier_score)`;
    return this._py`res_BaggingClassifier_score.tolist() if hasattr(res_BaggingClassifier_score, 'tolist') else res_BaggingClassifier_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_BaggingClassifier_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_BaggingClassifier_set_fit_request = {k: v for k, v in pms_BaggingClassifier_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_BaggingClassifier_set_fit_request = bridgeBaggingClassifier[${this.id}].set_fit_request(**pms_BaggingClassifier_set_fit_request)`;
    return this._py`res_BaggingClassifier_set_fit_request.tolist() if hasattr(res_BaggingClassifier_set_fit_request, 'tolist') else res_BaggingClassifier_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_BaggingClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_BaggingClassifier_set_score_request = {k: v for k, v in pms_BaggingClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_BaggingClassifier_set_score_request = bridgeBaggingClassifier[${this.id}].set_score_request(**pms_BaggingClassifier_set_score_request)`;
    return this._py`res_BaggingClassifier_set_score_request.tolist() if hasattr(res_BaggingClassifier_set_score_request, 'tolist') else res_BaggingClassifier_set_score_request`;
  }
  /**
    The base estimator from which the ensemble is grown.
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before accessing estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingClassifier_estimator_ = bridgeBaggingClassifier[${this.id}].estimator_`;
      return this._py`attr_BaggingClassifier_estimator_.tolist() if hasattr(attr_BaggingClassifier_estimator_, 'tolist') else attr_BaggingClassifier_estimator_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingClassifier_n_features_in_ = bridgeBaggingClassifier[${this.id}].n_features_in_`;
      return this._py`attr_BaggingClassifier_n_features_in_.tolist() if hasattr(attr_BaggingClassifier_n_features_in_, 'tolist') else attr_BaggingClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingClassifier_feature_names_in_ = bridgeBaggingClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_BaggingClassifier_feature_names_in_.tolist() if hasattr(attr_BaggingClassifier_feature_names_in_, 'tolist') else attr_BaggingClassifier_feature_names_in_`;
    })();
  }
  /**
    The collection of fitted base estimators.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingClassifier_estimators_ = bridgeBaggingClassifier[${this.id}].estimators_`;
      return this._py`attr_BaggingClassifier_estimators_.tolist() if hasattr(attr_BaggingClassifier_estimators_, 'tolist') else attr_BaggingClassifier_estimators_`;
    })();
  }
  /**
    The subset of drawn features for each base estimator.
   */
  get estimators_features_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before accessing estimators_features_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingClassifier_estimators_features_ = bridgeBaggingClassifier[${this.id}].estimators_features_`;
      return this._py`attr_BaggingClassifier_estimators_features_.tolist() if hasattr(attr_BaggingClassifier_estimators_features_, 'tolist') else attr_BaggingClassifier_estimators_features_`;
    })();
  }
  /**
    The classes labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingClassifier_classes_ = bridgeBaggingClassifier[${this.id}].classes_`;
      return this._py`attr_BaggingClassifier_classes_.tolist() if hasattr(attr_BaggingClassifier_classes_, 'tolist') else attr_BaggingClassifier_classes_`;
    })();
  }
  /**
    The number of classes.
   */
  get n_classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before accessing n_classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingClassifier_n_classes_ = bridgeBaggingClassifier[${this.id}].n_classes_`;
      return this._py`attr_BaggingClassifier_n_classes_.tolist() if hasattr(attr_BaggingClassifier_n_classes_, 'tolist') else attr_BaggingClassifier_n_classes_`;
    })();
  }
  /**
    Score of the training dataset obtained using an out-of-bag estimate. This attribute exists only when `oob_score` is `true`.
   */
  get oob_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before accessing oob_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingClassifier_oob_score_ = bridgeBaggingClassifier[${this.id}].oob_score_`;
      return this._py`attr_BaggingClassifier_oob_score_.tolist() if hasattr(attr_BaggingClassifier_oob_score_, 'tolist') else attr_BaggingClassifier_oob_score_`;
    })();
  }
  /**
    Decision function computed with out-of-bag estimate on the training set. If n_estimators is small it might be possible that a data point was never left out during the bootstrap. In this case, `oob_decision_function_` might contain NaN. This attribute exists only when `oob_score` is `true`.
   */
  get oob_decision_function_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingClassifier must call init() before accessing oob_decision_function_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingClassifier_oob_decision_function_ = bridgeBaggingClassifier[${this.id}].oob_decision_function_`;
      return this._py`attr_BaggingClassifier_oob_decision_function_.tolist() if hasattr(attr_BaggingClassifier_oob_decision_function_, 'tolist') else attr_BaggingClassifier_oob_decision_function_`;
    })();
  }
};

// src/generated/ensemble/BaggingRegressor.ts
import crypto52 from "node:crypto";
var BaggingRegressor = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `BaggingRegressor${crypto52.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("BaggingRegressor.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import BaggingRegressor
try: bridgeBaggingRegressor
except NameError: bridgeBaggingRegressor = {}
`;
    await this._py.ex`ctor_BaggingRegressor = {'estimator': ${this.opts["estimator"] ?? void 0}, 'n_estimators': ${this.opts["n_estimators"] ?? void 0}, 'max_samples': ${this.opts["max_samples"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'bootstrap': ${this.opts["bootstrap"] ?? void 0}, 'bootstrap_features': ${this.opts["bootstrap_features"] ?? void 0}, 'oob_score': ${this.opts["oob_score"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}}

ctor_BaggingRegressor = {k: v for k, v in ctor_BaggingRegressor.items() if v is not None}`;
    await this._py.ex`bridgeBaggingRegressor[${this.id}] = BaggingRegressor(**ctor_BaggingRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeBaggingRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Build a Bagging ensemble of estimators from the training set (X, y).
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("BaggingRegressor must call init() before fit()");
    }
    await this._py.ex`pms_BaggingRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'fit_params': ${opts["fit_params"] ?? void 0}}

pms_BaggingRegressor_fit = {k: v for k, v in pms_BaggingRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_BaggingRegressor_fit = bridgeBaggingRegressor[${this.id}].fit(**pms_BaggingRegressor_fit)`;
    return this._py`res_BaggingRegressor_fit.tolist() if hasattr(res_BaggingRegressor_fit, 'tolist') else res_BaggingRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_BaggingRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_BaggingRegressor_get_metadata_routing = {k: v for k, v in pms_BaggingRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_BaggingRegressor_get_metadata_routing = bridgeBaggingRegressor[${this.id}].get_metadata_routing(**pms_BaggingRegressor_get_metadata_routing)`;
    return this._py`res_BaggingRegressor_get_metadata_routing.tolist() if hasattr(res_BaggingRegressor_get_metadata_routing, 'tolist') else res_BaggingRegressor_get_metadata_routing`;
  }
  /**
      Predict regression target for X.
  
      The predicted regression target of an input sample is computed as the mean predicted regression targets of the estimators in the ensemble.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("BaggingRegressor must call init() before predict()");
    }
    await this._py.ex`pms_BaggingRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_BaggingRegressor_predict = {k: v for k, v in pms_BaggingRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_BaggingRegressor_predict = bridgeBaggingRegressor[${this.id}].predict(**pms_BaggingRegressor_predict)`;
    return this._py`res_BaggingRegressor_predict.tolist() if hasattr(res_BaggingRegressor_predict, 'tolist') else res_BaggingRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y_true \- y_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y_true \- y_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("BaggingRegressor must call init() before score()");
    }
    await this._py.ex`pms_BaggingRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_BaggingRegressor_score = {k: v for k, v in pms_BaggingRegressor_score.items() if v is not None}`;
    await this._py.ex`res_BaggingRegressor_score = bridgeBaggingRegressor[${this.id}].score(**pms_BaggingRegressor_score)`;
    return this._py`res_BaggingRegressor_score.tolist() if hasattr(res_BaggingRegressor_score, 'tolist') else res_BaggingRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_BaggingRegressor_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_BaggingRegressor_set_fit_request = {k: v for k, v in pms_BaggingRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_BaggingRegressor_set_fit_request = bridgeBaggingRegressor[${this.id}].set_fit_request(**pms_BaggingRegressor_set_fit_request)`;
    return this._py`res_BaggingRegressor_set_fit_request.tolist() if hasattr(res_BaggingRegressor_set_fit_request, 'tolist') else res_BaggingRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_BaggingRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_BaggingRegressor_set_score_request = {k: v for k, v in pms_BaggingRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_BaggingRegressor_set_score_request = bridgeBaggingRegressor[${this.id}].set_score_request(**pms_BaggingRegressor_set_score_request)`;
    return this._py`res_BaggingRegressor_set_score_request.tolist() if hasattr(res_BaggingRegressor_set_score_request, 'tolist') else res_BaggingRegressor_set_score_request`;
  }
  /**
    The base estimator from which the ensemble is grown.
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingRegressor must call init() before accessing estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingRegressor_estimator_ = bridgeBaggingRegressor[${this.id}].estimator_`;
      return this._py`attr_BaggingRegressor_estimator_.tolist() if hasattr(attr_BaggingRegressor_estimator_, 'tolist') else attr_BaggingRegressor_estimator_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingRegressor_n_features_in_ = bridgeBaggingRegressor[${this.id}].n_features_in_`;
      return this._py`attr_BaggingRegressor_n_features_in_.tolist() if hasattr(attr_BaggingRegressor_n_features_in_, 'tolist') else attr_BaggingRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingRegressor_feature_names_in_ = bridgeBaggingRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_BaggingRegressor_feature_names_in_.tolist() if hasattr(attr_BaggingRegressor_feature_names_in_, 'tolist') else attr_BaggingRegressor_feature_names_in_`;
    })();
  }
  /**
    The collection of fitted sub-estimators.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingRegressor must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingRegressor_estimators_ = bridgeBaggingRegressor[${this.id}].estimators_`;
      return this._py`attr_BaggingRegressor_estimators_.tolist() if hasattr(attr_BaggingRegressor_estimators_, 'tolist') else attr_BaggingRegressor_estimators_`;
    })();
  }
  /**
    The subset of drawn features for each base estimator.
   */
  get estimators_features_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingRegressor must call init() before accessing estimators_features_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingRegressor_estimators_features_ = bridgeBaggingRegressor[${this.id}].estimators_features_`;
      return this._py`attr_BaggingRegressor_estimators_features_.tolist() if hasattr(attr_BaggingRegressor_estimators_features_, 'tolist') else attr_BaggingRegressor_estimators_features_`;
    })();
  }
  /**
    Score of the training dataset obtained using an out-of-bag estimate. This attribute exists only when `oob_score` is `true`.
   */
  get oob_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingRegressor must call init() before accessing oob_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingRegressor_oob_score_ = bridgeBaggingRegressor[${this.id}].oob_score_`;
      return this._py`attr_BaggingRegressor_oob_score_.tolist() if hasattr(attr_BaggingRegressor_oob_score_, 'tolist') else attr_BaggingRegressor_oob_score_`;
    })();
  }
  /**
    Prediction computed with out-of-bag estimate on the training set. If n_estimators is small it might be possible that a data point was never left out during the bootstrap. In this case, `oob_prediction_` might contain NaN. This attribute exists only when `oob_score` is `true`.
   */
  get oob_prediction_() {
    if (this._isDisposed) {
      throw new Error(
        "This BaggingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "BaggingRegressor must call init() before accessing oob_prediction_"
      );
    }
    return (async () => {
      await this._py.ex`attr_BaggingRegressor_oob_prediction_ = bridgeBaggingRegressor[${this.id}].oob_prediction_`;
      return this._py`attr_BaggingRegressor_oob_prediction_.tolist() if hasattr(attr_BaggingRegressor_oob_prediction_, 'tolist') else attr_BaggingRegressor_oob_prediction_`;
    })();
  }
};

// src/generated/ensemble/ExtraTreesClassifier.ts
import crypto53 from "node:crypto";
var ExtraTreesClassifier = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `ExtraTreesClassifier${crypto53.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "ExtraTreesClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import ExtraTreesClassifier
try: bridgeExtraTreesClassifier
except NameError: bridgeExtraTreesClassifier = {}
`;
    await this._py.ex`ctor_ExtraTreesClassifier = {'n_estimators': ${this.opts["n_estimators"] ?? void 0}, 'criterion': ${this.opts["criterion"] ?? void 0}, 'max_depth': ${this.opts["max_depth"] ?? void 0}, 'min_samples_split': ${this.opts["min_samples_split"] ?? void 0}, 'min_samples_leaf': ${this.opts["min_samples_leaf"] ?? void 0}, 'min_weight_fraction_leaf': ${this.opts["min_weight_fraction_leaf"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'max_leaf_nodes': ${this.opts["max_leaf_nodes"] ?? void 0}, 'min_impurity_decrease': ${this.opts["min_impurity_decrease"] ?? void 0}, 'bootstrap': ${this.opts["bootstrap"] ?? void 0}, 'oob_score': ${this.opts["oob_score"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}, 'ccp_alpha': ${this.opts["ccp_alpha"] ?? void 0}, 'max_samples': ${this.opts["max_samples"] ?? void 0}, 'monotonic_cst': np.array(${this.opts["monotonic_cst"] ?? void 0}) if ${this.opts["monotonic_cst"] !== void 0} else None}

ctor_ExtraTreesClassifier = {k: v for k, v in ctor_ExtraTreesClassifier.items() if v is not None}`;
    await this._py.ex`bridgeExtraTreesClassifier[${this.id}] = ExtraTreesClassifier(**ctor_ExtraTreesClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeExtraTreesClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Apply trees in the forest to X, return leaf indices.
   */
  async apply(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ExtraTreesClassifier must call init() before apply()");
    }
    await this._py.ex`pms_ExtraTreesClassifier_apply = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ExtraTreesClassifier_apply = {k: v for k, v in pms_ExtraTreesClassifier_apply.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesClassifier_apply = bridgeExtraTreesClassifier[${this.id}].apply(**pms_ExtraTreesClassifier_apply)`;
    return this._py`res_ExtraTreesClassifier_apply.tolist() if hasattr(res_ExtraTreesClassifier_apply, 'tolist') else res_ExtraTreesClassifier_apply`;
  }
  /**
    Return the decision path in the forest.
   */
  async decision_path(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before decision_path()"
      );
    }
    await this._py.ex`pms_ExtraTreesClassifier_decision_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ExtraTreesClassifier_decision_path = {k: v for k, v in pms_ExtraTreesClassifier_decision_path.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesClassifier_decision_path = bridgeExtraTreesClassifier[${this.id}].decision_path(**pms_ExtraTreesClassifier_decision_path)`;
    return this._py`res_ExtraTreesClassifier_decision_path.tolist() if hasattr(res_ExtraTreesClassifier_decision_path, 'tolist') else res_ExtraTreesClassifier_decision_path`;
  }
  /**
    Build a forest of trees from the training set (X, y).
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ExtraTreesClassifier must call init() before fit()");
    }
    await this._py.ex`pms_ExtraTreesClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_ExtraTreesClassifier_fit = {k: v for k, v in pms_ExtraTreesClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesClassifier_fit = bridgeExtraTreesClassifier[${this.id}].fit(**pms_ExtraTreesClassifier_fit)`;
    return this._py`res_ExtraTreesClassifier_fit.tolist() if hasattr(res_ExtraTreesClassifier_fit, 'tolist') else res_ExtraTreesClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_ExtraTreesClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_ExtraTreesClassifier_get_metadata_routing = {k: v for k, v in pms_ExtraTreesClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesClassifier_get_metadata_routing = bridgeExtraTreesClassifier[${this.id}].get_metadata_routing(**pms_ExtraTreesClassifier_get_metadata_routing)`;
    return this._py`res_ExtraTreesClassifier_get_metadata_routing.tolist() if hasattr(res_ExtraTreesClassifier_get_metadata_routing, 'tolist') else res_ExtraTreesClassifier_get_metadata_routing`;
  }
  /**
      Predict class for X.
  
      The predicted class of an input sample is a vote by the trees in the forest, weighted by their probability estimates. That is, the predicted class is the one with highest mean probability estimate across the trees.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ExtraTreesClassifier must call init() before predict()");
    }
    await this._py.ex`pms_ExtraTreesClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ExtraTreesClassifier_predict = {k: v for k, v in pms_ExtraTreesClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesClassifier_predict = bridgeExtraTreesClassifier[${this.id}].predict(**pms_ExtraTreesClassifier_predict)`;
    return this._py`res_ExtraTreesClassifier_predict.tolist() if hasattr(res_ExtraTreesClassifier_predict, 'tolist') else res_ExtraTreesClassifier_predict`;
  }
  /**
      Predict class log-probabilities for X.
  
      The predicted class log-probabilities of an input sample is computed as the log of the mean predicted class probabilities of the trees in the forest.
     */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_ExtraTreesClassifier_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ExtraTreesClassifier_predict_log_proba = {k: v for k, v in pms_ExtraTreesClassifier_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesClassifier_predict_log_proba = bridgeExtraTreesClassifier[${this.id}].predict_log_proba(**pms_ExtraTreesClassifier_predict_log_proba)`;
    return this._py`res_ExtraTreesClassifier_predict_log_proba.tolist() if hasattr(res_ExtraTreesClassifier_predict_log_proba, 'tolist') else res_ExtraTreesClassifier_predict_log_proba`;
  }
  /**
      Predict class probabilities for X.
  
      The predicted class probabilities of an input sample are computed as the mean predicted class probabilities of the trees in the forest. The class probability of a single tree is the fraction of samples of the same class in a leaf.
     */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_ExtraTreesClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ExtraTreesClassifier_predict_proba = {k: v for k, v in pms_ExtraTreesClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesClassifier_predict_proba = bridgeExtraTreesClassifier[${this.id}].predict_proba(**pms_ExtraTreesClassifier_predict_proba)`;
    return this._py`res_ExtraTreesClassifier_predict_proba.tolist() if hasattr(res_ExtraTreesClassifier_predict_proba, 'tolist') else res_ExtraTreesClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ExtraTreesClassifier must call init() before score()");
    }
    await this._py.ex`pms_ExtraTreesClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_ExtraTreesClassifier_score = {k: v for k, v in pms_ExtraTreesClassifier_score.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesClassifier_score = bridgeExtraTreesClassifier[${this.id}].score(**pms_ExtraTreesClassifier_score)`;
    return this._py`res_ExtraTreesClassifier_score.tolist() if hasattr(res_ExtraTreesClassifier_score, 'tolist') else res_ExtraTreesClassifier_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_ExtraTreesClassifier_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_ExtraTreesClassifier_set_fit_request = {k: v for k, v in pms_ExtraTreesClassifier_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesClassifier_set_fit_request = bridgeExtraTreesClassifier[${this.id}].set_fit_request(**pms_ExtraTreesClassifier_set_fit_request)`;
    return this._py`res_ExtraTreesClassifier_set_fit_request.tolist() if hasattr(res_ExtraTreesClassifier_set_fit_request, 'tolist') else res_ExtraTreesClassifier_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_ExtraTreesClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_ExtraTreesClassifier_set_score_request = {k: v for k, v in pms_ExtraTreesClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesClassifier_set_score_request = bridgeExtraTreesClassifier[${this.id}].set_score_request(**pms_ExtraTreesClassifier_set_score_request)`;
    return this._py`res_ExtraTreesClassifier_set_score_request.tolist() if hasattr(res_ExtraTreesClassifier_set_score_request, 'tolist') else res_ExtraTreesClassifier_set_score_request`;
  }
  /**
    The child estimator template used to create the collection of fitted sub-estimators.
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before accessing estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesClassifier_estimator_ = bridgeExtraTreesClassifier[${this.id}].estimator_`;
      return this._py`attr_ExtraTreesClassifier_estimator_.tolist() if hasattr(attr_ExtraTreesClassifier_estimator_, 'tolist') else attr_ExtraTreesClassifier_estimator_`;
    })();
  }
  /**
    The collection of fitted sub-estimators.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesClassifier_estimators_ = bridgeExtraTreesClassifier[${this.id}].estimators_`;
      return this._py`attr_ExtraTreesClassifier_estimators_.tolist() if hasattr(attr_ExtraTreesClassifier_estimators_, 'tolist') else attr_ExtraTreesClassifier_estimators_`;
    })();
  }
  /**
    The classes labels (single output problem), or a list of arrays of class labels (multi-output problem).
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesClassifier_classes_ = bridgeExtraTreesClassifier[${this.id}].classes_`;
      return this._py`attr_ExtraTreesClassifier_classes_.tolist() if hasattr(attr_ExtraTreesClassifier_classes_, 'tolist') else attr_ExtraTreesClassifier_classes_`;
    })();
  }
  /**
    The number of classes (single output problem), or a list containing the number of classes for each output (multi-output problem).
   */
  get n_classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before accessing n_classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesClassifier_n_classes_ = bridgeExtraTreesClassifier[${this.id}].n_classes_`;
      return this._py`attr_ExtraTreesClassifier_n_classes_.tolist() if hasattr(attr_ExtraTreesClassifier_n_classes_, 'tolist') else attr_ExtraTreesClassifier_n_classes_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesClassifier_n_features_in_ = bridgeExtraTreesClassifier[${this.id}].n_features_in_`;
      return this._py`attr_ExtraTreesClassifier_n_features_in_.tolist() if hasattr(attr_ExtraTreesClassifier_n_features_in_, 'tolist') else attr_ExtraTreesClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesClassifier_feature_names_in_ = bridgeExtraTreesClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_ExtraTreesClassifier_feature_names_in_.tolist() if hasattr(attr_ExtraTreesClassifier_feature_names_in_, 'tolist') else attr_ExtraTreesClassifier_feature_names_in_`;
    })();
  }
  /**
    The number of outputs when `fit` is performed.
   */
  get n_outputs_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before accessing n_outputs_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesClassifier_n_outputs_ = bridgeExtraTreesClassifier[${this.id}].n_outputs_`;
      return this._py`attr_ExtraTreesClassifier_n_outputs_.tolist() if hasattr(attr_ExtraTreesClassifier_n_outputs_, 'tolist') else attr_ExtraTreesClassifier_n_outputs_`;
    })();
  }
  /**
    Score of the training dataset obtained using an out-of-bag estimate. This attribute exists only when `oob_score` is `true`.
   */
  get oob_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before accessing oob_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesClassifier_oob_score_ = bridgeExtraTreesClassifier[${this.id}].oob_score_`;
      return this._py`attr_ExtraTreesClassifier_oob_score_.tolist() if hasattr(attr_ExtraTreesClassifier_oob_score_, 'tolist') else attr_ExtraTreesClassifier_oob_score_`;
    })();
  }
  /**
    Decision function computed with out-of-bag estimate on the training set. If n_estimators is small it might be possible that a data point was never left out during the bootstrap. In this case, `oob_decision_function_` might contain NaN. This attribute exists only when `oob_score` is `true`.
   */
  get oob_decision_function_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesClassifier must call init() before accessing oob_decision_function_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesClassifier_oob_decision_function_ = bridgeExtraTreesClassifier[${this.id}].oob_decision_function_`;
      return this._py`attr_ExtraTreesClassifier_oob_decision_function_.tolist() if hasattr(attr_ExtraTreesClassifier_oob_decision_function_, 'tolist') else attr_ExtraTreesClassifier_oob_decision_function_`;
    })();
  }
};

// src/generated/ensemble/ExtraTreesRegressor.ts
import crypto54 from "node:crypto";
var ExtraTreesRegressor = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `ExtraTreesRegressor${crypto54.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "ExtraTreesRegressor.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import ExtraTreesRegressor
try: bridgeExtraTreesRegressor
except NameError: bridgeExtraTreesRegressor = {}
`;
    await this._py.ex`ctor_ExtraTreesRegressor = {'n_estimators': ${this.opts["n_estimators"] ?? void 0}, 'criterion': ${this.opts["criterion"] ?? void 0}, 'max_depth': ${this.opts["max_depth"] ?? void 0}, 'min_samples_split': ${this.opts["min_samples_split"] ?? void 0}, 'min_samples_leaf': ${this.opts["min_samples_leaf"] ?? void 0}, 'min_weight_fraction_leaf': ${this.opts["min_weight_fraction_leaf"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'max_leaf_nodes': ${this.opts["max_leaf_nodes"] ?? void 0}, 'min_impurity_decrease': ${this.opts["min_impurity_decrease"] ?? void 0}, 'bootstrap': ${this.opts["bootstrap"] ?? void 0}, 'oob_score': ${this.opts["oob_score"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'ccp_alpha': ${this.opts["ccp_alpha"] ?? void 0}, 'max_samples': ${this.opts["max_samples"] ?? void 0}, 'monotonic_cst': np.array(${this.opts["monotonic_cst"] ?? void 0}) if ${this.opts["monotonic_cst"] !== void 0} else None}

ctor_ExtraTreesRegressor = {k: v for k, v in ctor_ExtraTreesRegressor.items() if v is not None}`;
    await this._py.ex`bridgeExtraTreesRegressor[${this.id}] = ExtraTreesRegressor(**ctor_ExtraTreesRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeExtraTreesRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Apply trees in the forest to X, return leaf indices.
   */
  async apply(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ExtraTreesRegressor must call init() before apply()");
    }
    await this._py.ex`pms_ExtraTreesRegressor_apply = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ExtraTreesRegressor_apply = {k: v for k, v in pms_ExtraTreesRegressor_apply.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesRegressor_apply = bridgeExtraTreesRegressor[${this.id}].apply(**pms_ExtraTreesRegressor_apply)`;
    return this._py`res_ExtraTreesRegressor_apply.tolist() if hasattr(res_ExtraTreesRegressor_apply, 'tolist') else res_ExtraTreesRegressor_apply`;
  }
  /**
    Return the decision path in the forest.
   */
  async decision_path(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesRegressor must call init() before decision_path()"
      );
    }
    await this._py.ex`pms_ExtraTreesRegressor_decision_path = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ExtraTreesRegressor_decision_path = {k: v for k, v in pms_ExtraTreesRegressor_decision_path.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesRegressor_decision_path = bridgeExtraTreesRegressor[${this.id}].decision_path(**pms_ExtraTreesRegressor_decision_path)`;
    return this._py`res_ExtraTreesRegressor_decision_path.tolist() if hasattr(res_ExtraTreesRegressor_decision_path, 'tolist') else res_ExtraTreesRegressor_decision_path`;
  }
  /**
    Build a forest of trees from the training set (X, y).
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ExtraTreesRegressor must call init() before fit()");
    }
    await this._py.ex`pms_ExtraTreesRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_ExtraTreesRegressor_fit = {k: v for k, v in pms_ExtraTreesRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesRegressor_fit = bridgeExtraTreesRegressor[${this.id}].fit(**pms_ExtraTreesRegressor_fit)`;
    return this._py`res_ExtraTreesRegressor_fit.tolist() if hasattr(res_ExtraTreesRegressor_fit, 'tolist') else res_ExtraTreesRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_ExtraTreesRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_ExtraTreesRegressor_get_metadata_routing = {k: v for k, v in pms_ExtraTreesRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesRegressor_get_metadata_routing = bridgeExtraTreesRegressor[${this.id}].get_metadata_routing(**pms_ExtraTreesRegressor_get_metadata_routing)`;
    return this._py`res_ExtraTreesRegressor_get_metadata_routing.tolist() if hasattr(res_ExtraTreesRegressor_get_metadata_routing, 'tolist') else res_ExtraTreesRegressor_get_metadata_routing`;
  }
  /**
      Predict regression target for X.
  
      The predicted regression target of an input sample is computed as the mean predicted regression targets of the trees in the forest.
     */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ExtraTreesRegressor must call init() before predict()");
    }
    await this._py.ex`pms_ExtraTreesRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_ExtraTreesRegressor_predict = {k: v for k, v in pms_ExtraTreesRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesRegressor_predict = bridgeExtraTreesRegressor[${this.id}].predict(**pms_ExtraTreesRegressor_predict)`;
    return this._py`res_ExtraTreesRegressor_predict.tolist() if hasattr(res_ExtraTreesRegressor_predict, 'tolist') else res_ExtraTreesRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y_true \- y_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y_true \- y_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("ExtraTreesRegressor must call init() before score()");
    }
    await this._py.ex`pms_ExtraTreesRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_ExtraTreesRegressor_score = {k: v for k, v in pms_ExtraTreesRegressor_score.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesRegressor_score = bridgeExtraTreesRegressor[${this.id}].score(**pms_ExtraTreesRegressor_score)`;
    return this._py`res_ExtraTreesRegressor_score.tolist() if hasattr(res_ExtraTreesRegressor_score, 'tolist') else res_ExtraTreesRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_ExtraTreesRegressor_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_ExtraTreesRegressor_set_fit_request = {k: v for k, v in pms_ExtraTreesRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesRegressor_set_fit_request = bridgeExtraTreesRegressor[${this.id}].set_fit_request(**pms_ExtraTreesRegressor_set_fit_request)`;
    return this._py`res_ExtraTreesRegressor_set_fit_request.tolist() if hasattr(res_ExtraTreesRegressor_set_fit_request, 'tolist') else res_ExtraTreesRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_ExtraTreesRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_ExtraTreesRegressor_set_score_request = {k: v for k, v in pms_ExtraTreesRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_ExtraTreesRegressor_set_score_request = bridgeExtraTreesRegressor[${this.id}].set_score_request(**pms_ExtraTreesRegressor_set_score_request)`;
    return this._py`res_ExtraTreesRegressor_set_score_request.tolist() if hasattr(res_ExtraTreesRegressor_set_score_request, 'tolist') else res_ExtraTreesRegressor_set_score_request`;
  }
  /**
    The child estimator template used to create the collection of fitted sub-estimators.
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesRegressor must call init() before accessing estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesRegressor_estimator_ = bridgeExtraTreesRegressor[${this.id}].estimator_`;
      return this._py`attr_ExtraTreesRegressor_estimator_.tolist() if hasattr(attr_ExtraTreesRegressor_estimator_, 'tolist') else attr_ExtraTreesRegressor_estimator_`;
    })();
  }
  /**
    The collection of fitted sub-estimators.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesRegressor must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesRegressor_estimators_ = bridgeExtraTreesRegressor[${this.id}].estimators_`;
      return this._py`attr_ExtraTreesRegressor_estimators_.tolist() if hasattr(attr_ExtraTreesRegressor_estimators_, 'tolist') else attr_ExtraTreesRegressor_estimators_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesRegressor_n_features_in_ = bridgeExtraTreesRegressor[${this.id}].n_features_in_`;
      return this._py`attr_ExtraTreesRegressor_n_features_in_.tolist() if hasattr(attr_ExtraTreesRegressor_n_features_in_, 'tolist') else attr_ExtraTreesRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesRegressor_feature_names_in_ = bridgeExtraTreesRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_ExtraTreesRegressor_feature_names_in_.tolist() if hasattr(attr_ExtraTreesRegressor_feature_names_in_, 'tolist') else attr_ExtraTreesRegressor_feature_names_in_`;
    })();
  }
  /**
    The number of outputs.
   */
  get n_outputs_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesRegressor must call init() before accessing n_outputs_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesRegressor_n_outputs_ = bridgeExtraTreesRegressor[${this.id}].n_outputs_`;
      return this._py`attr_ExtraTreesRegressor_n_outputs_.tolist() if hasattr(attr_ExtraTreesRegressor_n_outputs_, 'tolist') else attr_ExtraTreesRegressor_n_outputs_`;
    })();
  }
  /**
    Score of the training dataset obtained using an out-of-bag estimate. This attribute exists only when `oob_score` is `true`.
   */
  get oob_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesRegressor must call init() before accessing oob_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesRegressor_oob_score_ = bridgeExtraTreesRegressor[${this.id}].oob_score_`;
      return this._py`attr_ExtraTreesRegressor_oob_score_.tolist() if hasattr(attr_ExtraTreesRegressor_oob_score_, 'tolist') else attr_ExtraTreesRegressor_oob_score_`;
    })();
  }
  /**
    Prediction computed with out-of-bag estimate on the training set. This attribute exists only when `oob_score` is `true`.
   */
  get oob_prediction_() {
    if (this._isDisposed) {
      throw new Error(
        "This ExtraTreesRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "ExtraTreesRegressor must call init() before accessing oob_prediction_"
      );
    }
    return (async () => {
      await this._py.ex`attr_ExtraTreesRegressor_oob_prediction_ = bridgeExtraTreesRegressor[${this.id}].oob_prediction_`;
      return this._py`attr_ExtraTreesRegressor_oob_prediction_.tolist() if hasattr(attr_ExtraTreesRegressor_oob_prediction_, 'tolist') else attr_ExtraTreesRegressor_oob_prediction_`;
    })();
  }
};

// src/generated/ensemble/GradientBoostingClassifier.ts
import crypto55 from "node:crypto";
var GradientBoostingClassifier = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `GradientBoostingClassifier${crypto55.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "GradientBoostingClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import GradientBoostingClassifier
try: bridgeGradientBoostingClassifier
except NameError: bridgeGradientBoostingClassifier = {}
`;
    await this._py.ex`ctor_GradientBoostingClassifier = {'loss': ${this.opts["loss"] ?? void 0}, 'learning_rate': ${this.opts["learning_rate"] ?? void 0}, 'n_estimators': ${this.opts["n_estimators"] ?? void 0}, 'subsample': ${this.opts["subsample"] ?? void 0}, 'criterion': ${this.opts["criterion"] ?? void 0}, 'min_samples_split': ${this.opts["min_samples_split"] ?? void 0}, 'min_samples_leaf': ${this.opts["min_samples_leaf"] ?? void 0}, 'min_weight_fraction_leaf': ${this.opts["min_weight_fraction_leaf"] ?? void 0}, 'max_depth': ${this.opts["max_depth"] ?? void 0}, 'min_impurity_decrease': ${this.opts["min_impurity_decrease"] ?? void 0}, 'init': ${this.opts["init"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'max_leaf_nodes': ${this.opts["max_leaf_nodes"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'validation_fraction': ${this.opts["validation_fraction"] ?? void 0}, 'n_iter_no_change': ${this.opts["n_iter_no_change"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'ccp_alpha': ${this.opts["ccp_alpha"] ?? void 0}}

ctor_GradientBoostingClassifier = {k: v for k, v in ctor_GradientBoostingClassifier.items() if v is not None}`;
    await this._py.ex`bridgeGradientBoostingClassifier[${this.id}] = GradientBoostingClassifier(**ctor_GradientBoostingClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeGradientBoostingClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Apply trees in the ensemble to X, return leaf indices.
   */
  async apply(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before apply()"
      );
    }
    await this._py.ex`pms_GradientBoostingClassifier_apply = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GradientBoostingClassifier_apply = {k: v for k, v in pms_GradientBoostingClassifier_apply.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingClassifier_apply = bridgeGradientBoostingClassifier[${this.id}].apply(**pms_GradientBoostingClassifier_apply)`;
    return this._py`res_GradientBoostingClassifier_apply.tolist() if hasattr(res_GradientBoostingClassifier_apply, 'tolist') else res_GradientBoostingClassifier_apply`;
  }
  /**
    Compute the decision function of `X`.
   */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_GradientBoostingClassifier_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GradientBoostingClassifier_decision_function = {k: v for k, v in pms_GradientBoostingClassifier_decision_function.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingClassifier_decision_function = bridgeGradientBoostingClassifier[${this.id}].decision_function(**pms_GradientBoostingClassifier_decision_function)`;
    return this._py`res_GradientBoostingClassifier_decision_function.tolist() if hasattr(res_GradientBoostingClassifier_decision_function, 'tolist') else res_GradientBoostingClassifier_decision_function`;
  }
  /**
    Fit the gradient boosting model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before fit()"
      );
    }
    await this._py.ex`pms_GradientBoostingClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'monitor': ${opts["monitor"] ?? void 0}}

pms_GradientBoostingClassifier_fit = {k: v for k, v in pms_GradientBoostingClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingClassifier_fit = bridgeGradientBoostingClassifier[${this.id}].fit(**pms_GradientBoostingClassifier_fit)`;
    return this._py`res_GradientBoostingClassifier_fit.tolist() if hasattr(res_GradientBoostingClassifier_fit, 'tolist') else res_GradientBoostingClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_GradientBoostingClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_GradientBoostingClassifier_get_metadata_routing = {k: v for k, v in pms_GradientBoostingClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingClassifier_get_metadata_routing = bridgeGradientBoostingClassifier[${this.id}].get_metadata_routing(**pms_GradientBoostingClassifier_get_metadata_routing)`;
    return this._py`res_GradientBoostingClassifier_get_metadata_routing.tolist() if hasattr(res_GradientBoostingClassifier_get_metadata_routing, 'tolist') else res_GradientBoostingClassifier_get_metadata_routing`;
  }
  /**
    Predict class for X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before predict()"
      );
    }
    await this._py.ex`pms_GradientBoostingClassifier_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GradientBoostingClassifier_predict = {k: v for k, v in pms_GradientBoostingClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingClassifier_predict = bridgeGradientBoostingClassifier[${this.id}].predict(**pms_GradientBoostingClassifier_predict)`;
    return this._py`res_GradientBoostingClassifier_predict.tolist() if hasattr(res_GradientBoostingClassifier_predict, 'tolist') else res_GradientBoostingClassifier_predict`;
  }
  /**
    Predict class log-probabilities for X.
   */
  async predict_log_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before predict_log_proba()"
      );
    }
    await this._py.ex`pms_GradientBoostingClassifier_predict_log_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GradientBoostingClassifier_predict_log_proba = {k: v for k, v in pms_GradientBoostingClassifier_predict_log_proba.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingClassifier_predict_log_proba = bridgeGradientBoostingClassifier[${this.id}].predict_log_proba(**pms_GradientBoostingClassifier_predict_log_proba)`;
    return this._py`res_GradientBoostingClassifier_predict_log_proba.tolist() if hasattr(res_GradientBoostingClassifier_predict_log_proba, 'tolist') else res_GradientBoostingClassifier_predict_log_proba`;
  }
  /**
    Predict class probabilities for X.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_GradientBoostingClassifier_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GradientBoostingClassifier_predict_proba = {k: v for k, v in pms_GradientBoostingClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingClassifier_predict_proba = bridgeGradientBoostingClassifier[${this.id}].predict_proba(**pms_GradientBoostingClassifier_predict_proba)`;
    return this._py`res_GradientBoostingClassifier_predict_proba.tolist() if hasattr(res_GradientBoostingClassifier_predict_proba, 'tolist') else res_GradientBoostingClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before score()"
      );
    }
    await this._py.ex`pms_GradientBoostingClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_GradientBoostingClassifier_score = {k: v for k, v in pms_GradientBoostingClassifier_score.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingClassifier_score = bridgeGradientBoostingClassifier[${this.id}].score(**pms_GradientBoostingClassifier_score)`;
    return this._py`res_GradientBoostingClassifier_score.tolist() if hasattr(res_GradientBoostingClassifier_score, 'tolist') else res_GradientBoostingClassifier_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_GradientBoostingClassifier_set_fit_request = {'monitor': ${opts["monitor"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_GradientBoostingClassifier_set_fit_request = {k: v for k, v in pms_GradientBoostingClassifier_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingClassifier_set_fit_request = bridgeGradientBoostingClassifier[${this.id}].set_fit_request(**pms_GradientBoostingClassifier_set_fit_request)`;
    return this._py`res_GradientBoostingClassifier_set_fit_request.tolist() if hasattr(res_GradientBoostingClassifier_set_fit_request, 'tolist') else res_GradientBoostingClassifier_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_GradientBoostingClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_GradientBoostingClassifier_set_score_request = {k: v for k, v in pms_GradientBoostingClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingClassifier_set_score_request = bridgeGradientBoostingClassifier[${this.id}].set_score_request(**pms_GradientBoostingClassifier_set_score_request)`;
    return this._py`res_GradientBoostingClassifier_set_score_request.tolist() if hasattr(res_GradientBoostingClassifier_set_score_request, 'tolist') else res_GradientBoostingClassifier_set_score_request`;
  }
  /**
      Compute decision function of `X` for each iteration.
  
      This method allows monitoring (i.e. determine error on testing set) after each stage.
     */
  async staged_decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before staged_decision_function()"
      );
    }
    await this._py.ex`pms_GradientBoostingClassifier_staged_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GradientBoostingClassifier_staged_decision_function = {k: v for k, v in pms_GradientBoostingClassifier_staged_decision_function.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingClassifier_staged_decision_function = bridgeGradientBoostingClassifier[${this.id}].staged_decision_function(**pms_GradientBoostingClassifier_staged_decision_function)`;
    return this._py`res_GradientBoostingClassifier_staged_decision_function.tolist() if hasattr(res_GradientBoostingClassifier_staged_decision_function, 'tolist') else res_GradientBoostingClassifier_staged_decision_function`;
  }
  /**
      Predict class at each stage for X.
  
      This method allows monitoring (i.e. determine error on testing set) after each stage.
     */
  async staged_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before staged_predict()"
      );
    }
    await this._py.ex`pms_GradientBoostingClassifier_staged_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GradientBoostingClassifier_staged_predict = {k: v for k, v in pms_GradientBoostingClassifier_staged_predict.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingClassifier_staged_predict = bridgeGradientBoostingClassifier[${this.id}].staged_predict(**pms_GradientBoostingClassifier_staged_predict)`;
    return this._py`res_GradientBoostingClassifier_staged_predict.tolist() if hasattr(res_GradientBoostingClassifier_staged_predict, 'tolist') else res_GradientBoostingClassifier_staged_predict`;
  }
  /**
      Predict class probabilities at each stage for X.
  
      This method allows monitoring (i.e. determine error on testing set) after each stage.
     */
  async staged_predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before staged_predict_proba()"
      );
    }
    await this._py.ex`pms_GradientBoostingClassifier_staged_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GradientBoostingClassifier_staged_predict_proba = {k: v for k, v in pms_GradientBoostingClassifier_staged_predict_proba.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingClassifier_staged_predict_proba = bridgeGradientBoostingClassifier[${this.id}].staged_predict_proba(**pms_GradientBoostingClassifier_staged_predict_proba)`;
    return this._py`res_GradientBoostingClassifier_staged_predict_proba.tolist() if hasattr(res_GradientBoostingClassifier_staged_predict_proba, 'tolist') else res_GradientBoostingClassifier_staged_predict_proba`;
  }
  /**
    The number of estimators as selected by early stopping (if `n_iter_no_change` is specified). Otherwise it is set to `n_estimators`.
   */
  get n_estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before accessing n_estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingClassifier_n_estimators_ = bridgeGradientBoostingClassifier[${this.id}].n_estimators_`;
      return this._py`attr_GradientBoostingClassifier_n_estimators_.tolist() if hasattr(attr_GradientBoostingClassifier_n_estimators_, 'tolist') else attr_GradientBoostingClassifier_n_estimators_`;
    })();
  }
  /**
    The number of trees that are built at each iteration. For binary classifiers, this is always 1.
   */
  get n_trees_per_iteration_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before accessing n_trees_per_iteration_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingClassifier_n_trees_per_iteration_ = bridgeGradientBoostingClassifier[${this.id}].n_trees_per_iteration_`;
      return this._py`attr_GradientBoostingClassifier_n_trees_per_iteration_.tolist() if hasattr(attr_GradientBoostingClassifier_n_trees_per_iteration_, 'tolist') else attr_GradientBoostingClassifier_n_trees_per_iteration_`;
    })();
  }
  /**
    The improvement in loss on the out-of-bag samples relative to the previous iteration. `oob_improvement_\[0\]` is the improvement in loss of the first stage over the `init` estimator. Only available if `subsample < 1.0`.
   */
  get oob_improvement_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before accessing oob_improvement_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingClassifier_oob_improvement_ = bridgeGradientBoostingClassifier[${this.id}].oob_improvement_`;
      return this._py`attr_GradientBoostingClassifier_oob_improvement_.tolist() if hasattr(attr_GradientBoostingClassifier_oob_improvement_, 'tolist') else attr_GradientBoostingClassifier_oob_improvement_`;
    })();
  }
  /**
    The full history of the loss values on the out-of-bag samples. Only available if `subsample < 1.0`.
   */
  get oob_scores_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before accessing oob_scores_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingClassifier_oob_scores_ = bridgeGradientBoostingClassifier[${this.id}].oob_scores_`;
      return this._py`attr_GradientBoostingClassifier_oob_scores_.tolist() if hasattr(attr_GradientBoostingClassifier_oob_scores_, 'tolist') else attr_GradientBoostingClassifier_oob_scores_`;
    })();
  }
  /**
    The last value of the loss on the out-of-bag samples. It is the same as `oob_scores_\[-1\]`. Only available if `subsample < 1.0`.
   */
  get oob_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before accessing oob_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingClassifier_oob_score_ = bridgeGradientBoostingClassifier[${this.id}].oob_score_`;
      return this._py`attr_GradientBoostingClassifier_oob_score_.tolist() if hasattr(attr_GradientBoostingClassifier_oob_score_, 'tolist') else attr_GradientBoostingClassifier_oob_score_`;
    })();
  }
  /**
    The i-th score `train_score_\[i\]` is the loss of the model at iteration `i` on the in-bag sample. If `subsample \== 1` this is the loss on the training data.
   */
  get train_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before accessing train_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingClassifier_train_score_ = bridgeGradientBoostingClassifier[${this.id}].train_score_`;
      return this._py`attr_GradientBoostingClassifier_train_score_.tolist() if hasattr(attr_GradientBoostingClassifier_train_score_, 'tolist') else attr_GradientBoostingClassifier_train_score_`;
    })();
  }
  /**
    The estimator that provides the initial predictions. Set via the `init` argument.
   */
  get init_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before accessing init_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingClassifier_init_ = bridgeGradientBoostingClassifier[${this.id}].init_`;
      return this._py`attr_GradientBoostingClassifier_init_.tolist() if hasattr(attr_GradientBoostingClassifier_init_, 'tolist') else attr_GradientBoostingClassifier_init_`;
    })();
  }
  /**
    The collection of fitted sub-estimators. `n_trees_per_iteration_` is 1 for binary classification, otherwise `n_classes`.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingClassifier_estimators_ = bridgeGradientBoostingClassifier[${this.id}].estimators_`;
      return this._py`attr_GradientBoostingClassifier_estimators_.tolist() if hasattr(attr_GradientBoostingClassifier_estimators_, 'tolist') else attr_GradientBoostingClassifier_estimators_`;
    })();
  }
  /**
    The classes labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingClassifier_classes_ = bridgeGradientBoostingClassifier[${this.id}].classes_`;
      return this._py`attr_GradientBoostingClassifier_classes_.tolist() if hasattr(attr_GradientBoostingClassifier_classes_, 'tolist') else attr_GradientBoostingClassifier_classes_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingClassifier_n_features_in_ = bridgeGradientBoostingClassifier[${this.id}].n_features_in_`;
      return this._py`attr_GradientBoostingClassifier_n_features_in_.tolist() if hasattr(attr_GradientBoostingClassifier_n_features_in_, 'tolist') else attr_GradientBoostingClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingClassifier_feature_names_in_ = bridgeGradientBoostingClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_GradientBoostingClassifier_feature_names_in_.tolist() if hasattr(attr_GradientBoostingClassifier_feature_names_in_, 'tolist') else attr_GradientBoostingClassifier_feature_names_in_`;
    })();
  }
  /**
    The number of classes.
   */
  get n_classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before accessing n_classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingClassifier_n_classes_ = bridgeGradientBoostingClassifier[${this.id}].n_classes_`;
      return this._py`attr_GradientBoostingClassifier_n_classes_.tolist() if hasattr(attr_GradientBoostingClassifier_n_classes_, 'tolist') else attr_GradientBoostingClassifier_n_classes_`;
    })();
  }
  /**
    The inferred value of max_features.
   */
  get max_features_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingClassifier must call init() before accessing max_features_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingClassifier_max_features_ = bridgeGradientBoostingClassifier[${this.id}].max_features_`;
      return this._py`attr_GradientBoostingClassifier_max_features_.tolist() if hasattr(attr_GradientBoostingClassifier_max_features_, 'tolist') else attr_GradientBoostingClassifier_max_features_`;
    })();
  }
};

// src/generated/ensemble/GradientBoostingRegressor.ts
import crypto56 from "node:crypto";
var GradientBoostingRegressor = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `GradientBoostingRegressor${crypto56.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "GradientBoostingRegressor.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import GradientBoostingRegressor
try: bridgeGradientBoostingRegressor
except NameError: bridgeGradientBoostingRegressor = {}
`;
    await this._py.ex`ctor_GradientBoostingRegressor = {'loss': ${this.opts["loss"] ?? void 0}, 'learning_rate': ${this.opts["learning_rate"] ?? void 0}, 'n_estimators': ${this.opts["n_estimators"] ?? void 0}, 'subsample': ${this.opts["subsample"] ?? void 0}, 'criterion': ${this.opts["criterion"] ?? void 0}, 'min_samples_split': ${this.opts["min_samples_split"] ?? void 0}, 'min_samples_leaf': ${this.opts["min_samples_leaf"] ?? void 0}, 'min_weight_fraction_leaf': ${this.opts["min_weight_fraction_leaf"] ?? void 0}, 'max_depth': ${this.opts["max_depth"] ?? void 0}, 'min_impurity_decrease': ${this.opts["min_impurity_decrease"] ?? void 0}, 'init': ${this.opts["init"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'max_leaf_nodes': ${this.opts["max_leaf_nodes"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'validation_fraction': ${this.opts["validation_fraction"] ?? void 0}, 'n_iter_no_change': ${this.opts["n_iter_no_change"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'ccp_alpha': ${this.opts["ccp_alpha"] ?? void 0}}

ctor_GradientBoostingRegressor = {k: v for k, v in ctor_GradientBoostingRegressor.items() if v is not None}`;
    await this._py.ex`bridgeGradientBoostingRegressor[${this.id}] = GradientBoostingRegressor(**ctor_GradientBoostingRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeGradientBoostingRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Apply trees in the ensemble to X, return leaf indices.
   */
  async apply(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before apply()"
      );
    }
    await this._py.ex`pms_GradientBoostingRegressor_apply = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GradientBoostingRegressor_apply = {k: v for k, v in pms_GradientBoostingRegressor_apply.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingRegressor_apply = bridgeGradientBoostingRegressor[${this.id}].apply(**pms_GradientBoostingRegressor_apply)`;
    return this._py`res_GradientBoostingRegressor_apply.tolist() if hasattr(res_GradientBoostingRegressor_apply, 'tolist') else res_GradientBoostingRegressor_apply`;
  }
  /**
    Fit the gradient boosting model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error("GradientBoostingRegressor must call init() before fit()");
    }
    await this._py.ex`pms_GradientBoostingRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None, 'monitor': ${opts["monitor"] ?? void 0}}

pms_GradientBoostingRegressor_fit = {k: v for k, v in pms_GradientBoostingRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingRegressor_fit = bridgeGradientBoostingRegressor[${this.id}].fit(**pms_GradientBoostingRegressor_fit)`;
    return this._py`res_GradientBoostingRegressor_fit.tolist() if hasattr(res_GradientBoostingRegressor_fit, 'tolist') else res_GradientBoostingRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_GradientBoostingRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_GradientBoostingRegressor_get_metadata_routing = {k: v for k, v in pms_GradientBoostingRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingRegressor_get_metadata_routing = bridgeGradientBoostingRegressor[${this.id}].get_metadata_routing(**pms_GradientBoostingRegressor_get_metadata_routing)`;
    return this._py`res_GradientBoostingRegressor_get_metadata_routing.tolist() if hasattr(res_GradientBoostingRegressor_get_metadata_routing, 'tolist') else res_GradientBoostingRegressor_get_metadata_routing`;
  }
  /**
    Predict regression target for X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before predict()"
      );
    }
    await this._py.ex`pms_GradientBoostingRegressor_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GradientBoostingRegressor_predict = {k: v for k, v in pms_GradientBoostingRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingRegressor_predict = bridgeGradientBoostingRegressor[${this.id}].predict(**pms_GradientBoostingRegressor_predict)`;
    return this._py`res_GradientBoostingRegressor_predict.tolist() if hasattr(res_GradientBoostingRegressor_predict, 'tolist') else res_GradientBoostingRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y_true \- y_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y_true \- y_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before score()"
      );
    }
    await this._py.ex`pms_GradientBoostingRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_GradientBoostingRegressor_score = {k: v for k, v in pms_GradientBoostingRegressor_score.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingRegressor_score = bridgeGradientBoostingRegressor[${this.id}].score(**pms_GradientBoostingRegressor_score)`;
    return this._py`res_GradientBoostingRegressor_score.tolist() if hasattr(res_GradientBoostingRegressor_score, 'tolist') else res_GradientBoostingRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_GradientBoostingRegressor_set_fit_request = {'monitor': ${opts["monitor"] ?? void 0}, 'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_GradientBoostingRegressor_set_fit_request = {k: v for k, v in pms_GradientBoostingRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingRegressor_set_fit_request = bridgeGradientBoostingRegressor[${this.id}].set_fit_request(**pms_GradientBoostingRegressor_set_fit_request)`;
    return this._py`res_GradientBoostingRegressor_set_fit_request.tolist() if hasattr(res_GradientBoostingRegressor_set_fit_request, 'tolist') else res_GradientBoostingRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_GradientBoostingRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_GradientBoostingRegressor_set_score_request = {k: v for k, v in pms_GradientBoostingRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingRegressor_set_score_request = bridgeGradientBoostingRegressor[${this.id}].set_score_request(**pms_GradientBoostingRegressor_set_score_request)`;
    return this._py`res_GradientBoostingRegressor_set_score_request.tolist() if hasattr(res_GradientBoostingRegressor_set_score_request, 'tolist') else res_GradientBoostingRegressor_set_score_request`;
  }
  /**
      Predict regression target at each stage for X.
  
      This method allows monitoring (i.e. determine error on testing set) after each stage.
     */
  async staged_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before staged_predict()"
      );
    }
    await this._py.ex`pms_GradientBoostingRegressor_staged_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_GradientBoostingRegressor_staged_predict = {k: v for k, v in pms_GradientBoostingRegressor_staged_predict.items() if v is not None}`;
    await this._py.ex`res_GradientBoostingRegressor_staged_predict = bridgeGradientBoostingRegressor[${this.id}].staged_predict(**pms_GradientBoostingRegressor_staged_predict)`;
    return this._py`res_GradientBoostingRegressor_staged_predict.tolist() if hasattr(res_GradientBoostingRegressor_staged_predict, 'tolist') else res_GradientBoostingRegressor_staged_predict`;
  }
  /**
    The number of estimators as selected by early stopping (if `n_iter_no_change` is specified). Otherwise it is set to `n_estimators`.
   */
  get n_estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before accessing n_estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingRegressor_n_estimators_ = bridgeGradientBoostingRegressor[${this.id}].n_estimators_`;
      return this._py`attr_GradientBoostingRegressor_n_estimators_.tolist() if hasattr(attr_GradientBoostingRegressor_n_estimators_, 'tolist') else attr_GradientBoostingRegressor_n_estimators_`;
    })();
  }
  /**
    The number of trees that are built at each iteration. For regressors, this is always 1.
   */
  get n_trees_per_iteration_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before accessing n_trees_per_iteration_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingRegressor_n_trees_per_iteration_ = bridgeGradientBoostingRegressor[${this.id}].n_trees_per_iteration_`;
      return this._py`attr_GradientBoostingRegressor_n_trees_per_iteration_.tolist() if hasattr(attr_GradientBoostingRegressor_n_trees_per_iteration_, 'tolist') else attr_GradientBoostingRegressor_n_trees_per_iteration_`;
    })();
  }
  /**
    The improvement in loss on the out-of-bag samples relative to the previous iteration. `oob_improvement_\[0\]` is the improvement in loss of the first stage over the `init` estimator. Only available if `subsample < 1.0`.
   */
  get oob_improvement_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before accessing oob_improvement_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingRegressor_oob_improvement_ = bridgeGradientBoostingRegressor[${this.id}].oob_improvement_`;
      return this._py`attr_GradientBoostingRegressor_oob_improvement_.tolist() if hasattr(attr_GradientBoostingRegressor_oob_improvement_, 'tolist') else attr_GradientBoostingRegressor_oob_improvement_`;
    })();
  }
  /**
    The full history of the loss values on the out-of-bag samples. Only available if `subsample < 1.0`.
   */
  get oob_scores_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before accessing oob_scores_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingRegressor_oob_scores_ = bridgeGradientBoostingRegressor[${this.id}].oob_scores_`;
      return this._py`attr_GradientBoostingRegressor_oob_scores_.tolist() if hasattr(attr_GradientBoostingRegressor_oob_scores_, 'tolist') else attr_GradientBoostingRegressor_oob_scores_`;
    })();
  }
  /**
    The last value of the loss on the out-of-bag samples. It is the same as `oob_scores_\[-1\]`. Only available if `subsample < 1.0`.
   */
  get oob_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before accessing oob_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingRegressor_oob_score_ = bridgeGradientBoostingRegressor[${this.id}].oob_score_`;
      return this._py`attr_GradientBoostingRegressor_oob_score_.tolist() if hasattr(attr_GradientBoostingRegressor_oob_score_, 'tolist') else attr_GradientBoostingRegressor_oob_score_`;
    })();
  }
  /**
    The i-th score `train_score_\[i\]` is the loss of the model at iteration `i` on the in-bag sample. If `subsample \== 1` this is the loss on the training data.
   */
  get train_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before accessing train_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingRegressor_train_score_ = bridgeGradientBoostingRegressor[${this.id}].train_score_`;
      return this._py`attr_GradientBoostingRegressor_train_score_.tolist() if hasattr(attr_GradientBoostingRegressor_train_score_, 'tolist') else attr_GradientBoostingRegressor_train_score_`;
    })();
  }
  /**
    The estimator that provides the initial predictions. Set via the `init` argument.
   */
  get init_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before accessing init_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingRegressor_init_ = bridgeGradientBoostingRegressor[${this.id}].init_`;
      return this._py`attr_GradientBoostingRegressor_init_.tolist() if hasattr(attr_GradientBoostingRegressor_init_, 'tolist') else attr_GradientBoostingRegressor_init_`;
    })();
  }
  /**
    The collection of fitted sub-estimators.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingRegressor_estimators_ = bridgeGradientBoostingRegressor[${this.id}].estimators_`;
      return this._py`attr_GradientBoostingRegressor_estimators_.tolist() if hasattr(attr_GradientBoostingRegressor_estimators_, 'tolist') else attr_GradientBoostingRegressor_estimators_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingRegressor_n_features_in_ = bridgeGradientBoostingRegressor[${this.id}].n_features_in_`;
      return this._py`attr_GradientBoostingRegressor_n_features_in_.tolist() if hasattr(attr_GradientBoostingRegressor_n_features_in_, 'tolist') else attr_GradientBoostingRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingRegressor_feature_names_in_ = bridgeGradientBoostingRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_GradientBoostingRegressor_feature_names_in_.tolist() if hasattr(attr_GradientBoostingRegressor_feature_names_in_, 'tolist') else attr_GradientBoostingRegressor_feature_names_in_`;
    })();
  }
  /**
    The inferred value of max_features.
   */
  get max_features_() {
    if (this._isDisposed) {
      throw new Error(
        "This GradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "GradientBoostingRegressor must call init() before accessing max_features_"
      );
    }
    return (async () => {
      await this._py.ex`attr_GradientBoostingRegressor_max_features_ = bridgeGradientBoostingRegressor[${this.id}].max_features_`;
      return this._py`attr_GradientBoostingRegressor_max_features_.tolist() if hasattr(attr_GradientBoostingRegressor_max_features_, 'tolist') else attr_GradientBoostingRegressor_max_features_`;
    })();
  }
};

// src/generated/ensemble/HistGradientBoostingClassifier.ts
import crypto57 from "node:crypto";
var HistGradientBoostingClassifier = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `HistGradientBoostingClassifier${crypto57.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "HistGradientBoostingClassifier.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import HistGradientBoostingClassifier
try: bridgeHistGradientBoostingClassifier
except NameError: bridgeHistGradientBoostingClassifier = {}
`;
    await this._py.ex`ctor_HistGradientBoostingClassifier = {'loss': ${this.opts["loss"] ?? void 0}, 'learning_rate': ${this.opts["learning_rate"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'max_leaf_nodes': ${this.opts["max_leaf_nodes"] ?? void 0}, 'max_depth': ${this.opts["max_depth"] ?? void 0}, 'min_samples_leaf': ${this.opts["min_samples_leaf"] ?? void 0}, 'l2_regularization': ${this.opts["l2_regularization"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'max_bins': ${this.opts["max_bins"] ?? void 0}, 'categorical_features': np.array(${this.opts["categorical_features"] ?? void 0}) if ${this.opts["categorical_features"] !== void 0} else None, 'monotonic_cst': np.array(${this.opts["monotonic_cst"] ?? void 0}) if ${this.opts["monotonic_cst"] !== void 0} else None, 'interaction_cst': ${this.opts["interaction_cst"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'early_stopping': ${this.opts["early_stopping"] ?? void 0}, 'scoring': ${this.opts["scoring"] ?? void 0}, 'validation_fraction': ${this.opts["validation_fraction"] ?? void 0}, 'n_iter_no_change': ${this.opts["n_iter_no_change"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'class_weight': ${this.opts["class_weight"] ?? void 0}}

ctor_HistGradientBoostingClassifier = {k: v for k, v in ctor_HistGradientBoostingClassifier.items() if v is not None}`;
    await this._py.ex`bridgeHistGradientBoostingClassifier[${this.id}] = HistGradientBoostingClassifier(**ctor_HistGradientBoostingClassifier)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeHistGradientBoostingClassifier[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Compute the decision function of `X`.
   */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingClassifier_decision_function = {'X': ${opts["X"] ?? void 0}}

pms_HistGradientBoostingClassifier_decision_function = {k: v for k, v in pms_HistGradientBoostingClassifier_decision_function.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingClassifier_decision_function = bridgeHistGradientBoostingClassifier[${this.id}].decision_function(**pms_HistGradientBoostingClassifier_decision_function)`;
    return this._py`res_HistGradientBoostingClassifier_decision_function.tolist() if hasattr(res_HistGradientBoostingClassifier_decision_function, 'tolist') else res_HistGradientBoostingClassifier_decision_function`;
  }
  /**
    Fit the gradient boosting model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before fit()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingClassifier_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_HistGradientBoostingClassifier_fit = {k: v for k, v in pms_HistGradientBoostingClassifier_fit.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingClassifier_fit = bridgeHistGradientBoostingClassifier[${this.id}].fit(**pms_HistGradientBoostingClassifier_fit)`;
    return this._py`res_HistGradientBoostingClassifier_fit.tolist() if hasattr(res_HistGradientBoostingClassifier_fit, 'tolist') else res_HistGradientBoostingClassifier_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingClassifier_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_HistGradientBoostingClassifier_get_metadata_routing = {k: v for k, v in pms_HistGradientBoostingClassifier_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingClassifier_get_metadata_routing = bridgeHistGradientBoostingClassifier[${this.id}].get_metadata_routing(**pms_HistGradientBoostingClassifier_get_metadata_routing)`;
    return this._py`res_HistGradientBoostingClassifier_get_metadata_routing.tolist() if hasattr(res_HistGradientBoostingClassifier_get_metadata_routing, 'tolist') else res_HistGradientBoostingClassifier_get_metadata_routing`;
  }
  /**
    Predict classes for X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before predict()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingClassifier_predict = {'X': ${opts["X"] ?? void 0}}

pms_HistGradientBoostingClassifier_predict = {k: v for k, v in pms_HistGradientBoostingClassifier_predict.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingClassifier_predict = bridgeHistGradientBoostingClassifier[${this.id}].predict(**pms_HistGradientBoostingClassifier_predict)`;
    return this._py`res_HistGradientBoostingClassifier_predict.tolist() if hasattr(res_HistGradientBoostingClassifier_predict, 'tolist') else res_HistGradientBoostingClassifier_predict`;
  }
  /**
    Predict class probabilities for X.
   */
  async predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before predict_proba()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingClassifier_predict_proba = {'X': ${opts["X"] ?? void 0}}

pms_HistGradientBoostingClassifier_predict_proba = {k: v for k, v in pms_HistGradientBoostingClassifier_predict_proba.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingClassifier_predict_proba = bridgeHistGradientBoostingClassifier[${this.id}].predict_proba(**pms_HistGradientBoostingClassifier_predict_proba)`;
    return this._py`res_HistGradientBoostingClassifier_predict_proba.tolist() if hasattr(res_HistGradientBoostingClassifier_predict_proba, 'tolist') else res_HistGradientBoostingClassifier_predict_proba`;
  }
  /**
      Return the mean accuracy on the given test data and labels.
  
      In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before score()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingClassifier_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_HistGradientBoostingClassifier_score = {k: v for k, v in pms_HistGradientBoostingClassifier_score.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingClassifier_score = bridgeHistGradientBoostingClassifier[${this.id}].score(**pms_HistGradientBoostingClassifier_score)`;
    return this._py`res_HistGradientBoostingClassifier_score.tolist() if hasattr(res_HistGradientBoostingClassifier_score, 'tolist') else res_HistGradientBoostingClassifier_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingClassifier_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_HistGradientBoostingClassifier_set_fit_request = {k: v for k, v in pms_HistGradientBoostingClassifier_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingClassifier_set_fit_request = bridgeHistGradientBoostingClassifier[${this.id}].set_fit_request(**pms_HistGradientBoostingClassifier_set_fit_request)`;
    return this._py`res_HistGradientBoostingClassifier_set_fit_request.tolist() if hasattr(res_HistGradientBoostingClassifier_set_fit_request, 'tolist') else res_HistGradientBoostingClassifier_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingClassifier_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_HistGradientBoostingClassifier_set_score_request = {k: v for k, v in pms_HistGradientBoostingClassifier_set_score_request.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingClassifier_set_score_request = bridgeHistGradientBoostingClassifier[${this.id}].set_score_request(**pms_HistGradientBoostingClassifier_set_score_request)`;
    return this._py`res_HistGradientBoostingClassifier_set_score_request.tolist() if hasattr(res_HistGradientBoostingClassifier_set_score_request, 'tolist') else res_HistGradientBoostingClassifier_set_score_request`;
  }
  /**
      Compute decision function of `X` for each iteration.
  
      This method allows monitoring (i.e. determine error on testing set) after each stage.
     */
  async staged_decision_function(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before staged_decision_function()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingClassifier_staged_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_HistGradientBoostingClassifier_staged_decision_function = {k: v for k, v in pms_HistGradientBoostingClassifier_staged_decision_function.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingClassifier_staged_decision_function = bridgeHistGradientBoostingClassifier[${this.id}].staged_decision_function(**pms_HistGradientBoostingClassifier_staged_decision_function)`;
    return this._py`res_HistGradientBoostingClassifier_staged_decision_function.tolist() if hasattr(res_HistGradientBoostingClassifier_staged_decision_function, 'tolist') else res_HistGradientBoostingClassifier_staged_decision_function`;
  }
  /**
      Predict classes at each iteration.
  
      This method allows monitoring (i.e. determine error on testing set) after each stage.
     */
  async staged_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before staged_predict()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingClassifier_staged_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_HistGradientBoostingClassifier_staged_predict = {k: v for k, v in pms_HistGradientBoostingClassifier_staged_predict.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingClassifier_staged_predict = bridgeHistGradientBoostingClassifier[${this.id}].staged_predict(**pms_HistGradientBoostingClassifier_staged_predict)`;
    return this._py`res_HistGradientBoostingClassifier_staged_predict.tolist() if hasattr(res_HistGradientBoostingClassifier_staged_predict, 'tolist') else res_HistGradientBoostingClassifier_staged_predict`;
  }
  /**
      Predict class probabilities at each iteration.
  
      This method allows monitoring (i.e. determine error on testing set) after each stage.
     */
  async staged_predict_proba(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before staged_predict_proba()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingClassifier_staged_predict_proba = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_HistGradientBoostingClassifier_staged_predict_proba = {k: v for k, v in pms_HistGradientBoostingClassifier_staged_predict_proba.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingClassifier_staged_predict_proba = bridgeHistGradientBoostingClassifier[${this.id}].staged_predict_proba(**pms_HistGradientBoostingClassifier_staged_predict_proba)`;
    return this._py`res_HistGradientBoostingClassifier_staged_predict_proba.tolist() if hasattr(res_HistGradientBoostingClassifier_staged_predict_proba, 'tolist') else res_HistGradientBoostingClassifier_staged_predict_proba`;
  }
  /**
    Class labels.
   */
  get classes_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before accessing classes_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingClassifier_classes_ = bridgeHistGradientBoostingClassifier[${this.id}].classes_`;
      return this._py`attr_HistGradientBoostingClassifier_classes_.tolist() if hasattr(attr_HistGradientBoostingClassifier_classes_, 'tolist') else attr_HistGradientBoostingClassifier_classes_`;
    })();
  }
  /**
    Indicates whether early stopping is used during training.
   */
  get do_early_stopping_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before accessing do_early_stopping_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingClassifier_do_early_stopping_ = bridgeHistGradientBoostingClassifier[${this.id}].do_early_stopping_`;
      return this._py`attr_HistGradientBoostingClassifier_do_early_stopping_.tolist() if hasattr(attr_HistGradientBoostingClassifier_do_early_stopping_, 'tolist') else attr_HistGradientBoostingClassifier_do_early_stopping_`;
    })();
  }
  /**
    The number of tree that are built at each iteration. This is equal to 1 for binary classification, and to `n_classes` for multiclass classification.
   */
  get n_trees_per_iteration_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before accessing n_trees_per_iteration_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingClassifier_n_trees_per_iteration_ = bridgeHistGradientBoostingClassifier[${this.id}].n_trees_per_iteration_`;
      return this._py`attr_HistGradientBoostingClassifier_n_trees_per_iteration_.tolist() if hasattr(attr_HistGradientBoostingClassifier_n_trees_per_iteration_, 'tolist') else attr_HistGradientBoostingClassifier_n_trees_per_iteration_`;
    })();
  }
  /**
    The scores at each iteration on the training data. The first entry is the score of the ensemble before the first iteration. Scores are computed according to the `scoring` parameter. If `scoring` is not ‘loss’, scores are computed on a subset of at most 10 000 samples. Empty if no early stopping.
   */
  get train_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before accessing train_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingClassifier_train_score_ = bridgeHistGradientBoostingClassifier[${this.id}].train_score_`;
      return this._py`attr_HistGradientBoostingClassifier_train_score_.tolist() if hasattr(attr_HistGradientBoostingClassifier_train_score_, 'tolist') else attr_HistGradientBoostingClassifier_train_score_`;
    })();
  }
  /**
    The scores at each iteration on the held-out validation data. The first entry is the score of the ensemble before the first iteration. Scores are computed according to the `scoring` parameter. Empty if no early stopping or if `validation_fraction` is `undefined`.
   */
  get validation_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before accessing validation_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingClassifier_validation_score_ = bridgeHistGradientBoostingClassifier[${this.id}].validation_score_`;
      return this._py`attr_HistGradientBoostingClassifier_validation_score_.tolist() if hasattr(attr_HistGradientBoostingClassifier_validation_score_, 'tolist') else attr_HistGradientBoostingClassifier_validation_score_`;
    })();
  }
  /**
    Boolean mask for the categorical features. `undefined` if there are no categorical features.
   */
  get is_categorical_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before accessing is_categorical_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingClassifier_is_categorical_ = bridgeHistGradientBoostingClassifier[${this.id}].is_categorical_`;
      return this._py`attr_HistGradientBoostingClassifier_is_categorical_.tolist() if hasattr(attr_HistGradientBoostingClassifier_is_categorical_, 'tolist') else attr_HistGradientBoostingClassifier_is_categorical_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingClassifier_n_features_in_ = bridgeHistGradientBoostingClassifier[${this.id}].n_features_in_`;
      return this._py`attr_HistGradientBoostingClassifier_n_features_in_.tolist() if hasattr(attr_HistGradientBoostingClassifier_n_features_in_, 'tolist') else attr_HistGradientBoostingClassifier_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingClassifier instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingClassifier must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingClassifier_feature_names_in_ = bridgeHistGradientBoostingClassifier[${this.id}].feature_names_in_`;
      return this._py`attr_HistGradientBoostingClassifier_feature_names_in_.tolist() if hasattr(attr_HistGradientBoostingClassifier_feature_names_in_, 'tolist') else attr_HistGradientBoostingClassifier_feature_names_in_`;
    })();
  }
};

// src/generated/ensemble/HistGradientBoostingRegressor.ts
import crypto58 from "node:crypto";
var HistGradientBoostingRegressor = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `HistGradientBoostingRegressor${crypto58.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error(
        "HistGradientBoostingRegressor.init requires a PythonBridge instance"
      );
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import HistGradientBoostingRegressor
try: bridgeHistGradientBoostingRegressor
except NameError: bridgeHistGradientBoostingRegressor = {}
`;
    await this._py.ex`ctor_HistGradientBoostingRegressor = {'loss': ${this.opts["loss"] ?? void 0}, 'quantile': ${this.opts["quantile"] ?? void 0}, 'learning_rate': ${this.opts["learning_rate"] ?? void 0}, 'max_iter': ${this.opts["max_iter"] ?? void 0}, 'max_leaf_nodes': ${this.opts["max_leaf_nodes"] ?? void 0}, 'max_depth': ${this.opts["max_depth"] ?? void 0}, 'min_samples_leaf': ${this.opts["min_samples_leaf"] ?? void 0}, 'l2_regularization': ${this.opts["l2_regularization"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'max_bins': ${this.opts["max_bins"] ?? void 0}, 'categorical_features': np.array(${this.opts["categorical_features"] ?? void 0}) if ${this.opts["categorical_features"] !== void 0} else None, 'monotonic_cst': np.array(${this.opts["monotonic_cst"] ?? void 0}) if ${this.opts["monotonic_cst"] !== void 0} else None, 'interaction_cst': ${this.opts["interaction_cst"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}, 'early_stopping': ${this.opts["early_stopping"] ?? void 0}, 'scoring': ${this.opts["scoring"] ?? void 0}, 'validation_fraction': ${this.opts["validation_fraction"] ?? void 0}, 'n_iter_no_change': ${this.opts["n_iter_no_change"] ?? void 0}, 'tol': ${this.opts["tol"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}}

ctor_HistGradientBoostingRegressor = {k: v for k, v in ctor_HistGradientBoostingRegressor.items() if v is not None}`;
    await this._py.ex`bridgeHistGradientBoostingRegressor[${this.id}] = HistGradientBoostingRegressor(**ctor_HistGradientBoostingRegressor)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeHistGradientBoostingRegressor[${this.id}]`;
    this._isDisposed = true;
  }
  /**
    Fit the gradient boosting model.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before fit()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingRegressor_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_HistGradientBoostingRegressor_fit = {k: v for k, v in pms_HistGradientBoostingRegressor_fit.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingRegressor_fit = bridgeHistGradientBoostingRegressor[${this.id}].fit(**pms_HistGradientBoostingRegressor_fit)`;
    return this._py`res_HistGradientBoostingRegressor_fit.tolist() if hasattr(res_HistGradientBoostingRegressor_fit, 'tolist') else res_HistGradientBoostingRegressor_fit`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingRegressor_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_HistGradientBoostingRegressor_get_metadata_routing = {k: v for k, v in pms_HistGradientBoostingRegressor_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingRegressor_get_metadata_routing = bridgeHistGradientBoostingRegressor[${this.id}].get_metadata_routing(**pms_HistGradientBoostingRegressor_get_metadata_routing)`;
    return this._py`res_HistGradientBoostingRegressor_get_metadata_routing.tolist() if hasattr(res_HistGradientBoostingRegressor_get_metadata_routing, 'tolist') else res_HistGradientBoostingRegressor_get_metadata_routing`;
  }
  /**
    Predict values for X.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before predict()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingRegressor_predict = {'X': ${opts["X"] ?? void 0}}

pms_HistGradientBoostingRegressor_predict = {k: v for k, v in pms_HistGradientBoostingRegressor_predict.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingRegressor_predict = bridgeHistGradientBoostingRegressor[${this.id}].predict(**pms_HistGradientBoostingRegressor_predict)`;
    return this._py`res_HistGradientBoostingRegressor_predict.tolist() if hasattr(res_HistGradientBoostingRegressor_predict, 'tolist') else res_HistGradientBoostingRegressor_predict`;
  }
  /**
      Return the coefficient of determination of the prediction.
  
      The coefficient of determination \\(R^2\\) is defined as \\((1 - \\frac{u}{v})\\), where \\(u\\) is the residual sum of squares `((y_true \- y_pred)\*\* 2).sum()` and \\(v\\) is the total sum of squares `((y_true \- y_true.mean()) \*\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\(R^2\\) score of 0.0.
     */
  async score(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before score()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingRegressor_score = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': np.array(${opts["y"] ?? void 0}) if ${opts["y"] !== void 0} else None, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_HistGradientBoostingRegressor_score = {k: v for k, v in pms_HistGradientBoostingRegressor_score.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingRegressor_score = bridgeHistGradientBoostingRegressor[${this.id}].score(**pms_HistGradientBoostingRegressor_score)`;
    return this._py`res_HistGradientBoostingRegressor_score.tolist() if hasattr(res_HistGradientBoostingRegressor_score, 'tolist') else res_HistGradientBoostingRegressor_score`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingRegressor_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_HistGradientBoostingRegressor_set_fit_request = {k: v for k, v in pms_HistGradientBoostingRegressor_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingRegressor_set_fit_request = bridgeHistGradientBoostingRegressor[${this.id}].set_fit_request(**pms_HistGradientBoostingRegressor_set_fit_request)`;
    return this._py`res_HistGradientBoostingRegressor_set_fit_request.tolist() if hasattr(res_HistGradientBoostingRegressor_set_fit_request, 'tolist') else res_HistGradientBoostingRegressor_set_fit_request`;
  }
  /**
      Request metadata passed to the `score` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_score_request(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before set_score_request()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingRegressor_set_score_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_HistGradientBoostingRegressor_set_score_request = {k: v for k, v in pms_HistGradientBoostingRegressor_set_score_request.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingRegressor_set_score_request = bridgeHistGradientBoostingRegressor[${this.id}].set_score_request(**pms_HistGradientBoostingRegressor_set_score_request)`;
    return this._py`res_HistGradientBoostingRegressor_set_score_request.tolist() if hasattr(res_HistGradientBoostingRegressor_set_score_request, 'tolist') else res_HistGradientBoostingRegressor_set_score_request`;
  }
  /**
      Predict regression target for each iteration.
  
      This method allows monitoring (i.e. determine error on testing set) after each stage.
     */
  async staged_predict(opts) {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before staged_predict()"
      );
    }
    await this._py.ex`pms_HistGradientBoostingRegressor_staged_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_HistGradientBoostingRegressor_staged_predict = {k: v for k, v in pms_HistGradientBoostingRegressor_staged_predict.items() if v is not None}`;
    await this._py.ex`res_HistGradientBoostingRegressor_staged_predict = bridgeHistGradientBoostingRegressor[${this.id}].staged_predict(**pms_HistGradientBoostingRegressor_staged_predict)`;
    return this._py`res_HistGradientBoostingRegressor_staged_predict.tolist() if hasattr(res_HistGradientBoostingRegressor_staged_predict, 'tolist') else res_HistGradientBoostingRegressor_staged_predict`;
  }
  /**
    Indicates whether early stopping is used during training.
   */
  get do_early_stopping_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before accessing do_early_stopping_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingRegressor_do_early_stopping_ = bridgeHistGradientBoostingRegressor[${this.id}].do_early_stopping_`;
      return this._py`attr_HistGradientBoostingRegressor_do_early_stopping_.tolist() if hasattr(attr_HistGradientBoostingRegressor_do_early_stopping_, 'tolist') else attr_HistGradientBoostingRegressor_do_early_stopping_`;
    })();
  }
  /**
    The number of tree that are built at each iteration. For regressors, this is always 1.
   */
  get n_trees_per_iteration_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before accessing n_trees_per_iteration_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingRegressor_n_trees_per_iteration_ = bridgeHistGradientBoostingRegressor[${this.id}].n_trees_per_iteration_`;
      return this._py`attr_HistGradientBoostingRegressor_n_trees_per_iteration_.tolist() if hasattr(attr_HistGradientBoostingRegressor_n_trees_per_iteration_, 'tolist') else attr_HistGradientBoostingRegressor_n_trees_per_iteration_`;
    })();
  }
  /**
    The scores at each iteration on the training data. The first entry is the score of the ensemble before the first iteration. Scores are computed according to the `scoring` parameter. If `scoring` is not ‘loss’, scores are computed on a subset of at most 10 000 samples. Empty if no early stopping.
   */
  get train_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before accessing train_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingRegressor_train_score_ = bridgeHistGradientBoostingRegressor[${this.id}].train_score_`;
      return this._py`attr_HistGradientBoostingRegressor_train_score_.tolist() if hasattr(attr_HistGradientBoostingRegressor_train_score_, 'tolist') else attr_HistGradientBoostingRegressor_train_score_`;
    })();
  }
  /**
    The scores at each iteration on the held-out validation data. The first entry is the score of the ensemble before the first iteration. Scores are computed according to the `scoring` parameter. Empty if no early stopping or if `validation_fraction` is `undefined`.
   */
  get validation_score_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before accessing validation_score_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingRegressor_validation_score_ = bridgeHistGradientBoostingRegressor[${this.id}].validation_score_`;
      return this._py`attr_HistGradientBoostingRegressor_validation_score_.tolist() if hasattr(attr_HistGradientBoostingRegressor_validation_score_, 'tolist') else attr_HistGradientBoostingRegressor_validation_score_`;
    })();
  }
  /**
    Boolean mask for the categorical features. `undefined` if there are no categorical features.
   */
  get is_categorical_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before accessing is_categorical_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingRegressor_is_categorical_ = bridgeHistGradientBoostingRegressor[${this.id}].is_categorical_`;
      return this._py`attr_HistGradientBoostingRegressor_is_categorical_.tolist() if hasattr(attr_HistGradientBoostingRegressor_is_categorical_, 'tolist') else attr_HistGradientBoostingRegressor_is_categorical_`;
    })();
  }
  /**
    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingRegressor_n_features_in_ = bridgeHistGradientBoostingRegressor[${this.id}].n_features_in_`;
      return this._py`attr_HistGradientBoostingRegressor_n_features_in_.tolist() if hasattr(attr_HistGradientBoostingRegressor_n_features_in_, 'tolist') else attr_HistGradientBoostingRegressor_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error(
        "This HistGradientBoostingRegressor instance has already been disposed"
      );
    }
    if (!this._isInitialized) {
      throw new Error(
        "HistGradientBoostingRegressor must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HistGradientBoostingRegressor_feature_names_in_ = bridgeHistGradientBoostingRegressor[${this.id}].feature_names_in_`;
      return this._py`attr_HistGradientBoostingRegressor_feature_names_in_.tolist() if hasattr(attr_HistGradientBoostingRegressor_feature_names_in_, 'tolist') else attr_HistGradientBoostingRegressor_feature_names_in_`;
    })();
  }
};

// src/generated/ensemble/IsolationForest.ts
import crypto59 from "node:crypto";
var IsolationForest = class {
  id;
  opts;
  _py;
  _isInitialized = false;
  _isDisposed = false;
  constructor(opts) {
    this.id = `IsolationForest${crypto59.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge2) {
    this._py = pythonBridge2;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This IsolationForest instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("IsolationForest.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.ensemble import IsolationForest
try: bridgeIsolationForest
except NameError: bridgeIsolationForest = {}
`;
    await this._py.ex`ctor_IsolationForest = {'n_estimators': ${this.opts["n_estimators"] ?? void 0}, 'max_samples': ${this.opts["max_samples"] ?? void 0}, 'contamination': ${this.opts["contamination"] ?? void 0}, 'max_features': ${this.opts["max_features"] ?? void 0}, 'bootstrap': ${this.opts["bootstrap"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'random_state': ${this.opts["random_state"] ?? void 0}, 'verbose': ${this.opts["verbose"] ?? void 0}, 'warm_start': ${this.opts["warm_start"] ?? void 0}}

ctor_IsolationForest = {k: v for k, v in ctor_IsolationForest.items() if v is not None}`;
    await this._py.ex`bridgeIsolationForest[${this.id}] = IsolationForest(**ctor_IsolationForest)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeIsolationForest[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Average anomaly score of X of the base classifiers.
  
      The anomaly score of an input sample is computed as the mean anomaly score of the trees in the forest.
  
      The measure of normality of an observation given a tree is the depth of the leaf containing this observation, which is equivalent to the number of splittings required to isolate this point. In case of several observations n_left in the leaf, the average path length of a n_left samples isolation tree is added.
     */
  async decision_function(opts) {
    if (this._isDisposed) {
      throw new Error("This IsolationForest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsolationForest must call init() before decision_function()"
      );
    }
    await this._py.ex`pms_IsolationForest_decision_function = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_IsolationForest_decision_function = {k: v for k, v in pms_IsolationForest_decision_function.items() if v is not None}`;
    await this._py.ex`res_IsolationForest_decision_function = bridgeIsolationForest[${this.id}].decision_function(**pms_IsolationForest_decision_function)`;
    return this._py`res_IsolationForest_decision_function.tolist() if hasattr(res_IsolationForest_decision_function, 'tolist') else res_IsolationForest_decision_function`;
  }
  /**
    Fit estimator.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This IsolationForest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IsolationForest must call init() before fit()");
    }
    await this._py.ex`pms_IsolationForest_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'sample_weight': np.array(${opts["sample_weight"] ?? void 0}) if ${opts["sample_weight"] !== void 0} else None}

pms_IsolationForest_fit = {k: v for k, v in pms_IsolationForest_fit.items() if v is not None}`;
    await this._py.ex`res_IsolationForest_fit = bridgeIsolationForest[${this.id}].fit(**pms_IsolationForest_fit)`;
    return this._py`res_IsolationForest_fit.tolist() if hasattr(res_IsolationForest_fit, 'tolist') else res_IsolationForest_fit`;
  }
  /**
      Perform fit on X and returns labels for X.
  
      Returns -1 for outliers and 1 for inliers.
     */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This IsolationForest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IsolationForest must call init() before fit_predict()");
    }
    await this._py.ex`pms_IsolationForest_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}, 'kwargs': ${opts["kwargs"] ?? void 0}}

pms_IsolationForest_fit_predict = {k: v for k, v in pms_IsolationForest_fit_predict.items() if v is not None}`;
    await this._py.ex`res_IsolationForest_fit_predict = bridgeIsolationForest[${this.id}].fit_predict(**pms_IsolationForest_fit_predict)`;
    return this._py`res_IsolationForest_fit_predict.tolist() if hasattr(res_IsolationForest_fit_predict, 'tolist') else res_IsolationForest_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This IsolationForest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsolationForest must call init() before get_metadata_routing()"
      );
    }
    await this._py.ex`pms_IsolationForest_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_IsolationForest_get_metadata_routing = {k: v for k, v in pms_IsolationForest_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_IsolationForest_get_metadata_routing = bridgeIsolationForest[${this.id}].get_metadata_routing(**pms_IsolationForest_get_metadata_routing)`;
    return this._py`res_IsolationForest_get_metadata_routing.tolist() if hasattr(res_IsolationForest_get_metadata_routing, 'tolist') else res_IsolationForest_get_metadata_routing`;
  }
  /**
    Predict if a particular sample is an outlier or not.
   */
  async predict(opts) {
    if (this._isDisposed) {
      throw new Error("This IsolationForest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IsolationForest must call init() before predict()");
    }
    await this._py.ex`pms_IsolationForest_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_IsolationForest_predict = {k: v for k, v in pms_IsolationForest_predict.items() if v is not None}`;
    await this._py.ex`res_IsolationForest_predict = bridgeIsolationForest[${this.id}].predict(**pms_IsolationForest_predict)`;
    return this._py`res_IsolationForest_predict.tolist() if hasattr(res_IsolationForest_predict, 'tolist') else res_IsolationForest_predict`;
  }
  /**
      Opposite of the anomaly score defined in the original paper.
  
      The anomaly score of an input sample is computed as the mean anomaly score of the trees in the forest.
  
      The measure of normality of an observation given a tree is the depth of the leaf containing this observation, which is equivalent to the number of splittings required to isolate this point. In case of several observations n_left in the leaf, the average path length of a n_left samples isolation tree is added.
     */
  async score_samples(opts) {
    if (this._isDisposed) {
      throw new Error("This IsolationForest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("IsolationForest must call init() before score_samples()");
    }
    await this._py.ex`pms_IsolationForest_score_samples = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None}

pms_IsolationForest_score_samples = {k: v for k, v in pms_IsolationForest_score_samples.items() if v is not None}`;
    await this._py.ex`res_IsolationForest_score_samples = bridgeIsolationForest[${this.id}].score_samples(**pms_IsolationForest_score_samples)`;
    return this._py`res_IsolationForest_score_samples.tolist() if hasattr(res_IsolationForest_score_samples, 'tolist') else res_IsolationForest_score_samples`;
  }
  /**
      Request metadata passed to the `fit` method.
  
      Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config "sklearn.set_config")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
  
      The options for each parameter are:
     */
  async set_fit_request(opts) {
    if (this._isDisposed) {
      throw new Error("This IsolationForest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsolationForest must call init() before set_fit_request()"
      );
    }
    await this._py.ex`pms_IsolationForest_set_fit_request = {'sample_weight': ${opts["sample_weight"] ?? void 0}}

pms_IsolationForest_set_fit_request = {k: v for k, v in pms_IsolationForest_set_fit_request.items() if v is not None}`;
    await this._py.ex`res_IsolationForest_set_fit_request = bridgeIsolationForest[${this.id}].set_fit_request(**pms_IsolationForest_set_fit_request)`;
    return this._py`res_IsolationForest_set_fit_request.tolist() if hasattr(res_IsolationForest_set_fit_request, 'tolist') else res_IsolationForest_set_fit_request`;
  }
  /**
    The child estimator template used to create the collection of fitted sub-estimators.
   */
  get estimator_() {
    if (this._isDisposed) {
      throw new Error("This IsolationForest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsolationForest must call init() before accessing estimator_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IsolationForest_estimator_ = bridgeIsolationForest[${this.id}].estimator_`;
      return this._py`attr_IsolationForest_estimator_.tolist() if hasattr(attr_IsolationForest_estimator_, 'tolist') else attr_IsolationForest_estimator_`;
    })();
  }
  /**
    The collection of fitted sub-estimators.
   */
  get estimators_() {
    if (this._isDisposed) {
      throw new Error("This IsolationForest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsolationForest must call init() before accessing estimators_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IsolationForest_estimators_ = bridgeIsolationForest[${this.id}].estimators_`;
      return this._py`attr_IsolationForest_estimators_.tolist() if hasattr(attr_IsolationForest_estimators_, 'tolist') else attr_IsolationForest_estimators_`;
    })();
  }
  /**
    The subset of drawn features for each base estimator.
   */
  get estimators_features_() {
    if (this._isDisposed) {
      throw new Error("This IsolationForest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsolationForest must call init() before accessing estimators_features_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IsolationForest_estimators_features_ = bridgeIsolationForest[${this.id}].estimators_features_`;
      return this._py`attr_IsolationForest_estimators_features_.tolist() if hasattr(attr_IsolationForest_estimators_features_, 'tolist') else attr_IsolationForest_estimators_features_`;
    })();
  }
  /**
    The actual number of samples.
   */
  get max_samples_() {
    if (this._isDisposed) {
      throw new Error("This IsolationForest instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "IsolationForest must call init() before accessing max_samples_"
      );
    }
    return (async () => {
      await this._py.ex`attr_IsolationForest_max_samples_ = bridgeIsolationForest[${this.id}].max_samples_`;
      return this._py`attr_IsolationForest_max_samples_.tolist() if hasattr(attr_IsolationForest_max_samples_, 'tolist') else attr_IsolationForest_max_samples_`;
    })();
  }
  /**
    Offset used to 